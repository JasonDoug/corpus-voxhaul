{
  "version": 3,
  "sources": ["../../../../../../../tmp/tmpma852cac/src/utils/logger.ts", "../../deps/5c41b908-6789-483b-a8d5-dfc5d76c2510/node_modules/dotenv/package.json", "../../deps/5c41b908-6789-483b-a8d5-dfc5d76c2510/node_modules/dotenv/lib/main.js", "../../../../../../../tmp/tmpma852cac/src/utils/config.ts", "../../../../../../../tmp/tmpma852cac/src/services/dynamodb.ts", "../../../../../../../tmp/tmpma852cac/src/functions/audio.ts", "../../../../../../../tmp/tmpma852cac/src/services/audio-synthesizer.ts", "../../../../../../../tmp/tmpma852cac/src/utils/retry.ts", "../../../../../../../tmp/tmpma852cac/src/utils/errors.ts", "../../../../../../../tmp/tmpma852cac/src/services/s3.ts", "../../../../../../../tmp/tmpma852cac/src/services/eventbridge.ts"],
  "sourcesContent": ["// Logging utility with structured JSON logging, correlation IDs, and sensitive data redaction\n\nexport enum LogLevel {\n  ERROR = 'ERROR',\n  WARN = 'WARN',\n  INFO = 'INFO',\n  DEBUG = 'DEBUG',\n}\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  correlationId?: string;\n  metadata?: Record<string, any>;\n  service?: string;\n  function?: string;\n}\n\n// Sensitive field patterns to redact\nconst SENSITIVE_PATTERNS = [\n  /password/i,\n  /secret/i,\n  /token/i,\n  /apikey/i,\n  /api[_-]?key/i,\n  /authorization/i,\n  /auth/i,\n  /credential/i,\n  /private[_-]?key/i,\n  /access[_-]?key/i,\n];\n\nclass Logger {\n  private correlationId?: string;\n  private serviceName?: string;\n  private functionName?: string;\n  private minLogLevel: LogLevel;\n\n  constructor() {\n    // Set minimum log level from environment or default to INFO\n    const envLogLevel = process.env.LOG_LEVEL?.toUpperCase() as LogLevel;\n    this.minLogLevel = envLogLevel || LogLevel.INFO;\n  }\n\n  setCorrelationId(id: string) {\n    this.correlationId = id;\n  }\n\n  getCorrelationId(): string | undefined {\n    return this.correlationId;\n  }\n\n  setServiceName(name: string) {\n    this.serviceName = name;\n  }\n\n  setFunctionName(name: string) {\n    this.functionName = name;\n  }\n\n  /**\n   * Redact sensitive data from metadata\n   */\n  private redactSensitiveData(data: any): any {\n    if (data === null || data === undefined) {\n      return data;\n    }\n\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(item => this.redactSensitiveData(item));\n    }\n\n    if (typeof data === 'object') {\n      const redacted: Record<string, any> = {};\n      for (const [key, value] of Object.entries(data)) {\n        // Check if key matches sensitive patterns\n        const isSensitive = SENSITIVE_PATTERNS.some(pattern => pattern.test(key));\n        \n        if (isSensitive) {\n          redacted[key] = '[REDACTED]';\n        } else if (typeof value === 'object' && value !== null) {\n          redacted[key] = this.redactSensitiveData(value);\n        } else {\n          redacted[key] = value;\n        }\n      }\n      return redacted;\n    }\n\n    return data;\n  }\n\n  /**\n   * Check if log level should be logged based on minimum level\n   */\n  private shouldLog(level: LogLevel): boolean {\n    const levels = [LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG];\n    const currentLevelIndex = levels.indexOf(level);\n    const minLevelIndex = levels.indexOf(this.minLogLevel);\n    return currentLevelIndex <= minLevelIndex;\n  }\n\n  private log(level: LogLevel, message: string, metadata?: Record<string, any>) {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      correlationId: this.correlationId,\n      service: this.serviceName,\n      function: this.functionName,\n      metadata: metadata ? this.redactSensitiveData(metadata) : undefined,\n    };\n    \n    // Output as JSON for structured logging\n    console.log(JSON.stringify(entry));\n  }\n\n  error(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.ERROR, message, metadata);\n  }\n\n  warn(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.WARN, message, metadata);\n  }\n\n  info(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.INFO, message, metadata);\n  }\n\n  debug(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.DEBUG, message, metadata);\n  }\n\n  /**\n   * Create a child logger with a specific correlation ID\n   */\n  child(correlationId: string): Logger {\n    const childLogger = new Logger();\n    childLogger.setCorrelationId(correlationId);\n    childLogger.setServiceName(this.serviceName || '');\n    childLogger.setFunctionName(this.functionName || '');\n    return childLogger;\n  }\n}\n\nexport const logger = new Logger();\n", "{\n  \"name\": \"dotenv\",\n  \"version\": \"16.6.1\",\n  \"description\": \"Loads environment variables from .env file\",\n  \"main\": \"lib/main.js\",\n  \"types\": \"lib/main.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./lib/main.d.ts\",\n      \"require\": \"./lib/main.js\",\n      \"default\": \"./lib/main.js\"\n    },\n    \"./config\": \"./config.js\",\n    \"./config.js\": \"./config.js\",\n    \"./lib/env-options\": \"./lib/env-options.js\",\n    \"./lib/env-options.js\": \"./lib/env-options.js\",\n    \"./lib/cli-options\": \"./lib/cli-options.js\",\n    \"./lib/cli-options.js\": \"./lib/cli-options.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"dts-check\": \"tsc --project tests/types/tsconfig.json\",\n    \"lint\": \"standard\",\n    \"pretest\": \"npm run lint && npm run dts-check\",\n    \"test\": \"tap run --allow-empty-coverage --disable-coverage --timeout=60000\",\n    \"test:coverage\": \"tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\n    \"prerelease\": \"npm test\",\n    \"release\": \"standard-version\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/motdotla/dotenv.git\"\n  },\n  \"homepage\": \"https://github.com/motdotla/dotenv#readme\",\n  \"funding\": \"https://dotenvx.com\",\n  \"keywords\": [\n    \"dotenv\",\n    \"env\",\n    \".env\",\n    \"environment\",\n    \"variables\",\n    \"config\",\n    \"settings\"\n  ],\n  \"readmeFilename\": \"README.md\",\n  \"license\": \"BSD-2-Clause\",\n  \"devDependencies\": {\n    \"@types/node\": \"^18.11.3\",\n    \"decache\": \"^4.6.2\",\n    \"sinon\": \"^14.0.1\",\n    \"standard\": \"^17.0.0\",\n    \"standard-version\": \"^9.5.0\",\n    \"tap\": \"^19.2.0\",\n    \"typescript\": \"^4.8.4\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"browser\": {\n    \"fs\": false\n  }\n}\n", "const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.log(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsedAll, options)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(parsedAll).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n    }\n  }\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n", "// Configuration utilities\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const config = {\n  nodeEnv: process.env.NODE_ENV || 'development',\n  port: parseInt(process.env.PORT || '3000', 10),\n  localMode: process.env.LOCAL_MODE === 'true',\n  isLocal: process.env.NODE_ENV !== 'production',\n  awsRegion: process.env.AWS_REGION || 'us-east-1',\n  eventBusName: process.env.EVENT_BUS_NAME || 'pdf-lecture-service-events',\n  \n  aws: {\n    region: process.env.AWS_REGION || 'us-east-1',\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  },\n  \n  localstack: {\n    endpoint: process.env.LOCALSTACK_ENDPOINT || 'http://localhost:4566',\n    useLocalStack: process.env.USE_LOCALSTACK === 'true',\n  },\n  \n  s3: {\n    bucketName: process.env.S3_BUCKET_NAME || 'pdf-lecture-service',\n    pdfPrefix: process.env.S3_PDF_PREFIX || 'pdfs',\n    audioPrefix: process.env.S3_AUDIO_PREFIX || 'audio',\n    cachePrefix: process.env.S3_CACHE_PREFIX || 'cache',\n  },\n  \n  dynamodb: {\n    jobsTable: process.env.DYNAMODB_TABLE_JOBS || 'pdf-lecture-jobs',\n    agentsTable: process.env.DYNAMODB_TABLE_AGENTS || 'pdf-lecture-agents',\n    contentTable: process.env.DYNAMODB_TABLE_CONTENT || 'pdf-lecture-content',\n  },\n  \n  processing: {\n    maxPdfSizeMB: parseInt(process.env.MAX_PDF_SIZE_MB || '100', 10),\n    analysisTimeoutMs: parseInt(process.env.ANALYSIS_TIMEOUT_MS || '300000', 10),\n    audioSynthesisTimeoutMs: parseInt(process.env.AUDIO_SYNTHESIS_TIMEOUT_MS || '600000', 10),\n  },\n  \n  featureFlags: {\n    enableRealSegmentation: process.env.ENABLE_REAL_SEGMENTATION === 'true',\n    enableRealScriptGeneration: process.env.ENABLE_REAL_SCRIPT_GENERATION === 'true',\n    enableImageExtraction: process.env.ENABLE_IMAGE_EXTRACTION === 'true',\n    enableVisionFirstPipeline: process.env.ENABLE_VISION_FIRST_PIPELINE === 'true',\n  },\n  \n  vision: {\n    model: process.env.VISION_MODEL || 'google/gemini-2.0-flash-exp:free',\n    temperature: parseFloat(process.env.VISION_LLM_TEMPERATURE || '0.3'),\n    maxTokens: parseInt(process.env.VISION_LLM_MAX_TOKENS || '4000', 10),\n  },\n};\n", "// DynamoDB client wrapper with local/production mode support\nimport AWS from 'aws-sdk';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\nimport { Job, JobStatus, StageStatus } from '../models/job';\nimport { LectureAgent } from '../models/agent';\nimport { ExtractedContent, SegmentedContent } from '../models/content';\nimport { WordTiming } from '../models/audio';\n\n// Configure AWS SDK based on environment\nconst dynamoDBConfig: AWS.DynamoDB.ClientConfiguration = {\n  region: config.aws.region,\n};\n\nif (config.localstack.useLocalStack) {\n  dynamoDBConfig.endpoint = config.localstack.endpoint;\n  dynamoDBConfig.accessKeyId = 'test';\n  dynamoDBConfig.secretAccessKey = 'test';\n}\n// In Lambda, don't set credentials - they're provided automatically via execution role\n\nconst dynamoDB = new AWS.DynamoDB.DocumentClient(dynamoDBConfig);\n\n// Helper function to handle DynamoDB errors\nfunction handleDynamoDBError(error: any, operation: string): never {\n  logger.error(`DynamoDB ${operation} failed`, { error: error.message });\n  throw new Error(`Database operation failed: ${operation}`);\n}\n\n// ============================================================================\n// Jobs Table Operations\n// ============================================================================\n\nexport interface JobRecord {\n  jobId: string;\n  status: JobStatus;\n  createdAt: string;\n  updatedAt: string;\n  pdfFilename: string;\n  pdfUrl: string;\n  agentId?: string;\n  stages: StageStatus[];\n  error?: string;\n}\n\nfunction jobToRecord(job: Job): JobRecord {\n  return {\n    ...job,\n    createdAt: job.createdAt.toISOString(),\n    updatedAt: job.updatedAt.toISOString(),\n  };\n}\n\nfunction recordToJob(record: JobRecord): Job {\n  return {\n    ...record,\n    createdAt: new Date(record.createdAt),\n    updatedAt: new Date(record.updatedAt),\n    stages: record.stages.map(stage => ({\n      ...stage,\n      startedAt: stage.startedAt ? new Date(stage.startedAt) : undefined,\n      completedAt: stage.completedAt ? new Date(stage.completedAt) : undefined,\n    })),\n  };\n}\n\nexport async function createJob(job: Job): Promise<Job> {\n  try {\n    const record = jobToRecord(job);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job created', { jobId: job.jobId });\n    return job;\n  } catch (error) {\n    handleDynamoDBError(error, 'createJob');\n  }\n}\n\nexport async function getJob(jobId: string): Promise<Job | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToJob(result.Item as JobRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getJob');\n  }\n}\n\nexport async function updateJob(jobId: string, updates: Partial<Job>): Promise<Job> {\n  try {\n    const current = await getJob(jobId);\n    if (!current) {\n      throw new Error(`Job not found: ${jobId}`);\n    }\n    \n    const updated: Job = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date(),\n    };\n    \n    const record = jobToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateJob');\n  }\n}\n\nexport async function deleteJob(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Job deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteJob');\n  }\n}\n\nexport async function listJobs(): Promise<Job[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.jobsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToJob(item as JobRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listJobs');\n  }\n}\n\n// ============================================================================\n// Agents Table Operations\n// ============================================================================\n\nexport interface AgentRecord {\n  id: string;\n  name: string;\n  description: string;\n  personality: {\n    instructions: string;\n    tone: string;\n    examples?: string[];\n  };\n  voice: {\n    voiceId: string;\n    speed: number;\n    pitch: number;\n  };\n  createdAt: string;\n}\n\nfunction agentToRecord(agent: LectureAgent): AgentRecord {\n  return {\n    ...agent,\n    createdAt: agent.createdAt.toISOString(),\n  };\n}\n\nfunction recordToAgent(record: AgentRecord): LectureAgent {\n  return {\n    ...record,\n    personality: {\n      ...record.personality,\n      tone: record.personality.tone as any,\n    },\n    createdAt: new Date(record.createdAt),\n  };\n}\n\nexport async function createAgent(agent: LectureAgent): Promise<LectureAgent> {\n  try {\n    // Check for unique name\n    const existing = await listAgents();\n    if (existing.some(a => a.name === agent.name && a.id !== agent.id)) {\n      throw new Error(`Agent with name \"${agent.name}\" already exists`);\n    }\n    \n    const record = agentToRecord(agent);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent created', { agentId: agent.id, name: agent.name });\n    return agent;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('already exists')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'createAgent');\n  }\n}\n\nexport async function getAgent(id: string): Promise<LectureAgent | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToAgent(result.Item as AgentRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getAgent');\n  }\n}\n\nexport async function updateAgent(id: string, updates: Partial<LectureAgent>): Promise<LectureAgent> {\n  try {\n    const current = await getAgent(id);\n    if (!current) {\n      throw new Error(`Agent not found: ${id}`);\n    }\n    \n    // Check for unique name if name is being updated\n    if (updates.name && updates.name !== current.name) {\n      const existing = await listAgents();\n      if (existing.some(a => a.name === updates.name && a.id !== id)) {\n        throw new Error(`Agent with name \"${updates.name}\" already exists`);\n      }\n    }\n    \n    const updated: LectureAgent = {\n      ...current,\n      ...updates,\n      id, // Ensure id doesn't change\n      // Deep merge nested objects\n      personality: updates.personality ? {\n        ...current.personality,\n        ...updates.personality,\n      } : current.personality,\n      voice: updates.voice ? {\n        ...current.voice,\n        ...updates.voice,\n      } : current.voice,\n    };\n    \n    const record = agentToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent updated', { agentId: id });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && (error.message.includes('already exists') || error.message.includes('not found'))) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateAgent');\n  }\n}\n\nexport async function deleteAgent(id: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    logger.info('Agent deleted', { agentId: id });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteAgent');\n  }\n}\n\nexport async function listAgents(): Promise<LectureAgent[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.agentsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToAgent(item as AgentRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listAgents');\n  }\n}\n\n// ============================================================================\n// Content Table Operations\n// ============================================================================\n\nexport interface ContentRecord {\n  jobId: string;\n  extractedContent?: ExtractedContent;\n  segmentedContent?: SegmentedContent;\n  script?: any; // LectureScript type from script model\n  audioUrl?: string;\n  wordTimings?: WordTiming[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport async function createContent(jobId: string): Promise<ContentRecord> {\n  try {\n    const record: ContentRecord = {\n      jobId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Content record created', { jobId });\n    return record;\n  } catch (error) {\n    handleDynamoDBError(error, 'createContent');\n  }\n}\n\nexport async function getContent(jobId: string): Promise<ContentRecord | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return result.Item as ContentRecord;\n  } catch (error) {\n    handleDynamoDBError(error, 'getContent');\n  }\n}\n\nexport async function updateContent(jobId: string, updates: Partial<ContentRecord>): Promise<ContentRecord> {\n  try {\n    const current = await getContent(jobId);\n    if (!current) {\n      throw new Error(`Content not found for job: ${jobId}`);\n    }\n    \n    const updated: ContentRecord = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: updated,\n    }).promise();\n    \n    logger.info('Content updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateContent');\n  }\n}\n\nexport async function deleteContent(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Content deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteContent');\n  }\n}\n\n// ============================================================================\n// Table Creation (for local development)\n// ============================================================================\n\nexport async function createTablesIfNotExist(): Promise<void> {\n  if (!config.localstack.useLocalStack) {\n    logger.info('Skipping table creation in production mode');\n    return;\n  }\n  \n  const dynamoDBClient = new AWS.DynamoDB(dynamoDBConfig);\n  \n  const tables = [\n    {\n      TableName: config.dynamodb.jobsTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.agentsTable,\n      KeySchema: [{ AttributeName: 'id', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'id', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.contentTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n  ];\n  \n  for (const tableConfig of tables) {\n    try {\n      await dynamoDBClient.describeTable({ TableName: tableConfig.TableName }).promise();\n      logger.info(`Table ${tableConfig.TableName} already exists`);\n    } catch (error: any) {\n      if (error.code === 'ResourceNotFoundException') {\n        try {\n          await dynamoDBClient.createTable({\n            ...tableConfig,\n            BillingMode: 'PAY_PER_REQUEST',\n          }).promise();\n          logger.info(`Table ${tableConfig.TableName} created`);\n        } catch (createError) {\n          logger.error(`Failed to create table ${tableConfig.TableName}`, { error: createError });\n        }\n      }\n    }\n  }\n}\n", "// Audio Synthesizer function - Serverless function wrapper\nimport { synthesizeAudio } from '../services/audio-synthesizer';\nimport { getJob, updateJob } from '../services/dynamodb';\nimport { publishJobCompleted } from '../services/eventbridge';\nimport { ErrorResponse } from '../models/errors';\nimport { logger } from '../utils/logger';\nimport { config } from '../utils/config';\n\n/**\n * Lambda handler for audio synthesis\n * This function synthesizes audio from the lecture script,\n * extracts word-level timing data, and marks the job as completed.\n */\nexport async function audioHandler(event: any): Promise<any> {\n  try {\n    logger.info('Audio synthesizer function invoked');\n    \n    // Parse the request\n    const jobId = event.jobId;\n    \n    if (!jobId) {\n      throw new Error('jobId is required');\n    }\n    \n    // Get the job\n    const job = await getJob(jobId);\n    if (!job) {\n      throw new Error(`Job not found: ${jobId}`);\n    }\n    \n    // Update job status to 'synthesizing_audio'\n    await updateJob(jobId, {\n      status: 'synthesizing_audio',\n      stages: job.stages.map(stage =>\n        stage.stage === 'audio_synthesis'\n          ? { ...stage, status: 'in_progress', startedAt: new Date() }\n          : stage\n      ),\n    });\n    \n    logger.info('Starting audio synthesis', { jobId });\n    \n    // Synthesize the audio\n    const audioOutput = await synthesizeAudio(jobId);\n    \n    // Job status is updated to 'completed' by synthesizeAudio\n    \n    logger.info('Audio synthesis completed successfully', { jobId });\n    \n    // Publish job completion event in production\n    if (config.nodeEnv === 'production') {\n      await publishJobCompleted(jobId);\n      logger.info('Job completion event published', { jobId });\n    }\n    \n    return {\n      statusCode: 200,\n      body: JSON.stringify({\n        jobId,\n        status: 'completed',\n        message: 'Audio synthesis completed',\n        audioOutput: {\n          audioUrl: audioOutput.audioUrl,\n          duration: audioOutput.duration,\n          wordTimingCount: audioOutput.wordTimings.length,\n        },\n      }),\n    };\n  } catch (error) {\n    logger.error('Audio synthesizer handler error', { error });\n    \n    const errorResponse: ErrorResponse = {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      code: 'AUDIO_SYNTHESIS_FAILED',\n      retryable: true,\n    };\n    \n    // Try to update job status to failed\n    if (event.jobId) {\n      try {\n        const job = await getJob(event.jobId);\n        if (job) {\n          await updateJob(event.jobId, {\n            status: 'failed',\n            error: errorResponse.error,\n            stages: job.stages.map(stage =>\n              stage.stage === 'audio_synthesis'\n                ? { ...stage, status: 'failed', error: errorResponse.error }\n                : stage\n            ),\n          });\n        }\n      } catch (updateError) {\n        logger.error('Failed to update job status', { error: updateError });\n      }\n    }\n    \n    return {\n      statusCode: 500,\n      body: JSON.stringify(errorResponse),\n    };\n  }\n}\n", "// Audio Synthesizer service - Convert lecture scripts to MP3 audio with word-level timing\nimport { logger } from '../utils/logger';\nimport { withRetryAndCircuitBreaker } from '../utils/retry';\nimport { ExternalServiceError } from '../utils/errors';\nimport { LectureAgent } from '../models/agent';\nimport { LectureScript } from '../models/script';\nimport { AudioOutput, WordTiming } from '../models/audio';\nimport { uploadAudio } from './s3';\n\n/**\n * TTS Provider interface\n * Abstracts the TTS service to allow different providers\n */\nexport interface TTSProvider {\n  synthesize(text: string, voiceConfig: LectureAgent['voice']): Promise<TTSResult>;\n}\n\nexport interface TTSResult {\n  audioBuffer: Buffer;\n  duration: number;\n  wordTimings: WordTiming[];\n}\n\n/**\n * Mock TTS Provider for testing and development\n * In production, this would be replaced with actual TTS service (AWS Polly, Google TTS, ElevenLabs)\n */\nexport class MockTTSProvider implements TTSProvider {\n  async synthesize(text: string, voiceConfig: LectureAgent['voice']): Promise<TTSResult> {\n    logger.info('Mock TTS synthesis', {\n      textLength: text.length,\n      voiceId: voiceConfig.voiceId,\n      speed: voiceConfig.speed,\n      pitch: voiceConfig.pitch,\n    });\n\n    // Simulate API call delay\n    await new Promise(resolve => setTimeout(resolve, 100));\n\n    // Generate mock audio buffer (empty MP3 header)\n    const audioBuffer = Buffer.from([\n      0xFF, 0xFB, 0x90, 0x00, // MP3 frame header\n      ...Array(1000).fill(0), // Padding\n    ]);\n\n    // Generate mock word timings\n    const words = text.split(/\\s+/).filter(w => w.length > 0);\n    const wordTimings: WordTiming[] = [];\n    \n    // Calculate timing based on voice speed\n    // Base rate: 155 words per minute\n    const wordsPerMinute = 155 * voiceConfig.speed;\n    const secondsPerWord = 60 / wordsPerMinute;\n    \n    let currentTime = 0;\n    for (const word of words) {\n      const wordDuration = secondsPerWord;\n      wordTimings.push({\n        word: word.replace(/[.,!?;:]$/, ''), // Remove trailing punctuation\n        startTime: currentTime,\n        endTime: currentTime + wordDuration,\n        scriptBlockId: 'unknown', // Will be set later\n      });\n      currentTime += wordDuration;\n    }\n\n    const duration = currentTime;\n\n    return {\n      audioBuffer,\n      duration,\n      wordTimings,\n    };\n  }\n}\n\n/**\n * AWS Polly TTS Provider\n * Uses AWS Polly for text-to-speech synthesis\n * \n * Supports multiple engines:\n * - generative: Best quality, most natural (newest, limited voices)\n * - long-form: Optimized for long content (news-style voices)\n * - neural: High quality, natural (most voices available)\n * - standard: Basic quality, fast (all voices available)\n */\nexport class PollyTTSProvider implements TTSProvider {\n  private polly: any; // AWS.Polly instance\n  private engine: string;\n\n  constructor() {\n    // Initialize AWS Polly client\n    const AWS = require('aws-sdk');\n    const { config } = require('../utils/config');\n    \n    const pollyConfig: any = {\n      region: config.aws.region,\n    };\n    \n    if (config.aws.accessKeyId && config.aws.secretAccessKey) {\n      pollyConfig.accessKeyId = config.aws.accessKeyId;\n      pollyConfig.secretAccessKey = config.aws.secretAccessKey;\n    }\n    \n    this.polly = new AWS.Polly(pollyConfig);\n    \n    // Get engine from environment (generative, long-form, neural, standard)\n    this.engine = process.env.POLLY_ENGINE || 'neural';\n    \n    logger.info('AWS Polly TTS Provider initialized', {\n      region: config.aws.region,\n      engine: this.engine,\n    });\n  }\n\n  async synthesize(text: string, voiceConfig: LectureAgent['voice']): Promise<TTSResult> {\n    logger.info('AWS Polly TTS synthesis', {\n      textLength: text.length,\n      voiceId: voiceConfig.voiceId,\n      engine: this.engine,\n    });\n\n    return withRetryAndCircuitBreaker(\n      'aws-polly',\n      async () => {\n        try {\n          // Build synthesis parameters\n          const params: any = {\n            Text: text,\n            OutputFormat: 'mp3',\n            VoiceId: voiceConfig.voiceId,\n            Engine: this.engine,\n          };\n          \n          // Add engine-specific parameters\n          if (this.engine === 'generative') {\n            // Generative engine doesn't support SpeechMarkTypes\n            // We'll need to estimate timings\n            logger.info('Using generative engine (word timings will be estimated)');\n          } else if (this.engine === 'long-form') {\n            // Long-form engine supports speech marks\n            params.SpeechMarkTypes = ['word'];\n          } else {\n            // Neural and standard engines support speech marks\n            params.SpeechMarkTypes = ['word'];\n          }\n\n          // Get audio stream\n          const audioResult = await this.polly.synthesizeSpeech(params).promise();\n          const audioBuffer = audioResult.AudioStream as Buffer;\n\n          let wordTimings: WordTiming[] = [];\n          let duration = 0;\n\n          // Get word timing marks (if supported by engine)\n          if (this.engine !== 'generative') {\n            try {\n              const timingParams = {\n                ...params,\n                OutputFormat: 'json',\n              };\n              const timingResult = await this.polly.synthesizeSpeech(timingParams).promise();\n              const timingData = timingResult.AudioStream.toString('utf-8');\n              \n              // Parse timing marks (each line is a JSON object)\n              const lines = timingData.split('\\n').filter((line: string) => line.trim());\n              \n              for (const line of lines) {\n                try {\n                  const mark = JSON.parse(line);\n                  if (mark.type === 'word') {\n                    wordTimings.push({\n                      word: mark.value,\n                      startTime: mark.time / 1000, // Convert ms to seconds\n                      endTime: (mark.time + (mark.duration || 0)) / 1000,\n                      scriptBlockId: 'unknown', // Will be set later\n                    });\n                  }\n                } catch (e) {\n                  logger.warn('Failed to parse timing mark', { line: line as string });\n                }\n              }\n\n              // Calculate duration from last word timing\n              duration = wordTimings.length > 0\n                ? wordTimings[wordTimings.length - 1].endTime\n                : 0;\n            } catch (timingError) {\n              logger.warn('Failed to get word timings, will estimate', { error: timingError });\n              // Fall through to estimation\n            }\n          }\n\n          // If we don't have timings (generative engine or timing fetch failed), estimate them\n          if (wordTimings.length === 0) {\n            logger.info('Estimating word timings based on voice speed');\n            wordTimings = this.estimateWordTimings(text, voiceConfig.speed);\n            duration = wordTimings.length > 0\n              ? wordTimings[wordTimings.length - 1].endTime\n              : 0;\n          }\n\n          return {\n            audioBuffer,\n            duration,\n            wordTimings,\n          };\n        } catch (error) {\n          logger.error('AWS Polly synthesis failed', { error });\n          throw new ExternalServiceError(\n            `TTS synthesis failed: ${error instanceof Error ? error.message : String(error)}`,\n            'aws-polly',\n            { error }\n          );\n        }\n      },\n      { maxAttempts: 3, initialDelayMs: 1000 },\n      { failureThreshold: 5, timeout: 60000 }\n    );\n  }\n\n  /**\n   * Estimate word timings when actual timings are not available\n   * Used for generative engine or when timing fetch fails\n   */\n  private estimateWordTimings(text: string, speed: number): WordTiming[] {\n    const words = text.split(/\\s+/).filter(w => w.length > 0);\n    const wordTimings: WordTiming[] = [];\n    \n    // Calculate timing based on voice speed\n    // Base rate: 155 words per minute\n    const wordsPerMinute = 155 * speed;\n    const secondsPerWord = 60 / wordsPerMinute;\n    \n    let currentTime = 0;\n    for (const word of words) {\n      const wordDuration = secondsPerWord;\n      wordTimings.push({\n        word: word.replace(/[.,!?;:]$/, ''), // Remove trailing punctuation\n        startTime: currentTime,\n        endTime: currentTime + wordDuration,\n        scriptBlockId: 'unknown', // Will be set later\n      });\n      currentTime += wordDuration;\n    }\n    \n    return wordTimings;\n  }\n}\n\n/**\n * Get TTS provider based on configuration\n */\nexport function getTTSProvider(): TTSProvider {\n  const ttsProvider = process.env.TTS_PROVIDER || 'mock';\n  \n  switch (ttsProvider.toLowerCase()) {\n    case 'polly':\n    case 'aws':\n      return new PollyTTSProvider();\n    case 'mock':\n    default:\n      return new MockTTSProvider();\n  }\n}\n\n/**\n * Map voice configuration from agent settings to TTS provider format\n */\nexport function mapVoiceConfiguration(agent: LectureAgent): LectureAgent['voice'] {\n  // In production, this might map generic voice IDs to provider-specific IDs\n  // For now, we pass through the configuration\n  return {\n    voiceId: agent.voice.voiceId,\n    speed: agent.voice.speed,\n    pitch: agent.voice.pitch,\n  };\n}\n\n/**\n * Extract word-level timing data from TTS result\n * Assigns script block IDs to word timings based on text position\n */\nexport function extractWordTimings(\n  ttsResult: TTSResult,\n  script: LectureScript\n): WordTiming[] {\n  const wordTimings = ttsResult.wordTimings;\n  \n  // Build a map of word positions to script blocks\n  const scriptWords: Array<{ word: string; blockId: string }> = [];\n  \n  for (const segment of script.segments) {\n    for (const block of segment.scriptBlocks) {\n      const words = block.text.split(/\\s+/).filter(w => w.length > 0);\n      for (const word of words) {\n        scriptWords.push({\n          word: word.replace(/[.,!?;:]$/, ''), // Remove trailing punctuation\n          blockId: block.id,\n        });\n      }\n    }\n  }\n  \n  // Assign script block IDs to word timings\n  const result: WordTiming[] = [];\n  \n  for (let i = 0; i < wordTimings.length && i < scriptWords.length; i++) {\n    result.push({\n      ...wordTimings[i],\n      scriptBlockId: scriptWords[i].blockId,\n    });\n  }\n  \n  // If there are extra timings without matching script words, use the last block ID\n  if (wordTimings.length > scriptWords.length && scriptWords.length > 0) {\n    const lastBlockId = scriptWords[scriptWords.length - 1].blockId;\n    for (let i = scriptWords.length; i < wordTimings.length; i++) {\n      result.push({\n        ...wordTimings[i],\n        scriptBlockId: lastBlockId,\n      });\n    }\n  }\n  \n  return result;\n}\n\n/**\n * Validate timing monotonicity\n * Ensures that word timings are in increasing order\n */\nexport function validateTimingMonotonicity(wordTimings: WordTiming[]): boolean {\n  if (wordTimings.length === 0) {\n    return true;\n  }\n  \n  for (let i = 1; i < wordTimings.length; i++) {\n    const prev = wordTimings[i - 1];\n    const curr = wordTimings[i];\n    \n    // Current word's start time should be >= previous word's end time\n    if (curr.startTime < prev.endTime) {\n      logger.warn('Timing monotonicity violation detected', {\n        index: i,\n        prevWord: prev.word,\n        prevEnd: prev.endTime,\n        currWord: curr.word,\n        currStart: curr.startTime,\n      });\n      return false;\n    }\n    \n    // Word's end time should be >= start time\n    if (curr.endTime < curr.startTime) {\n      logger.warn('Invalid word timing detected', {\n        index: i,\n        word: curr.word,\n        startTime: curr.startTime,\n        endTime: curr.endTime,\n      });\n      return false;\n    }\n  }\n  \n  return true;\n}\n\n/**\n * Fix timing monotonicity issues\n * Adjusts timings to ensure they are monotonically increasing\n */\nexport function fixTimingMonotonicity(wordTimings: WordTiming[]): WordTiming[] {\n  if (wordTimings.length === 0) {\n    return wordTimings;\n  }\n  \n  const fixed: WordTiming[] = [wordTimings[0]];\n  \n  for (let i = 1; i < wordTimings.length; i++) {\n    const prev = fixed[i - 1];\n    const curr = { ...wordTimings[i] };\n    \n    // Ensure current start time is >= previous end time\n    if (curr.startTime < prev.endTime) {\n      curr.startTime = prev.endTime;\n    }\n    \n    // Ensure end time is >= start time\n    if (curr.endTime < curr.startTime) {\n      curr.endTime = curr.startTime + 0.1; // Add small duration\n    }\n    \n    fixed.push(curr);\n  }\n  \n  return fixed;\n}\n\n/**\n * Concatenate script blocks into full text for TTS\n */\nexport function concatenateScriptText(script: LectureScript): string {\n  const textParts: string[] = [];\n  \n  for (const segment of script.segments) {\n    for (const block of segment.scriptBlocks) {\n      textParts.push(block.text);\n    }\n  }\n  \n  // Join with spaces and normalize whitespace\n  return textParts.join(' ').replace(/\\s+/g, ' ').trim();\n}\n\n/**\n * Main audio synthesis function\n * Retrieves lecture script and agent, generates audio, and stores the result\n */\nexport async function synthesizeAudio(jobId: string): Promise<AudioOutput> {\n  try {\n    logger.info('Starting audio synthesis', { jobId });\n    \n    // Import dynamodb functions here to avoid circular dependencies\n    const { getContent, updateContent, getAgent, getJob, updateJob } = require('./dynamodb');\n    \n    // Retrieve lecture script from database\n    const contentRecord = await getContent(jobId);\n    if (!contentRecord || !contentRecord.script) {\n      throw new Error(`No lecture script found for job: ${jobId}`);\n    }\n    \n    const script = contentRecord.script as LectureScript;\n    \n    // Retrieve agent configuration\n    const job = await getJob(jobId);\n    if (!job) {\n      throw new Error(`Job not found: ${jobId}`);\n    }\n    \n    let agent = null;\n    if (job.agentId) {\n      agent = await getAgent(job.agentId);\n    }\n    \n    // If no agent found, use default\n    if (!agent) {\n      logger.warn('No agent specified, using default agent');\n      agent = {\n        id: 'default',\n        name: 'Default Lecturer',\n        description: 'A clear and straightforward science communicator',\n        personality: {\n          instructions: 'Explain concepts clearly and accessibly',\n          tone: 'casual' as const,\n        },\n        voice: {\n          voiceId: 'Joanna', // AWS Polly default voice\n          speed: 1.0,\n          pitch: 0,\n        },\n        createdAt: new Date(),\n      };\n    }\n    \n    // Concatenate script blocks into full text\n    const fullText = concatenateScriptText(script);\n    \n    if (fullText.length === 0) {\n      throw new Error('Script text is empty');\n    }\n    \n    logger.info('Script concatenated', {\n      jobId,\n      textLength: fullText.length,\n      wordCount: fullText.split(/\\s+/).length,\n    });\n    \n    // Get TTS provider\n    const ttsProvider = getTTSProvider();\n    \n    // Map voice configuration\n    const voiceConfig = mapVoiceConfiguration(agent);\n    \n    // Generate audio with agent's voice settings\n    const ttsResult = await ttsProvider.synthesize(fullText, voiceConfig);\n    \n    logger.info('TTS synthesis completed', {\n      jobId,\n      duration: ttsResult.duration,\n      wordCount: ttsResult.wordTimings.length,\n    });\n    \n    // Extract word-level timing data\n    let wordTimings = extractWordTimings(ttsResult, script);\n    \n    // Validate timing monotonicity\n    const isMonotonic = validateTimingMonotonicity(wordTimings);\n    if (!isMonotonic) {\n      logger.warn('Timing monotonicity validation failed, fixing timings', { jobId });\n      wordTimings = fixTimingMonotonicity(wordTimings);\n    }\n    \n    // Store MP3 file in S3\n    const audioUrl = await uploadAudio(jobId, ttsResult.audioBuffer);\n    \n    logger.info('Audio uploaded to S3', { jobId, audioUrl });\n    \n    // Create audio output\n    const audioOutput: AudioOutput = {\n      audioUrl,\n      duration: ttsResult.duration,\n      wordTimings,\n    };\n    \n    // Store audio metadata and timings in database\n    await updateContent(jobId, {\n      audioUrl,\n      wordTimings,\n    });\n    \n    // Update job status to completed\n    await updateJob(jobId, {\n      status: 'completed',\n    });\n    \n    logger.info('Audio synthesis completed', {\n      jobId,\n      audioUrl,\n      duration: ttsResult.duration,\n      wordTimingCount: wordTimings.length,\n    });\n    \n    return audioOutput;\n  } catch (error) {\n    logger.error('Audio synthesis failed', { jobId, error });\n    \n    // Update job status to failed\n    try {\n      const { updateJob } = require('./dynamodb');\n      await updateJob(jobId, {\n        status: 'failed',\n        error: error instanceof Error ? error.message : 'Audio synthesis failed',\n      });\n    } catch (updateError) {\n      logger.error('Failed to update job status', { jobId, error: updateError });\n    }\n    \n    throw error;\n  }\n}\n", "// Retry logic and circuit breaker utilities\n\nimport { logger } from './logger';\nimport { ExternalServiceError, ResourceError } from './errors';\n\nexport interface RetryOptions {\n  maxAttempts?: number;\n  initialDelayMs?: number;\n  maxDelayMs?: number;\n  backoffMultiplier?: number;\n  retryableErrors?: string[];\n}\n\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n  maxAttempts: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 10000,\n  backoffMultiplier: 2,\n  retryableErrors: ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'ECONNREFUSED'],\n};\n\n/**\n * Delays execution for the specified number of milliseconds\n */\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Determines if an error is retryable\n */\nfunction isRetryableError(error: any, retryableErrors: string[]): boolean {\n  if (!error) return false;\n  \n  // Check if error has retryable flag\n  if (typeof error.retryable === 'boolean') {\n    return error.retryable;\n  }\n  \n  // Check error name (for custom error classes)\n  if (error.name && retryableErrors.includes(error.name)) {\n    return true;\n  }\n  \n  // Check error code\n  if (error.code && retryableErrors.includes(error.code)) {\n    return true;\n  }\n  \n  // Check for common transient error messages\n  const message = error.message?.toLowerCase() || '';\n  return (\n    message.includes('timeout') ||\n    message.includes('connection') ||\n    message.includes('network') ||\n    message.includes('temporary') ||\n    message.includes('rate limit') ||\n    message.includes('429') ||\n    message.includes('too many requests')\n  );\n}\n\n/**\n * Executes a function with exponential backoff retry logic\n * @param fn Function to execute\n * @param options Retry configuration options\n * @returns Result of the function\n * @throws Last error if all retries fail\n */\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const opts = { ...DEFAULT_RETRY_OPTIONS, ...options };\n  let lastError: any;\n  let delayMs = opts.initialDelayMs;\n  \n  for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {\n    try {\n      const result = await fn();\n      \n      if (attempt > 1) {\n        logger.info('Operation succeeded after retry', { attempt });\n      }\n      \n      return result;\n    } catch (error) {\n      lastError = error;\n      \n      const isRetryable = isRetryableError(error, opts.retryableErrors);\n      const isLastAttempt = attempt === opts.maxAttempts;\n      \n      logger.warn('Operation failed', {\n        attempt,\n        maxAttempts: opts.maxAttempts,\n        isRetryable,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      \n      if (!isRetryable || isLastAttempt) {\n        throw error;\n      }\n      \n      // Wait before retrying\n      logger.info('Retrying operation', { attempt, delayMs });\n      await delay(delayMs);\n      \n      // Increase delay for next attempt (exponential backoff)\n      delayMs = Math.min(delayMs * opts.backoffMultiplier, opts.maxDelayMs);\n    }\n  }\n  \n  throw lastError;\n}\n\n// ============================================================================\n// Circuit Breaker\n// ============================================================================\n\nexport enum CircuitState {\n  CLOSED = 'CLOSED',     // Normal operation\n  OPEN = 'OPEN',         // Failing, reject requests\n  HALF_OPEN = 'HALF_OPEN', // Testing if service recovered\n}\n\nexport interface CircuitBreakerOptions {\n  failureThreshold?: number;\n  successThreshold?: number;\n  timeout?: number;\n  resetTimeoutMs?: number;\n}\n\nconst DEFAULT_CIRCUIT_OPTIONS: Required<CircuitBreakerOptions> = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeout: 30000,\n  resetTimeoutMs: 60000,\n};\n\n/**\n * Circuit breaker implementation for external service calls\n */\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failureCount = 0;\n  private successCount = 0;\n  private nextAttemptTime = 0;\n  private readonly options: Required<CircuitBreakerOptions>;\n  \n  constructor(\n    private readonly serviceName: string,\n    options: CircuitBreakerOptions = {}\n  ) {\n    this.options = { ...DEFAULT_CIRCUIT_OPTIONS, ...options };\n  }\n  \n  /**\n   * Executes a function with circuit breaker protection\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextAttemptTime) {\n        logger.warn('Circuit breaker is OPEN, rejecting request', {\n          service: this.serviceName,\n          nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n        });\n        throw new ExternalServiceError(\n          `Service ${this.serviceName} is currently unavailable (circuit breaker OPEN)`,\n          this.serviceName\n        );\n      }\n      \n      // Try to recover\n      this.state = CircuitState.HALF_OPEN;\n      this.successCount = 0;\n      logger.info('Circuit breaker entering HALF_OPEN state', {\n        service: this.serviceName,\n      });\n    }\n    \n    try {\n      // Execute with timeout\n      const result = await this.executeWithTimeout(fn);\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  /**\n   * Executes function with timeout\n   */\n  private async executeWithTimeout<T>(fn: () => Promise<T>): Promise<T> {\n    return Promise.race([\n      fn(),\n      new Promise<T>((_, reject) =>\n        setTimeout(\n          () => reject(new ResourceError('Operation timeout', { timeout: this.options.timeout })),\n          this.options.timeout\n        )\n      ),\n    ]);\n  }\n  \n  /**\n   * Handles successful execution\n   */\n  private onSuccess(): void {\n    this.failureCount = 0;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      this.successCount++;\n      \n      if (this.successCount >= this.options.successThreshold) {\n        this.state = CircuitState.CLOSED;\n        this.successCount = 0;\n        logger.info('Circuit breaker closed', { service: this.serviceName });\n      }\n    }\n  }\n  \n  /**\n   * Handles failed execution\n   */\n  private onFailure(): void {\n    this.failureCount++;\n    this.successCount = 0;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      this.state = CircuitState.OPEN;\n      this.nextAttemptTime = Date.now() + this.options.resetTimeoutMs;\n      logger.warn('Circuit breaker opened from HALF_OPEN', {\n        service: this.serviceName,\n        nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n      });\n    } else if (this.failureCount >= this.options.failureThreshold) {\n      this.state = CircuitState.OPEN;\n      this.nextAttemptTime = Date.now() + this.options.resetTimeoutMs;\n      logger.warn('Circuit breaker opened', {\n        service: this.serviceName,\n        failureCount: this.failureCount,\n        nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n      });\n    }\n  }\n  \n  /**\n   * Gets current circuit breaker state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n  \n  /**\n   * Resets circuit breaker to closed state\n   */\n  reset(): void {\n    this.state = CircuitState.CLOSED;\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.nextAttemptTime = 0;\n    logger.info('Circuit breaker manually reset', { service: this.serviceName });\n  }\n}\n\n// ============================================================================\n// Global Circuit Breakers\n// ============================================================================\n\nconst circuitBreakers = new Map<string, CircuitBreaker>();\n\n/**\n * Gets or creates a circuit breaker for a service\n */\nexport function getCircuitBreaker(\n  serviceName: string,\n  options?: CircuitBreakerOptions\n): CircuitBreaker {\n  if (!circuitBreakers.has(serviceName)) {\n    circuitBreakers.set(serviceName, new CircuitBreaker(serviceName, options));\n  }\n  return circuitBreakers.get(serviceName)!;\n}\n\n/**\n * Executes a function with both retry logic and circuit breaker protection\n */\nexport async function withRetryAndCircuitBreaker<T>(\n  serviceName: string,\n  fn: () => Promise<T>,\n  retryOptions?: RetryOptions,\n  circuitOptions?: CircuitBreakerOptions\n): Promise<T> {\n  const circuitBreaker = getCircuitBreaker(serviceName, circuitOptions);\n  \n  return withRetry(\n    () => circuitBreaker.execute(fn),\n    retryOptions\n  );\n}\n", "// Error handling utilities\n\nexport interface ErrorResponse {\n  error: string;\n  code: string;\n  jobId?: string;\n  details?: Record<string, any>;\n  retryable: boolean;\n}\n\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public statusCode: number = 500,\n    public retryable: boolean = false,\n    public details?: Record<string, any>\n  ) {\n    super(message);\n    this.name = 'AppError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  toResponse(jobId?: string): ErrorResponse {\n    return {\n      error: this.message,\n      code: this.code,\n      jobId,\n      details: this.details,\n      retryable: this.retryable,\n    };\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string, details?: Record<string, any>) {\n    super(message, 'VALIDATION_ERROR', 400, false, details);\n    this.name = 'ValidationError';\n  }\n}\n\nexport class ProcessingError extends AppError {\n  constructor(message: string, retryable: boolean = true, details?: Record<string, any>) {\n    super(message, 'PROCESSING_ERROR', 500, retryable, details);\n    this.name = 'ProcessingError';\n  }\n}\n\nexport class ExternalServiceError extends AppError {\n  constructor(message: string, service: string, details?: Record<string, any>) {\n    super(message, 'EXTERNAL_SERVICE_ERROR', 502, true, { service, ...details });\n    this.name = 'ExternalServiceError';\n  }\n}\n\nexport class ResourceError extends AppError {\n  constructor(message: string, details?: Record<string, any>) {\n    super(message, 'RESOURCE_ERROR', 503, true, details);\n    this.name = 'ResourceError';\n  }\n}\n\n// Validation helpers\nexport function validateRequired(value: any, fieldName: string): void {\n  if (value === undefined || value === null) {\n    throw new ValidationError(`${fieldName} is required`);\n  }\n}\n\nexport function validateString(value: any, fieldName: string, minLength?: number, maxLength?: number): void {\n  validateRequired(value, fieldName);\n  if (typeof value !== 'string') {\n    throw new ValidationError(`${fieldName} must be a string`);\n  }\n  if (minLength !== undefined && value.length < minLength) {\n    throw new ValidationError(`${fieldName} must be at least ${minLength} characters`);\n  }\n  if (maxLength !== undefined && value.length > maxLength) {\n    throw new ValidationError(`${fieldName} must be at most ${maxLength} characters`);\n  }\n}\n\nexport function validateNumber(value: any, fieldName: string, min?: number, max?: number): void {\n  validateRequired(value, fieldName);\n  if (typeof value !== 'number' || isNaN(value)) {\n    throw new ValidationError(`${fieldName} must be a number`);\n  }\n  if (min !== undefined && value < min) {\n    throw new ValidationError(`${fieldName} must be at least ${min}`);\n  }\n  if (max !== undefined && value > max) {\n    throw new ValidationError(`${fieldName} must be at most ${max}`);\n  }\n}\n\nexport function validateEnum<T extends string>(value: any, fieldName: string, allowedValues: T[]): void {\n  validateRequired(value, fieldName);\n  if (!allowedValues.includes(value)) {\n    throw new ValidationError(`${fieldName} must be one of: ${allowedValues.join(', ')}`);\n  }\n}\n\nexport function validateArray(value: any, fieldName: string, itemValidator?: (item: any, index: number) => void): void {\n  validateRequired(value, fieldName);\n  if (!Array.isArray(value)) {\n    throw new ValidationError(`${fieldName} must be an array`);\n  }\n  if (itemValidator) {\n    value.forEach((item, index) => {\n      try {\n        itemValidator(item, index);\n      } catch (error) {\n        if (error instanceof ValidationError) {\n          throw new ValidationError(`${fieldName}[${index}]: ${error.message}`);\n        }\n        throw error;\n      }\n    });\n  }\n}\n\nexport function validateFileSize(size: number, maxSize: number): void {\n  if (size > maxSize) {\n    throw new ValidationError(`File size exceeds maximum allowed size of ${maxSize} bytes`, {\n      actualSize: size,\n      maxSize,\n    });\n  }\n}\n\nexport function validatePDFFormat(buffer: Buffer): void {\n  // Check PDF magic bytes: %PDF-\n  if (buffer.length < 5) {\n    throw new ValidationError('File is too small to be a valid PDF');\n  }\n  \n  const header = buffer.slice(0, 5).toString('ascii');\n  if (header !== '%PDF-') {\n    throw new ValidationError('File is not a valid PDF (invalid magic bytes)', {\n      actualHeader: header,\n    });\n  }\n}\n", "// S3 client wrapper with local/production mode support\nimport AWS from 'aws-sdk';\nimport { Readable } from 'stream';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\nimport { ResourceError, ExternalServiceError } from '../utils/errors';\nimport { withRetry } from '../utils/retry';\n\n// Configure AWS SDK based on environment\nconst s3Config: AWS.S3.ClientConfiguration = {\n  region: config.aws.region,\n  s3ForcePathStyle: true, // Required for LocalStack\n  httpOptions: {\n    timeout: 30000, // 30 second timeout for operations\n    connectTimeout: 5000, // 5 second connection timeout\n  },\n  maxRetries: 0, // We handle retries ourselves\n};\n\nif (config.localstack.useLocalStack) {\n  s3Config.endpoint = config.localstack.endpoint;\n  s3Config.accessKeyId = 'test';\n  s3Config.secretAccessKey = 'test';\n} else if (config.aws.accessKeyId && config.aws.secretAccessKey) {\n  s3Config.accessKeyId = config.aws.accessKeyId;\n  s3Config.secretAccessKey = config.aws.secretAccessKey;\n}\n\nconst s3 = new AWS.S3(s3Config);\n\n// Helper function to handle S3 errors\nfunction handleS3Error(error: any, operation: string): never {\n  logger.error(`S3 ${operation} failed`, { error: error.message, code: error.code });\n  \n  // Check for timeout errors\n  if (error.code === 'RequestTimeout' || error.code === 'TimeoutError') {\n    throw new ResourceError(`Storage operation timed out: ${operation}`, { error: error.message });\n  }\n  \n  // Check for resource errors\n  if (error.code === 'NoSuchBucket' || error.code === 'NoSuchKey') {\n    throw new ResourceError(`Storage resource not found: ${operation}`, { error: error.message });\n  }\n  \n  // Other errors are external service errors\n  throw new ExternalServiceError(`Storage operation failed: ${operation}`, 's3', { error: error.message });\n}\n\n// ============================================================================\n// PDF Operations\n// ============================================================================\n\nexport async function uploadPDF(jobId: string, pdfBuffer: Buffer, filename: string): Promise<string> {\n  return withRetry(async () => {\n    try {\n      const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n      \n      await s3.putObject({\n        Bucket: config.s3.bucketName,\n        Key: key,\n        Body: pdfBuffer,\n        ContentType: 'application/pdf',\n        Metadata: {\n          originalFilename: filename,\n          jobId,\n        },\n      }).promise();\n      \n      logger.info('PDF uploaded', { jobId, key });\n      \n      // Return the S3 URL\n      if (config.localstack.useLocalStack) {\n        return `${config.localstack.endpoint}/${config.s3.bucketName}/${key}`;\n      }\n      return `https://${config.s3.bucketName}.s3.${config.aws.region}.amazonaws.com/${key}`;\n    } catch (error) {\n      handleS3Error(error, 'uploadPDF');\n    }\n  }, { maxAttempts: 3, initialDelayMs: 1000 });\n}\n\nexport async function downloadPDF(jobId: string): Promise<Buffer> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    const result = await s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('PDF downloaded', { jobId, key });\n    return result.Body as Buffer;\n  } catch (error) {\n    handleS3Error(error, 'downloadPDF');\n  }\n}\n\nexport async function streamPDF(jobId: string): Promise<Readable> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    const stream = s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).createReadStream();\n    \n    logger.info('PDF stream created', { jobId, key });\n    return stream;\n  } catch (error) {\n    handleS3Error(error, 'streamPDF');\n  }\n}\n\nexport async function deletePDF(jobId: string): Promise<void> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    await s3.deleteObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('PDF deleted', { jobId, key });\n  } catch (error) {\n    handleS3Error(error, 'deletePDF');\n  }\n}\n\nexport async function getPDFSignedUrl(jobId: string, expiresIn: number = 3600): Promise<string> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    const url = s3.getSignedUrl('getObject', {\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Expires: expiresIn,\n    });\n    \n    logger.info('PDF signed URL generated', { jobId, expiresIn });\n    return url;\n  } catch (error) {\n    handleS3Error(error, 'getPDFSignedUrl');\n  }\n}\n\n// ============================================================================\n// Audio Operations\n// ============================================================================\n\nexport async function uploadAudio(jobId: string, audioBuffer: Buffer): Promise<string> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    await s3.putObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Body: audioBuffer,\n      ContentType: 'audio/mpeg',\n      Metadata: {\n        jobId,\n      },\n    }).promise();\n    \n    logger.info('Audio uploaded', { jobId, key });\n    \n    // Return the S3 URL\n    if (config.localstack.useLocalStack) {\n      return `${config.localstack.endpoint}/${config.s3.bucketName}/${key}`;\n    }\n    return `https://${config.s3.bucketName}.s3.${config.aws.region}.amazonaws.com/${key}`;\n  } catch (error) {\n    handleS3Error(error, 'uploadAudio');\n  }\n}\n\nexport async function downloadAudio(jobId: string): Promise<Buffer> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    const result = await s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('Audio downloaded', { jobId, key });\n    return result.Body as Buffer;\n  } catch (error) {\n    handleS3Error(error, 'downloadAudio');\n  }\n}\n\nexport async function streamAudio(jobId: string): Promise<Readable> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    const stream = s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).createReadStream();\n    \n    logger.info('Audio stream created', { jobId, key });\n    return stream;\n  } catch (error) {\n    handleS3Error(error, 'streamAudio');\n  }\n}\n\nexport async function deleteAudio(jobId: string): Promise<void> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    await s3.deleteObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('Audio deleted', { jobId, key });\n  } catch (error) {\n    handleS3Error(error, 'deleteAudio');\n  }\n}\n\nexport async function getAudioSignedUrl(jobId: string, expiresIn: number = 3600): Promise<string> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    const url = s3.getSignedUrl('getObject', {\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Expires: expiresIn,\n    });\n    \n    logger.info('Audio signed URL generated', { jobId, expiresIn });\n    return url;\n  } catch (error) {\n    handleS3Error(error, 'getAudioSignedUrl');\n  }\n}\n\n// ============================================================================\n// Cache Operations (for figures, etc.)\n// ============================================================================\n\nexport async function uploadCacheFile(\n  jobId: string,\n  fileType: 'figure' | 'table',\n  fileId: string,\n  buffer: Buffer,\n  contentType: string\n): Promise<string> {\n  try {\n    const extension = contentType.includes('png') ? 'png' : 'jpg';\n    const key = `${config.s3.cachePrefix}/${jobId}/${fileType}s/${fileId}.${extension}`;\n    \n    await s3.putObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Body: buffer,\n      ContentType: contentType,\n      Metadata: {\n        jobId,\n        fileType,\n        fileId,\n      },\n    }).promise();\n    \n    logger.info('Cache file uploaded', { jobId, fileType, fileId, key });\n    \n    // Return the S3 URL\n    if (config.localstack.useLocalStack) {\n      return `${config.localstack.endpoint}/${config.s3.bucketName}/${key}`;\n    }\n    return `https://${config.s3.bucketName}.s3.${config.aws.region}.amazonaws.com/${key}`;\n  } catch (error) {\n    handleS3Error(error, 'uploadCacheFile');\n  }\n}\n\nexport async function downloadCacheFile(jobId: string, fileType: string, fileId: string): Promise<Buffer> {\n  try {\n    // Try both png and jpg extensions\n    const extensions = ['png', 'jpg'];\n    let lastError: any;\n    \n    for (const ext of extensions) {\n      try {\n        const key = `${config.s3.cachePrefix}/${jobId}/${fileType}s/${fileId}.${ext}`;\n        const result = await s3.getObject({\n          Bucket: config.s3.bucketName,\n          Key: key,\n        }).promise();\n        \n        logger.info('Cache file downloaded', { jobId, fileType, fileId, key });\n        return result.Body as Buffer;\n      } catch (error: any) {\n        lastError = error;\n        if (error.code !== 'NoSuchKey') {\n          throw error;\n        }\n      }\n    }\n    \n    throw lastError;\n  } catch (error) {\n    handleS3Error(error, 'downloadCacheFile');\n  }\n}\n\nexport async function deleteCacheFiles(jobId: string): Promise<void> {\n  try {\n    const prefix = `${config.s3.cachePrefix}/${jobId}/`;\n    \n    // List all objects with the prefix\n    const listResult = await s3.listObjectsV2({\n      Bucket: config.s3.bucketName,\n      Prefix: prefix,\n    }).promise();\n    \n    if (!listResult.Contents || listResult.Contents.length === 0) {\n      logger.info('No cache files to delete', { jobId });\n      return;\n    }\n    \n    // Delete all objects\n    await s3.deleteObjects({\n      Bucket: config.s3.bucketName,\n      Delete: {\n        Objects: listResult.Contents.map(obj => ({ Key: obj.Key! })),\n      },\n    }).promise();\n    \n    logger.info('Cache files deleted', { jobId, count: listResult.Contents.length });\n  } catch (error) {\n    handleS3Error(error, 'deleteCacheFiles');\n  }\n}\n\n// ============================================================================\n// Bucket Management (for local development)\n// ============================================================================\n\nexport async function createBucketIfNotExists(): Promise<void> {\n  if (!config.localstack.useLocalStack) {\n    logger.info('Skipping bucket creation in production mode');\n    return;\n  }\n  \n  try {\n    await s3.headBucket({ Bucket: config.s3.bucketName }).promise();\n    logger.info(`Bucket ${config.s3.bucketName} already exists`);\n  } catch (error: any) {\n    if (error.code === 'NotFound' || error.code === 'NoSuchBucket') {\n      try {\n        await s3.createBucket({ Bucket: config.s3.bucketName }).promise();\n        logger.info(`Bucket ${config.s3.bucketName} created`);\n      } catch (createError) {\n        logger.error(`Failed to create bucket ${config.s3.bucketName}`, { error: createError });\n      }\n    } else {\n      logger.error('Error checking bucket existence', { error });\n    }\n  }\n}\n\n// ============================================================================\n// Cleanup Operations\n// ============================================================================\n\nexport async function deleteAllJobFiles(jobId: string): Promise<void> {\n  try {\n    await Promise.all([\n      deletePDF(jobId).catch(err => logger.warn('Failed to delete PDF', { jobId, error: err.message })),\n      deleteAudio(jobId).catch(err => logger.warn('Failed to delete audio', { jobId, error: err.message })),\n      deleteCacheFiles(jobId).catch(err => logger.warn('Failed to delete cache files', { jobId, error: err.message })),\n    ]);\n    \n    logger.info('All job files deleted', { jobId });\n  } catch (error) {\n    logger.error('Error during job file cleanup', { jobId, error });\n  }\n}\n", "// EventBridge service for asynchronous function triggering\nimport { EventBridge } from 'aws-sdk';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\n\nconst eventBridge = new EventBridge({\n  endpoint: config.isLocal ? 'http://localhost:4566' : undefined,\n  region: config.awsRegion,\n});\n\nexport interface PipelineEvent {\n  jobId: string;\n  agentId?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Publish an event to EventBridge to trigger the next stage in the pipeline\n */\nexport async function publishPipelineEvent(\n  detailType: string,\n  detail: PipelineEvent\n): Promise<void> {\n  const eventBusName = config.eventBusName || 'pdf-lecture-service-events';\n  \n  try {\n    logger.info('Publishing pipeline event', { detailType, jobId: detail.jobId });\n    \n    const params: EventBridge.PutEventsRequest = {\n      Entries: [\n        {\n          Source: 'pdf-lecture-service',\n          DetailType: detailType,\n          Detail: JSON.stringify(detail),\n          EventBusName: eventBusName,\n        },\n      ],\n    };\n    \n    const result = await eventBridge.putEvents(params).promise();\n    \n    if (result.FailedEntryCount && result.FailedEntryCount > 0) {\n      const errors = result.Entries?.filter(e => e.ErrorCode).map(e => ({\n        code: e.ErrorCode,\n        message: e.ErrorMessage,\n      }));\n      throw new Error(`Failed to publish event: ${JSON.stringify(errors)}`);\n    }\n    \n    logger.info('Pipeline event published successfully', { detailType, jobId: detail.jobId });\n  } catch (error) {\n    logger.error('Failed to publish pipeline event', { error, detailType, jobId: detail.jobId });\n    throw error;\n  }\n}\n\n/**\n * Trigger the content analysis stage\n */\nexport async function triggerAnalysis(jobId: string): Promise<void> {\n  await publishPipelineEvent('JobCreated', { jobId });\n}\n\n/**\n * Trigger the content segmentation stage\n */\nexport async function triggerSegmentation(jobId: string): Promise<void> {\n  await publishPipelineEvent('AnalysisCompleted', { jobId });\n}\n\n/**\n * Trigger the script generation stage\n */\nexport async function triggerScriptGeneration(jobId: string, agentId?: string): Promise<void> {\n  await publishPipelineEvent('SegmentationCompleted', { jobId, agentId });\n}\n\n/**\n * Trigger the audio synthesis stage\n */\nexport async function triggerAudioSynthesis(jobId: string): Promise<void> {\n  await publishPipelineEvent('ScriptGenerationCompleted', { jobId });\n}\n\n/**\n * Publish a job completion event\n */\nexport async function publishJobCompleted(jobId: string): Promise<void> {\n  await publishPipelineEvent('JobCompleted', { jobId });\n}\n\n/**\n * Publish a job failure event\n */\nexport async function publishJobFailed(jobId: string, error: string): Promise<void> {\n  await publishPipelineEvent('JobFailed', { \n    jobId, \n    metadata: { error } \n  });\n}\n"],
  "mappings": "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",
  "names": ["SENSITIVE_PATTERNS", "Logger", "logger", "init_logger", "__esmMin", "_Logger", "envLogLevel", "id", "name", "data", "item", "redacted", "key", "value", "pattern", "level", "levels", "currentLevelIndex", "minLevelIndex", "message", "metadata", "entry", "correlationId", "childLogger", "require_package", "__commonJSMin", "exports", "module", "require_main", "__commonJSMin", "exports", "module", "fs", "path", "os", "crypto", "packageJson", "version", "LINE", "parse", "src", "obj", "lines", "match", "key", "value", "maybeQuote", "_parseVault", "options", "vaultPath", "_vaultPath", "result", "DotenvModule", "err", "keys", "_dotenvKey", "length", "decrypted", "attrs", "_instructions", "error", "_warn", "message", "_debug", "_log", "dotenvKey", "uri", "environment", "environmentKey", "ciphertext", "possibleVaultPath", "filepath", "_resolveHome", "envPath", "_configVault", "debug", "quiet", "parsed", "processEnv", "configDotenv", "dotenvPath", "encoding", "optionPaths", "lastError", "parsedAll", "e", "keysCount", "shortPaths", "filePath", "relative", "config", "decrypt", "encrypted", "keyStr", "nonce", "authTag", "aesgcm", "isRange", "invalidKeyLength", "decryptionFailed", "populate", "override", "config_exports", "__export", "config", "import_dotenv", "init_config", "__esmMin", "dotenv", "dynamodb_exports", "__export", "createAgent", "createContent", "createJob", "createTablesIfNotExist", "deleteAgent", "deleteContent", "deleteJob", "getAgent", "getContent", "getJob", "listAgents", "listJobs", "updateAgent", "updateContent", "updateJob", "handleDynamoDBError", "error", "operation", "logger", "jobToRecord", "job", "recordToJob", "record", "stage", "dynamoDB", "config", "jobId", "result", "updates", "current", "updated", "item", "agentToRecord", "agent", "recordToAgent", "a", "id", "dynamoDBClient", "AWS", "dynamoDBConfig", "tables", "tableConfig", "createError", "import_aws_sdk", "init_dynamodb", "__esmMin", "init_config", "init_logger", "audio_exports", "__export", "audioHandler", "__toCommonJS", "init_logger", "init_logger", "AppError", "message", "code", "statusCode", "retryable", "details", "jobId", "ExternalServiceError", "AppError", "message", "service", "details", "ResourceError", "DEFAULT_RETRY_OPTIONS", "delay", "ms", "resolve", "isRetryableError", "error", "retryableErrors", "message", "withRetry", "fn", "options", "opts", "lastError", "delayMs", "attempt", "result", "logger", "isRetryable", "isLastAttempt", "DEFAULT_CIRCUIT_OPTIONS", "CircuitBreaker", "serviceName", "options", "fn", "logger", "ExternalServiceError", "result", "error", "_", "reject", "ResourceError", "circuitBreakers", "getCircuitBreaker", "withRetryAndCircuitBreaker", "retryOptions", "circuitOptions", "circuitBreaker", "withRetry", "import_aws_sdk", "init_config", "init_logger", "s3Config", "config", "s3", "AWS", "handleS3Error", "error", "operation", "logger", "ResourceError", "ExternalServiceError", "uploadAudio", "jobId", "audioBuffer", "key", "config", "s3", "logger", "error", "handleS3Error", "MockTTSProvider", "text", "voiceConfig", "logger", "resolve", "audioBuffer", "words", "w", "wordTimings", "secondsPerWord", "currentTime", "word", "wordDuration", "PollyTTSProvider", "AWS", "config", "pollyConfig", "withRetryAndCircuitBreaker", "params", "duration", "timingParams", "lines", "line", "mark", "timingError", "error", "ExternalServiceError", "speed", "getTTSProvider", "mapVoiceConfiguration", "agent", "extractWordTimings", "ttsResult", "script", "scriptWords", "segment", "block", "result", "i", "lastBlockId", "validateTimingMonotonicity", "prev", "curr", "fixTimingMonotonicity", "fixed", "concatenateScriptText", "textParts", "synthesizeAudio", "jobId", "getContent", "updateContent", "getAgent", "getJob", "updateJob", "contentRecord", "job", "fullText", "ttsProvider", "audioUrl", "uploadAudio", "audioOutput", "updateError", "init_dynamodb", "import_aws_sdk", "init_config", "init_logger", "eventBridge", "config", "publishPipelineEvent", "detailType", "detail", "eventBusName", "logger", "params", "result", "errors", "e", "error", "publishJobCompleted", "jobId", "publishPipelineEvent", "init_logger", "init_config", "audioHandler", "event", "logger", "jobId", "job", "getJob", "updateJob", "stage", "audioOutput", "synthesizeAudio", "config", "publishJobCompleted", "error", "errorResponse", "updateError"]
}
