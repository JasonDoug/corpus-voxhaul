{
  "version": 3,
  "sources": ["../../../../../../../tmp/tmpgptteqsp/src/utils/logger.ts", "../../../../../../../tmp/tmpgptteqsp/node_modules/dotenv/package.json", "../../../../../../../tmp/tmpgptteqsp/node_modules/dotenv/lib/main.js", "../../../../../../../tmp/tmpgptteqsp/src/utils/config.ts", "../../../../../../../tmp/tmpgptteqsp/src/utils/cloudwatch.ts", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/max.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/nil.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/regex.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/validate.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/parse.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/stringify.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/rng.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v1.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v1ToV6.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/md5.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v35.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v3.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/native.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v4.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/sha1.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v5.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v6.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v6ToV1.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/v7.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/version.js", "../../../../../../../tmp/tmpgptteqsp/node_modules/uuid/dist-node/index.js", "../../../../../../../tmp/tmpgptteqsp/src/services/dynamodb.ts", "../../../../../../../tmp/tmpgptteqsp/src/functions/segmenter.ts", "../../../../../../../tmp/tmpgptteqsp/src/services/segmenter.ts", "../../../../../../../tmp/tmpgptteqsp/src/services/llm.ts", "../../../../../../../tmp/tmpgptteqsp/src/utils/retry.ts", "../../../../../../../tmp/tmpgptteqsp/src/utils/llm-metrics.ts", "../../../../../../../tmp/tmpgptteqsp/src/utils/metrics.ts", "../../../../../../../tmp/tmpgptteqsp/src/services/eventbridge.ts"],
  "sourcesContent": ["// Logging utility with structured JSON logging, correlation IDs, and sensitive data redaction\n\nexport enum LogLevel {\n  ERROR = 'ERROR',\n  WARN = 'WARN',\n  INFO = 'INFO',\n  DEBUG = 'DEBUG',\n}\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  correlationId?: string;\n  metadata?: Record<string, any>;\n  service?: string;\n  function?: string;\n}\n\n// Sensitive field patterns to redact\nconst SENSITIVE_PATTERNS = [\n  /password/i,\n  /secret/i,\n  /token/i,\n  /apikey/i,\n  /api[_-]?key/i,\n  /authorization/i,\n  /auth/i,\n  /credential/i,\n  /private[_-]?key/i,\n  /access[_-]?key/i,\n];\n\nclass Logger {\n  private correlationId?: string;\n  private serviceName?: string;\n  private functionName?: string;\n  private minLogLevel: LogLevel;\n\n  constructor() {\n    // Set minimum log level from environment or default to INFO\n    const envLogLevel = process.env.LOG_LEVEL?.toUpperCase() as LogLevel;\n    this.minLogLevel = envLogLevel || LogLevel.INFO;\n  }\n\n  setCorrelationId(id: string) {\n    this.correlationId = id;\n  }\n\n  getCorrelationId(): string | undefined {\n    return this.correlationId;\n  }\n\n  setServiceName(name: string) {\n    this.serviceName = name;\n  }\n\n  setFunctionName(name: string) {\n    this.functionName = name;\n  }\n\n  /**\n   * Redact sensitive data from metadata\n   */\n  private redactSensitiveData(data: any): any {\n    if (data === null || data === undefined) {\n      return data;\n    }\n\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(item => this.redactSensitiveData(item));\n    }\n\n    if (typeof data === 'object') {\n      const redacted: Record<string, any> = {};\n      for (const [key, value] of Object.entries(data)) {\n        // Check if key matches sensitive patterns\n        const isSensitive = SENSITIVE_PATTERNS.some(pattern => pattern.test(key));\n        \n        if (isSensitive) {\n          redacted[key] = '[REDACTED]';\n        } else if (typeof value === 'object' && value !== null) {\n          redacted[key] = this.redactSensitiveData(value);\n        } else {\n          redacted[key] = value;\n        }\n      }\n      return redacted;\n    }\n\n    return data;\n  }\n\n  /**\n   * Check if log level should be logged based on minimum level\n   */\n  private shouldLog(level: LogLevel): boolean {\n    const levels = [LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG];\n    const currentLevelIndex = levels.indexOf(level);\n    const minLevelIndex = levels.indexOf(this.minLogLevel);\n    return currentLevelIndex <= minLevelIndex;\n  }\n\n  private log(level: LogLevel, message: string, metadata?: Record<string, any>) {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      correlationId: this.correlationId,\n      service: this.serviceName,\n      function: this.functionName,\n      metadata: metadata ? this.redactSensitiveData(metadata) : undefined,\n    };\n    \n    // Output as JSON for structured logging\n    console.log(JSON.stringify(entry));\n  }\n\n  error(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.ERROR, message, metadata);\n  }\n\n  warn(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.WARN, message, metadata);\n  }\n\n  info(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.INFO, message, metadata);\n  }\n\n  debug(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.DEBUG, message, metadata);\n  }\n\n  /**\n   * Create a child logger with a specific correlation ID\n   */\n  child(correlationId: string): Logger {\n    const childLogger = new Logger();\n    childLogger.setCorrelationId(correlationId);\n    childLogger.setServiceName(this.serviceName || '');\n    childLogger.setFunctionName(this.functionName || '');\n    return childLogger;\n  }\n}\n\nexport const logger = new Logger();\n", "{\n  \"name\": \"dotenv\",\n  \"version\": \"16.6.1\",\n  \"description\": \"Loads environment variables from .env file\",\n  \"main\": \"lib/main.js\",\n  \"types\": \"lib/main.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./lib/main.d.ts\",\n      \"require\": \"./lib/main.js\",\n      \"default\": \"./lib/main.js\"\n    },\n    \"./config\": \"./config.js\",\n    \"./config.js\": \"./config.js\",\n    \"./lib/env-options\": \"./lib/env-options.js\",\n    \"./lib/env-options.js\": \"./lib/env-options.js\",\n    \"./lib/cli-options\": \"./lib/cli-options.js\",\n    \"./lib/cli-options.js\": \"./lib/cli-options.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"dts-check\": \"tsc --project tests/types/tsconfig.json\",\n    \"lint\": \"standard\",\n    \"pretest\": \"npm run lint && npm run dts-check\",\n    \"test\": \"tap run --allow-empty-coverage --disable-coverage --timeout=60000\",\n    \"test:coverage\": \"tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\n    \"prerelease\": \"npm test\",\n    \"release\": \"standard-version\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/motdotla/dotenv.git\"\n  },\n  \"homepage\": \"https://github.com/motdotla/dotenv#readme\",\n  \"funding\": \"https://dotenvx.com\",\n  \"keywords\": [\n    \"dotenv\",\n    \"env\",\n    \".env\",\n    \"environment\",\n    \"variables\",\n    \"config\",\n    \"settings\"\n  ],\n  \"readmeFilename\": \"README.md\",\n  \"license\": \"BSD-2-Clause\",\n  \"devDependencies\": {\n    \"@types/node\": \"^18.11.3\",\n    \"decache\": \"^4.6.2\",\n    \"sinon\": \"^14.0.1\",\n    \"standard\": \"^17.0.0\",\n    \"standard-version\": \"^9.5.0\",\n    \"tap\": \"^19.2.0\",\n    \"typescript\": \"^4.8.4\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"browser\": {\n    \"fs\": false\n  }\n}\n", "const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.log(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsedAll, options)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(parsedAll).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n    }\n  }\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n", "// Configuration utilities\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const config = {\n  nodeEnv: process.env.NODE_ENV || 'development',\n  port: parseInt(process.env.PORT || '3000', 10),\n  localMode: process.env.LOCAL_MODE === 'true',\n  isLocal: process.env.NODE_ENV !== 'production',\n  awsRegion: process.env.AWS_REGION || 'us-east-1',\n  eventBusName: process.env.EVENT_BUS_NAME || 'pdf-lecture-service-events',\n  \n  aws: {\n    region: process.env.AWS_REGION || 'us-east-1',\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  },\n  \n  localstack: {\n    endpoint: process.env.LOCALSTACK_ENDPOINT || 'http://localhost:4566',\n    useLocalStack: process.env.USE_LOCALSTACK === 'true',\n  },\n  \n  s3: {\n    bucketName: process.env.S3_BUCKET_NAME || 'pdf-lecture-service',\n    pdfPrefix: process.env.S3_PDF_PREFIX || 'pdfs',\n    audioPrefix: process.env.S3_AUDIO_PREFIX || 'audio',\n    cachePrefix: process.env.S3_CACHE_PREFIX || 'cache',\n  },\n  \n  dynamodb: {\n    jobsTable: process.env.DYNAMODB_JOBS_TABLE || 'pdf-lecture-jobs',\n    agentsTable: process.env.DYNAMODB_AGENTS_TABLE || 'pdf-lecture-agents',\n    contentTable: process.env.DYNAMODB_CONTENT_TABLE || 'pdf-lecture-content',\n  },\n  \n  processing: {\n    maxPdfSizeMB: parseInt(process.env.MAX_PDF_SIZE_MB || '100', 10),\n    analysisTimeoutMs: parseInt(process.env.ANALYSIS_TIMEOUT_MS || '300000', 10),\n    audioSynthesisTimeoutMs: parseInt(process.env.AUDIO_SYNTHESIS_TIMEOUT_MS || '600000', 10),\n  },\n  \n  featureFlags: {\n    enableRealSegmentation: process.env.ENABLE_REAL_SEGMENTATION === 'true',\n    enableRealScriptGeneration: process.env.ENABLE_REAL_SCRIPT_GENERATION === 'true',\n    enableImageExtraction: process.env.ENABLE_IMAGE_EXTRACTION === 'true',\n    enableVisionFirstPipeline: process.env.ENABLE_VISION_FIRST_PIPELINE === 'true',\n  },\n  \n  vision: {\n    model: process.env.VISION_MODEL || 'google/gemini-2.0-flash-exp:free',\n    temperature: parseFloat(process.env.VISION_LLM_TEMPERATURE || '0.3'),\n    maxTokens: parseInt(process.env.VISION_LLM_MAX_TOKENS || '4000', 10),\n  },\n};\n", "// CloudWatch integration for metrics and logs\nimport * as AWS from 'aws-sdk';\nimport { config } from './config';\nimport { logger } from './logger';\n\n// Initialize CloudWatch client\nconst cloudwatch = new AWS.CloudWatch({\n  region: config.aws.region,\n  ...(config.localstack.useLocalStack && {\n    endpoint: config.localstack.endpoint,\n  }),\n});\n\nexport interface CloudWatchMetric {\n  name: string;\n  value: number;\n  unit: string;\n  dimensions?: Record<string, string>;\n  timestamp?: Date;\n}\n\n/**\n * Publish a single metric to CloudWatch\n */\nexport async function publishMetric(metric: CloudWatchMetric): Promise<void> {\n  // Skip CloudWatch publishing in local mode\n  if (config.isLocal && !config.localstack.useLocalStack) {\n    logger.debug('Skipping CloudWatch metric in local mode', { metric });\n    return;\n  }\n\n  try {\n    const dimensions = metric.dimensions\n      ? Object.entries(metric.dimensions).map(([name, value]) => ({\n          Name: name,\n          Value: value,\n        }))\n      : [];\n\n    await cloudwatch\n      .putMetricData({\n        Namespace: 'PDFLectureService',\n        MetricData: [\n          {\n            MetricName: metric.name,\n            Value: metric.value,\n            Unit: metric.unit as any,\n            Timestamp: metric.timestamp || new Date(),\n            Dimensions: dimensions,\n          },\n        ],\n      })\n      .promise();\n\n    logger.debug('Metric published to CloudWatch', { metric });\n  } catch (error) {\n    logger.error('Failed to publish metric to CloudWatch', {\n      metric,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Publish multiple metrics to CloudWatch in a batch\n */\nexport async function publishMetrics(metrics: CloudWatchMetric[]): Promise<void> {\n  // Skip CloudWatch publishing in local mode\n  if (config.isLocal && !config.localstack.useLocalStack) {\n    logger.debug('Skipping CloudWatch metrics in local mode', { count: metrics.length });\n    return;\n  }\n\n  try {\n    const metricData = metrics.map((metric) => {\n      const dimensions = metric.dimensions\n        ? Object.entries(metric.dimensions).map(([name, value]) => ({\n            Name: name,\n            Value: value,\n          }))\n        : [];\n\n      return {\n        MetricName: metric.name,\n        Value: metric.value,\n        Unit: metric.unit as any,\n        Timestamp: metric.timestamp || new Date(),\n        Dimensions: dimensions,\n      };\n    });\n\n    // CloudWatch allows max 20 metrics per request\n    const batchSize = 20;\n    for (let i = 0; i < metricData.length; i += batchSize) {\n      const batch = metricData.slice(i, i + batchSize);\n      await cloudwatch\n        .putMetricData({\n          Namespace: 'PDFLectureService',\n          MetricData: batch,\n        })\n        .promise();\n    }\n\n    logger.debug('Metrics published to CloudWatch', { count: metrics.length });\n  } catch (error) {\n    logger.error('Failed to publish metrics to CloudWatch', {\n      count: metrics.length,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Create a CloudWatch alarm programmatically\n */\nexport async function createAlarm(params: {\n  alarmName: string;\n  metricName: string;\n  threshold: number;\n  comparisonOperator: string;\n  evaluationPeriods: number;\n  period: number;\n  statistic: string;\n  dimensions?: Record<string, string>;\n}): Promise<void> {\n  try {\n    const dimensions = params.dimensions\n      ? Object.entries(params.dimensions).map(([name, value]) => ({\n          Name: name,\n          Value: value,\n        }))\n      : [];\n\n    await cloudwatch\n      .putMetricAlarm({\n        AlarmName: params.alarmName,\n        MetricName: params.metricName,\n        Namespace: 'PDFLectureService',\n        Statistic: params.statistic,\n        Period: params.period,\n        EvaluationPeriods: params.evaluationPeriods,\n        Threshold: params.threshold,\n        ComparisonOperator: params.comparisonOperator,\n        Dimensions: dimensions,\n        TreatMissingData: 'notBreaching',\n      })\n      .promise();\n\n    logger.info('CloudWatch alarm created', { alarmName: params.alarmName });\n  } catch (error) {\n    logger.error('Failed to create CloudWatch alarm', {\n      alarmName: params.alarmName,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Helper to create standard alarms for a Lambda function\n */\nexport async function createStandardAlarmsForFunction(\n  functionName: string,\n  timeoutMs: number\n): Promise<void> {\n  // Error rate alarm\n  await createAlarm({\n    alarmName: `${functionName}-ErrorRate`,\n    metricName: 'Errors',\n    threshold: 5,\n    comparisonOperator: 'GreaterThanThreshold',\n    evaluationPeriods: 1,\n    period: 300,\n    statistic: 'Sum',\n    dimensions: { FunctionName: functionName },\n  });\n\n  // Timeout alarm (90% of actual timeout)\n  await createAlarm({\n    alarmName: `${functionName}-Timeout`,\n    metricName: 'Duration',\n    threshold: timeoutMs * 0.9,\n    comparisonOperator: 'GreaterThanThreshold',\n    evaluationPeriods: 1,\n    period: 300,\n    statistic: 'Maximum',\n    dimensions: { FunctionName: functionName },\n  });\n\n  // Throttle alarm\n  await createAlarm({\n    alarmName: `${functionName}-Throttles`,\n    metricName: 'Throttles',\n    threshold: 1,\n    comparisonOperator: 'GreaterThanThreshold',\n    evaluationPeriods: 1,\n    period: 300,\n    statistic: 'Sum',\n    dimensions: { FunctionName: functionName },\n  });\n}\n", "export default 'ffffffff-ffff-ffff-ffff-ffffffffffff';\n", "export default '00000000-0000-0000-0000-000000000000';\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;\n", "import REGEX from './regex.js';\nfunction validate(uuid) {\n    return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;\n", "import validate from './validate.js';\nfunction parse(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    let v;\n    return Uint8Array.of((v = parseInt(uuid.slice(0, 8), 16)) >>> 24, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff, (v = parseInt(uuid.slice(9, 13), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(14, 18), 16)) >>> 8, v & 0xff, (v = parseInt(uuid.slice(19, 23), 16)) >>> 8, v & 0xff, ((v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000) & 0xff, (v / 0x100000000) & 0xff, (v >>> 24) & 0xff, (v >>> 16) & 0xff, (v >>> 8) & 0xff, v & 0xff);\n}\nexport default parse;\n", "import validate from './validate.js';\nconst byteToHex = [];\nfor (let i = 0; i < 256; ++i) {\n    byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n    return (byteToHex[arr[offset + 0]] +\n        byteToHex[arr[offset + 1]] +\n        byteToHex[arr[offset + 2]] +\n        byteToHex[arr[offset + 3]] +\n        '-' +\n        byteToHex[arr[offset + 4]] +\n        byteToHex[arr[offset + 5]] +\n        '-' +\n        byteToHex[arr[offset + 6]] +\n        byteToHex[arr[offset + 7]] +\n        '-' +\n        byteToHex[arr[offset + 8]] +\n        byteToHex[arr[offset + 9]] +\n        '-' +\n        byteToHex[arr[offset + 10]] +\n        byteToHex[arr[offset + 11]] +\n        byteToHex[arr[offset + 12]] +\n        byteToHex[arr[offset + 13]] +\n        byteToHex[arr[offset + 14]] +\n        byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n    const uuid = unsafeStringify(arr, offset);\n    if (!validate(uuid)) {\n        throw TypeError('Stringified UUID is invalid');\n    }\n    return uuid;\n}\nexport default stringify;\n", "import { randomFillSync } from 'node:crypto';\nconst rnds8Pool = new Uint8Array(256);\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n    if (poolPtr > rnds8Pool.length - 16) {\n        randomFillSync(rnds8Pool);\n        poolPtr = 0;\n    }\n    return rnds8Pool.slice(poolPtr, (poolPtr += 16));\n}\n", "import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nconst _state = {};\nfunction v1(options, buf, offset) {\n    let bytes;\n    const isV6 = options?._v6 ?? false;\n    if (options) {\n        const optionsKeys = Object.keys(options);\n        if (optionsKeys.length === 1 && optionsKeys[0] === '_v6') {\n            options = undefined;\n        }\n    }\n    if (options) {\n        bytes = v1Bytes(options.random ?? options.rng?.() ?? rng(), options.msecs, options.nsecs, options.clockseq, options.node, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = rng();\n        updateV1State(_state, now, rnds);\n        bytes = v1Bytes(rnds, _state.msecs, _state.nsecs, isV6 ? undefined : _state.clockseq, isV6 ? undefined : _state.node, buf, offset);\n    }\n    return buf ?? unsafeStringify(bytes);\n}\nexport function updateV1State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.nsecs ??= 0;\n    if (now === state.msecs) {\n        state.nsecs++;\n        if (state.nsecs >= 10000) {\n            state.node = undefined;\n            state.nsecs = 0;\n        }\n    }\n    else if (now > state.msecs) {\n        state.nsecs = 0;\n    }\n    else if (now < state.msecs) {\n        state.node = undefined;\n    }\n    if (!state.node) {\n        state.node = rnds.slice(10, 16);\n        state.node[0] |= 0x01;\n        state.clockseq = ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    }\n    state.msecs = now;\n    return state;\n}\nfunction v1Bytes(rnds, msecs, nsecs, clockseq, node, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    nsecs ??= 0;\n    clockseq ??= ((rnds[8] << 8) | rnds[9]) & 0x3fff;\n    node ??= rnds.slice(10, 16);\n    msecs += 12219292800000;\n    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n    buf[offset++] = (tl >>> 24) & 0xff;\n    buf[offset++] = (tl >>> 16) & 0xff;\n    buf[offset++] = (tl >>> 8) & 0xff;\n    buf[offset++] = tl & 0xff;\n    const tmh = ((msecs / 0x100000000) * 10000) & 0xfffffff;\n    buf[offset++] = (tmh >>> 8) & 0xff;\n    buf[offset++] = tmh & 0xff;\n    buf[offset++] = ((tmh >>> 24) & 0xf) | 0x10;\n    buf[offset++] = (tmh >>> 16) & 0xff;\n    buf[offset++] = (clockseq >>> 8) | 0x80;\n    buf[offset++] = clockseq & 0xff;\n    for (let n = 0; n < 6; ++n) {\n        buf[offset++] = node[n];\n    }\n    return buf;\n}\nexport default v1;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport default function v1ToV6(uuid) {\n    const v1Bytes = typeof uuid === 'string' ? parse(uuid) : uuid;\n    const v6Bytes = _v1ToV6(v1Bytes);\n    return typeof uuid === 'string' ? unsafeStringify(v6Bytes) : v6Bytes;\n}\nfunction _v1ToV6(v1Bytes) {\n    return Uint8Array.of(((v1Bytes[6] & 0x0f) << 4) | ((v1Bytes[7] >> 4) & 0x0f), ((v1Bytes[7] & 0x0f) << 4) | ((v1Bytes[4] & 0xf0) >> 4), ((v1Bytes[4] & 0x0f) << 4) | ((v1Bytes[5] & 0xf0) >> 4), ((v1Bytes[5] & 0x0f) << 4) | ((v1Bytes[0] & 0xf0) >> 4), ((v1Bytes[0] & 0x0f) << 4) | ((v1Bytes[1] & 0xf0) >> 4), ((v1Bytes[1] & 0x0f) << 4) | ((v1Bytes[2] & 0xf0) >> 4), 0x60 | (v1Bytes[2] & 0x0f), v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);\n}\n", "import { createHash } from 'node:crypto';\nfunction md5(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return createHash('md5').update(bytes).digest();\n}\nexport default md5;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    const bytes = new Uint8Array(str.length);\n    for (let i = 0; i < str.length; ++i) {\n        bytes[i] = str.charCodeAt(i);\n    }\n    return bytes;\n}\nexport const DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport const URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(version, hash, value, namespace, buf, offset) {\n    const valueBytes = typeof value === 'string' ? stringToBytes(value) : value;\n    const namespaceBytes = typeof namespace === 'string' ? parse(namespace) : namespace;\n    if (typeof namespace === 'string') {\n        namespace = parse(namespace);\n    }\n    if (namespace?.length !== 16) {\n        throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n    let bytes = new Uint8Array(16 + valueBytes.length);\n    bytes.set(namespaceBytes);\n    bytes.set(valueBytes, namespaceBytes.length);\n    bytes = hash(bytes);\n    bytes[6] = (bytes[6] & 0x0f) | version;\n    bytes[8] = (bytes[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\n", "import md5 from './md5.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v3(value, namespace, buf, offset) {\n    return v35(0x30, md5, value, namespace, buf, offset);\n}\nv3.DNS = DNS;\nv3.URL = URL;\nexport default v3;\n", "import { randomUUID } from 'node:crypto';\nexport default { randomUUID };\n", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction _v4(options, buf, offset) {\n    options = options || {};\n    const rnds = options.random ?? options.rng?.() ?? rng();\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    rnds[6] = (rnds[6] & 0x0f) | 0x40;\n    rnds[8] = (rnds[8] & 0x3f) | 0x80;\n    if (buf) {\n        offset = offset || 0;\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n        for (let i = 0; i < 16; ++i) {\n            buf[offset + i] = rnds[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(rnds);\n}\nfunction v4(options, buf, offset) {\n    if (native.randomUUID && !buf && !options) {\n        return native.randomUUID();\n    }\n    return _v4(options, buf, offset);\n}\nexport default v4;\n", "import { createHash } from 'node:crypto';\nfunction sha1(bytes) {\n    if (Array.isArray(bytes)) {\n        bytes = Buffer.from(bytes);\n    }\n    else if (typeof bytes === 'string') {\n        bytes = Buffer.from(bytes, 'utf8');\n    }\n    return createHash('sha1').update(bytes).digest();\n}\nexport default sha1;\n", "import sha1 from './sha1.js';\nimport v35, { DNS, URL } from './v35.js';\nexport { DNS, URL } from './v35.js';\nfunction v5(value, namespace, buf, offset) {\n    return v35(0x50, sha1, value, namespace, buf, offset);\n}\nv5.DNS = DNS;\nv5.URL = URL;\nexport default v5;\n", "import { unsafeStringify } from './stringify.js';\nimport v1 from './v1.js';\nimport v1ToV6 from './v1ToV6.js';\nfunction v6(options, buf, offset) {\n    options ??= {};\n    offset ??= 0;\n    let bytes = v1({ ...options, _v6: true }, new Uint8Array(16));\n    bytes = v1ToV6(bytes);\n    if (buf) {\n        for (let i = 0; i < 16; i++) {\n            buf[offset + i] = bytes[i];\n        }\n        return buf;\n    }\n    return unsafeStringify(bytes);\n}\nexport default v6;\n", "import parse from './parse.js';\nimport { unsafeStringify } from './stringify.js';\nexport default function v6ToV1(uuid) {\n    const v6Bytes = typeof uuid === 'string' ? parse(uuid) : uuid;\n    const v1Bytes = _v6ToV1(v6Bytes);\n    return typeof uuid === 'string' ? unsafeStringify(v1Bytes) : v1Bytes;\n}\nfunction _v6ToV1(v6Bytes) {\n    return Uint8Array.of(((v6Bytes[3] & 0x0f) << 4) | ((v6Bytes[4] >> 4) & 0x0f), ((v6Bytes[4] & 0x0f) << 4) | ((v6Bytes[5] & 0xf0) >> 4), ((v6Bytes[5] & 0x0f) << 4) | (v6Bytes[6] & 0x0f), v6Bytes[7], ((v6Bytes[1] & 0x0f) << 4) | ((v6Bytes[2] & 0xf0) >> 4), ((v6Bytes[2] & 0x0f) << 4) | ((v6Bytes[3] & 0xf0) >> 4), 0x10 | ((v6Bytes[0] & 0xf0) >> 4), ((v6Bytes[0] & 0x0f) << 4) | ((v6Bytes[1] & 0xf0) >> 4), v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);\n}\n", "import rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nconst _state = {};\nfunction v7(options, buf, offset) {\n    let bytes;\n    if (options) {\n        bytes = v7Bytes(options.random ?? options.rng?.() ?? rng(), options.msecs, options.seq, buf, offset);\n    }\n    else {\n        const now = Date.now();\n        const rnds = rng();\n        updateV7State(_state, now, rnds);\n        bytes = v7Bytes(rnds, _state.msecs, _state.seq, buf, offset);\n    }\n    return buf ?? unsafeStringify(bytes);\n}\nexport function updateV7State(state, now, rnds) {\n    state.msecs ??= -Infinity;\n    state.seq ??= 0;\n    if (now > state.msecs) {\n        state.seq = (rnds[6] << 23) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n        state.msecs = now;\n    }\n    else {\n        state.seq = (state.seq + 1) | 0;\n        if (state.seq === 0) {\n            state.msecs++;\n        }\n    }\n    return state;\n}\nfunction v7Bytes(rnds, msecs, seq, buf, offset = 0) {\n    if (rnds.length < 16) {\n        throw new Error('Random bytes length must be >= 16');\n    }\n    if (!buf) {\n        buf = new Uint8Array(16);\n        offset = 0;\n    }\n    else {\n        if (offset < 0 || offset + 16 > buf.length) {\n            throw new RangeError(`UUID byte range ${offset}:${offset + 15} is out of buffer bounds`);\n        }\n    }\n    msecs ??= Date.now();\n    seq ??= ((rnds[6] * 0x7f) << 24) | (rnds[7] << 16) | (rnds[8] << 8) | rnds[9];\n    buf[offset++] = (msecs / 0x10000000000) & 0xff;\n    buf[offset++] = (msecs / 0x100000000) & 0xff;\n    buf[offset++] = (msecs / 0x1000000) & 0xff;\n    buf[offset++] = (msecs / 0x10000) & 0xff;\n    buf[offset++] = (msecs / 0x100) & 0xff;\n    buf[offset++] = msecs & 0xff;\n    buf[offset++] = 0x70 | ((seq >>> 28) & 0x0f);\n    buf[offset++] = (seq >>> 20) & 0xff;\n    buf[offset++] = 0x80 | ((seq >>> 14) & 0x3f);\n    buf[offset++] = (seq >>> 6) & 0xff;\n    buf[offset++] = ((seq << 2) & 0xff) | (rnds[10] & 0x03);\n    buf[offset++] = rnds[11];\n    buf[offset++] = rnds[12];\n    buf[offset++] = rnds[13];\n    buf[offset++] = rnds[14];\n    buf[offset++] = rnds[15];\n    return buf;\n}\nexport default v7;\n", "import validate from './validate.js';\nfunction version(uuid) {\n    if (!validate(uuid)) {\n        throw TypeError('Invalid UUID');\n    }\n    return parseInt(uuid.slice(14, 15), 16);\n}\nexport default version;\n", "export { default as MAX } from './max.js';\nexport { default as NIL } from './nil.js';\nexport { default as parse } from './parse.js';\nexport { default as stringify } from './stringify.js';\nexport { default as v1 } from './v1.js';\nexport { default as v1ToV6 } from './v1ToV6.js';\nexport { default as v3 } from './v3.js';\nexport { default as v4 } from './v4.js';\nexport { default as v5 } from './v5.js';\nexport { default as v6 } from './v6.js';\nexport { default as v6ToV1 } from './v6ToV1.js';\nexport { default as v7 } from './v7.js';\nexport { default as validate } from './validate.js';\nexport { default as version } from './version.js';\n", "// DynamoDB client wrapper with local/production mode support\nimport AWS from 'aws-sdk';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\nimport { Job, JobStatus, StageStatus } from '../models/job';\nimport { LectureAgent } from '../models/agent';\nimport { ExtractedContent, SegmentedContent } from '../models/content';\nimport { WordTiming } from '../models/audio';\n\n// Configure AWS SDK based on environment\nconst dynamoDBConfig: AWS.DynamoDB.ClientConfiguration = {\n  region: config.aws.region,\n};\n\nif (config.localstack.useLocalStack) {\n  dynamoDBConfig.endpoint = config.localstack.endpoint;\n  dynamoDBConfig.accessKeyId = 'test';\n  dynamoDBConfig.secretAccessKey = 'test';\n} else if (config.aws.accessKeyId && config.aws.secretAccessKey) {\n  dynamoDBConfig.accessKeyId = config.aws.accessKeyId;\n  dynamoDBConfig.secretAccessKey = config.aws.secretAccessKey;\n}\n\nconst dynamoDB = new AWS.DynamoDB.DocumentClient(dynamoDBConfig);\n\n// Helper function to handle DynamoDB errors\nfunction handleDynamoDBError(error: any, operation: string): never {\n  logger.error(`DynamoDB ${operation} failed`, { error: error.message });\n  throw new Error(`Database operation failed: ${operation}`);\n}\n\n// ============================================================================\n// Jobs Table Operations\n// ============================================================================\n\nexport interface JobRecord {\n  jobId: string;\n  status: JobStatus;\n  createdAt: string;\n  updatedAt: string;\n  pdfFilename: string;\n  pdfUrl: string;\n  agentId?: string;\n  stages: StageStatus[];\n  error?: string;\n}\n\nfunction jobToRecord(job: Job): JobRecord {\n  return {\n    ...job,\n    createdAt: job.createdAt.toISOString(),\n    updatedAt: job.updatedAt.toISOString(),\n  };\n}\n\nfunction recordToJob(record: JobRecord): Job {\n  return {\n    ...record,\n    createdAt: new Date(record.createdAt),\n    updatedAt: new Date(record.updatedAt),\n    stages: record.stages.map(stage => ({\n      ...stage,\n      startedAt: stage.startedAt ? new Date(stage.startedAt) : undefined,\n      completedAt: stage.completedAt ? new Date(stage.completedAt) : undefined,\n    })),\n  };\n}\n\nexport async function createJob(job: Job): Promise<Job> {\n  try {\n    const record = jobToRecord(job);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job created', { jobId: job.jobId });\n    return job;\n  } catch (error) {\n    handleDynamoDBError(error, 'createJob');\n  }\n}\n\nexport async function getJob(jobId: string): Promise<Job | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToJob(result.Item as JobRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getJob');\n  }\n}\n\nexport async function updateJob(jobId: string, updates: Partial<Job>): Promise<Job> {\n  try {\n    const current = await getJob(jobId);\n    if (!current) {\n      throw new Error(`Job not found: ${jobId}`);\n    }\n    \n    const updated: Job = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date(),\n    };\n    \n    const record = jobToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateJob');\n  }\n}\n\nexport async function deleteJob(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Job deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteJob');\n  }\n}\n\nexport async function listJobs(): Promise<Job[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.jobsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToJob(item as JobRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listJobs');\n  }\n}\n\n// ============================================================================\n// Agents Table Operations\n// ============================================================================\n\nexport interface AgentRecord {\n  id: string;\n  name: string;\n  description: string;\n  personality: {\n    instructions: string;\n    tone: string;\n    examples?: string[];\n  };\n  voice: {\n    voiceId: string;\n    speed: number;\n    pitch: number;\n  };\n  createdAt: string;\n}\n\nfunction agentToRecord(agent: LectureAgent): AgentRecord {\n  return {\n    ...agent,\n    createdAt: agent.createdAt.toISOString(),\n  };\n}\n\nfunction recordToAgent(record: AgentRecord): LectureAgent {\n  return {\n    ...record,\n    personality: {\n      ...record.personality,\n      tone: record.personality.tone as any,\n    },\n    createdAt: new Date(record.createdAt),\n  };\n}\n\nexport async function createAgent(agent: LectureAgent): Promise<LectureAgent> {\n  try {\n    // Check for unique name\n    const existing = await listAgents();\n    if (existing.some(a => a.name === agent.name && a.id !== agent.id)) {\n      throw new Error(`Agent with name \"${agent.name}\" already exists`);\n    }\n    \n    const record = agentToRecord(agent);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent created', { agentId: agent.id, name: agent.name });\n    return agent;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('already exists')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'createAgent');\n  }\n}\n\nexport async function getAgent(id: string): Promise<LectureAgent | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToAgent(result.Item as AgentRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getAgent');\n  }\n}\n\nexport async function updateAgent(id: string, updates: Partial<LectureAgent>): Promise<LectureAgent> {\n  try {\n    const current = await getAgent(id);\n    if (!current) {\n      throw new Error(`Agent not found: ${id}`);\n    }\n    \n    // Check for unique name if name is being updated\n    if (updates.name && updates.name !== current.name) {\n      const existing = await listAgents();\n      if (existing.some(a => a.name === updates.name && a.id !== id)) {\n        throw new Error(`Agent with name \"${updates.name}\" already exists`);\n      }\n    }\n    \n    const updated: LectureAgent = {\n      ...current,\n      ...updates,\n      id, // Ensure id doesn't change\n      // Deep merge nested objects\n      personality: updates.personality ? {\n        ...current.personality,\n        ...updates.personality,\n      } : current.personality,\n      voice: updates.voice ? {\n        ...current.voice,\n        ...updates.voice,\n      } : current.voice,\n    };\n    \n    const record = agentToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent updated', { agentId: id });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && (error.message.includes('already exists') || error.message.includes('not found'))) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateAgent');\n  }\n}\n\nexport async function deleteAgent(id: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    logger.info('Agent deleted', { agentId: id });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteAgent');\n  }\n}\n\nexport async function listAgents(): Promise<LectureAgent[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.agentsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToAgent(item as AgentRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listAgents');\n  }\n}\n\n// ============================================================================\n// Content Table Operations\n// ============================================================================\n\nexport interface ContentRecord {\n  jobId: string;\n  extractedContent?: ExtractedContent;\n  segmentedContent?: SegmentedContent;\n  script?: any; // LectureScript type from script model\n  audioUrl?: string;\n  wordTimings?: WordTiming[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport async function createContent(jobId: string): Promise<ContentRecord> {\n  try {\n    const record: ContentRecord = {\n      jobId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Content record created', { jobId });\n    return record;\n  } catch (error) {\n    handleDynamoDBError(error, 'createContent');\n  }\n}\n\nexport async function getContent(jobId: string): Promise<ContentRecord | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return result.Item as ContentRecord;\n  } catch (error) {\n    handleDynamoDBError(error, 'getContent');\n  }\n}\n\nexport async function updateContent(jobId: string, updates: Partial<ContentRecord>): Promise<ContentRecord> {\n  try {\n    const current = await getContent(jobId);\n    if (!current) {\n      throw new Error(`Content not found for job: ${jobId}`);\n    }\n    \n    const updated: ContentRecord = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: updated,\n    }).promise();\n    \n    logger.info('Content updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateContent');\n  }\n}\n\nexport async function deleteContent(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Content deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteContent');\n  }\n}\n\n// ============================================================================\n// Table Creation (for local development)\n// ============================================================================\n\nexport async function createTablesIfNotExist(): Promise<void> {\n  if (!config.localstack.useLocalStack) {\n    logger.info('Skipping table creation in production mode');\n    return;\n  }\n  \n  const dynamoDBClient = new AWS.DynamoDB(dynamoDBConfig);\n  \n  const tables = [\n    {\n      TableName: config.dynamodb.jobsTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.agentsTable,\n      KeySchema: [{ AttributeName: 'id', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'id', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.contentTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n  ];\n  \n  for (const tableConfig of tables) {\n    try {\n      await dynamoDBClient.describeTable({ TableName: tableConfig.TableName }).promise();\n      logger.info(`Table ${tableConfig.TableName} already exists`);\n    } catch (error: any) {\n      if (error.code === 'ResourceNotFoundException') {\n        try {\n          await dynamoDBClient.createTable({\n            ...tableConfig,\n            BillingMode: 'PAY_PER_REQUEST',\n          }).promise();\n          logger.info(`Table ${tableConfig.TableName} created`);\n        } catch (createError) {\n          logger.error(`Failed to create table ${tableConfig.TableName}`, { error: createError });\n        }\n      }\n    }\n  }\n}\n", "// Segmenter function - Serverless function wrapper\nimport { segmentContent } from '../services/segmenter';\nimport { getJob, updateJob } from '../services/dynamodb';\nimport { triggerScriptGeneration } from '../services/eventbridge';\nimport { ErrorResponse } from '../models/errors';\nimport { logger } from '../utils/logger';\nimport { config } from '../utils/config';\n\n/**\n * Lambda handler for content segmentation\n * This function segments extracted content into logical topics,\n * applies dependency-based ordering, and triggers script generation.\n */\nexport async function segmenterHandler(event: any): Promise<any> {\n  try {\n    logger.info('Segmenter function invoked');\n    \n    // Parse the request\n    const jobId = event.jobId;\n    \n    if (!jobId) {\n      throw new Error('jobId is required');\n    }\n    \n    // Get the job\n    const job = await getJob(jobId);\n    if (!job) {\n      throw new Error(`Job not found: ${jobId}`);\n    }\n    \n    // Update job status to 'segmenting'\n    await updateJob(jobId, {\n      status: 'segmenting',\n      stages: job.stages.map(stage =>\n        stage.stage === 'segmentation'\n          ? { ...stage, status: 'in_progress', startedAt: new Date() }\n          : stage\n      ),\n    });\n    \n    logger.info('Starting content segmentation', { jobId });\n    \n    // Segment the content\n    const segmentedContent = await segmentContent(jobId);\n    \n    // Update job status to 'generating_script'\n    await updateJob(jobId, {\n      status: 'generating_script',\n      stages: job.stages.map(stage => {\n        if (stage.stage === 'segmentation') {\n          return { ...stage, status: 'completed', completedAt: new Date() };\n        }\n        if (stage.stage === 'script_generation') {\n          return { ...stage, status: 'in_progress', startedAt: new Date() };\n        }\n        return stage;\n      }),\n    });\n    \n    logger.info('Content segmentation completed successfully', { jobId });\n    \n    // Trigger script generation asynchronously in production\n    if (config.nodeEnv === 'production') {\n      await triggerScriptGeneration(jobId, job.agentId);\n      logger.info('Script generation triggered asynchronously', { jobId });\n    }\n    \n    return {\n      statusCode: 200,\n      body: JSON.stringify({\n        jobId,\n        status: 'generating_script',\n        message: 'Content segmentation completed',\n        segmentedContent: {\n          segments: segmentedContent.segments.length,\n        },\n      }),\n    };\n  } catch (error) {\n    logger.error('Segmenter handler error', { error });\n    \n    const errorResponse: ErrorResponse = {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      code: 'SEGMENTATION_FAILED',\n      retryable: true,\n    };\n    \n    // Try to update job status to failed\n    if (event.jobId) {\n      try {\n        const job = await getJob(event.jobId);\n        if (job) {\n          await updateJob(event.jobId, {\n            status: 'failed',\n            error: errorResponse.error,\n            stages: job.stages.map(stage =>\n              stage.stage === 'segmentation'\n                ? { ...stage, status: 'failed', error: errorResponse.error }\n                : stage\n            ),\n          });\n        }\n      } catch (updateError) {\n        logger.error('Failed to update job status', { error: updateError });\n      }\n    }\n    \n    return {\n      statusCode: 500,\n      body: JSON.stringify(errorResponse),\n    };\n  }\n}\n", "// Content Segmenter service - Organize extracted content into logical topic segments\nimport { logger } from '../utils/logger';\nimport { config } from '../utils/config';\nimport { ExtractedContent, SegmentedContent, ContentSegment, ContentBlock } from '../models/content';\nimport { llmService, getRecommendedModel } from './llm';\nimport { recordLLMCallMetrics } from '../utils/llm-metrics';\n\nconst { v4: uuidv4 } = require('uuid');\n\n/**\n * Create a prompt for the LLM to segment content into logical topics\n */\nexport function createSegmentationPrompt(extractedContent: ExtractedContent): string {\n  // Build a comprehensive text representation of the content\n  const contentSummary = buildContentSummary(extractedContent);\n  \n  const prompt = `You are an expert at analyzing scientific documents and organizing them into logical learning segments.\n\nI will provide you with the extracted content from a scientific PDF, including text, figures, tables, formulas, and citations.\n\nYour task is to:\n1. Identify distinct topics and concepts in the content\n2. Group related concepts together into coherent segments\n3. Create a logical narrative flow where concepts build upon each other\n4. Identify prerequisite relationships (which concepts must be understood before others)\n5. Provide a clear title for each segment\n\nContent to analyze:\n${contentSummary}\n\nPlease respond with a JSON object in the following format:\n{\n  \"segments\": [\n    {\n      \"title\": \"Clear, descriptive title for the segment\",\n      \"contentIndices\": {\n        \"pageRanges\": [[startPage, endPage], ...],\n        \"figureIds\": [\"id1\", \"id2\", ...],\n        \"tableIds\": [\"id1\", \"id2\", ...],\n        \"formulaIds\": [\"id1\", \"id2\", ...],\n        \"citationIds\": [\"id1\", \"id2\", ...]\n      },\n      \"prerequisites\": [0, 1, ...] // Indices of segments that should come before this one\n    },\n    ...\n  ]\n}\n\nGuidelines:\n- Create as many segments as needed to organize the content into logical, cohesive topics\n- Each segment should represent a distinct concept or theme that can be understood as a unit\n- Segments should flow logically from foundational to advanced concepts\n- Prerequisites should only reference earlier segments (lower indices)\n- Include all relevant figures, tables, formulas for each segment\n- Ensure all content is assigned to at least one segment\n- Aim for segments that are substantial enough to be meaningful but focused enough to be digestible\n\nRespond ONLY with the JSON object, no additional text.`;\n\n  return prompt;\n}\n\n/**\n * Build a summary of extracted content for the LLM prompt\n * Enhanced to provide comprehensive document overview with inventory and context\n */\nfunction buildContentSummary(extractedContent: ExtractedContent): string {\n  const parts: string[] = [];\n  \n  // DOCUMENT OVERVIEW - High-level statistics\n  parts.push('=== DOCUMENT OVERVIEW ===');\n  parts.push(`Total Pages: ${extractedContent.pages.length}`);\n  parts.push(`Figures: ${extractedContent.figures.length}`);\n  parts.push(`Tables: ${extractedContent.tables.length}`);\n  parts.push(`Formulas: ${extractedContent.formulas.length}`);\n  parts.push(`Citations: ${extractedContent.citations.length}`);\n  \n  // Calculate estimated complexity\n  const totalElements = extractedContent.figures.length + \n                       extractedContent.tables.length + \n                       extractedContent.formulas.length;\n  const complexity = totalElements > 15 ? 'High' : totalElements > 8 ? 'Medium' : 'Low';\n  parts.push(`Estimated Complexity: ${complexity}`);\n  \n  // ELEMENT INVENTORY - Quick reference of all visual elements\n  if (extractedContent.figures.length > 0) {\n    parts.push('\\n=== FIGURE INVENTORY ===');\n    extractedContent.figures.forEach(figure => {\n      const caption = figure.caption || 'No caption';\n      parts.push(`- Figure ${figure.id} (Page ${figure.pageNumber}): ${caption}`);\n    });\n  }\n  \n  if (extractedContent.tables.length > 0) {\n    parts.push('\\n=== TABLE INVENTORY ===');\n    extractedContent.tables.forEach(table => {\n      const headerSummary = table.headers.length > 0 \n        ? table.headers.slice(0, 3).join(', ') + (table.headers.length > 3 ? '...' : '')\n        : 'No headers';\n      parts.push(`- Table ${table.id} (Page ${table.pageNumber}): ${headerSummary} (${table.rows.length} rows)`);\n    });\n  }\n  \n  if (extractedContent.formulas.length > 0) {\n    parts.push('\\n=== FORMULA INVENTORY ===');\n    extractedContent.formulas.forEach(formula => {\n      // Truncate long LaTeX for inventory\n      const latexPreview = formula.latex.length > 50 \n        ? formula.latex.substring(0, 50) + '...'\n        : formula.latex;\n      parts.push(`- Formula ${formula.id} (Page ${formula.pageNumber}): ${latexPreview}`);\n    });\n  }\n  \n  // CITATION CONTEXT - Key references\n  if (extractedContent.citations.length > 0) {\n    parts.push('\\n=== CITATION CONTEXT ===');\n    parts.push(`Total Citations: ${extractedContent.citations.length}`);\n    \n    // Show first few citations as examples\n    const citationsToShow = Math.min(5, extractedContent.citations.length);\n    parts.push(`Key Citations (showing ${citationsToShow} of ${extractedContent.citations.length}):`);\n    \n    extractedContent.citations.slice(0, citationsToShow).forEach(citation => {\n      if (citation.authors && citation.year && citation.title) {\n        const authorStr = citation.authors.length > 2\n          ? `${citation.authors[0]} et al.`\n          : citation.authors.join(', ');\n        parts.push(`- [${citation.id}] ${authorStr} (${citation.year}): ${citation.title}`);\n      } else {\n        parts.push(`- [${citation.id}] ${citation.text}`);\n      }\n    });\n    \n    if (extractedContent.citations.length > citationsToShow) {\n      parts.push(`... and ${extractedContent.citations.length - citationsToShow} more citations`);\n    }\n  }\n  \n  // PAGE SUMMARIES - Detailed content by page\n  parts.push('\\n=== PAGE SUMMARIES ===');\n  extractedContent.pages.forEach(page => {\n    parts.push(`\\n--- Page ${page.pageNumber} ---`);\n    \n    // Add element references for this page\n    const pageElements: string[] = [];\n    \n    // Find figures on this page\n    const pageFigures = extractedContent.figures.filter(f => f.pageNumber === page.pageNumber);\n    if (pageFigures.length > 0) {\n      pageElements.push(`Figures: ${pageFigures.map(f => f.id).join(', ')}`);\n    }\n    \n    // Find tables on this page\n    const pageTables = extractedContent.tables.filter(t => t.pageNumber === page.pageNumber);\n    if (pageTables.length > 0) {\n      pageElements.push(`Tables: ${pageTables.map(t => t.id).join(', ')}`);\n    }\n    \n    // Find formulas on this page\n    const pageFormulas = extractedContent.formulas.filter(f => f.pageNumber === page.pageNumber);\n    if (pageFormulas.length > 0) {\n      pageElements.push(`Formulas: ${pageFormulas.map(f => f.id).join(', ')}`);\n    }\n    \n    if (pageElements.length > 0) {\n      parts.push(`Elements: ${pageElements.join(' | ')}`);\n    }\n    \n    // Add text content (truncated for very long pages)\n    const maxTextLength = 600;\n    if (page.text.length > maxTextLength) {\n      const truncated = page.text.substring(0, maxTextLength);\n      // Try to truncate at sentence boundary\n      const lastPeriod = truncated.lastIndexOf('.');\n      const text = lastPeriod > maxTextLength * 0.7 \n        ? truncated.substring(0, lastPeriod + 1)\n        : truncated;\n      parts.push(`Text: ${text}...[truncated, ${page.text.length - text.length} chars remaining]`);\n    } else {\n      parts.push(`Text: ${page.text}`);\n    }\n  });\n  \n  // DETAILED ELEMENT DESCRIPTIONS\n  if (extractedContent.figures.length > 0) {\n    parts.push('\\n=== DETAILED FIGURE DESCRIPTIONS ===');\n    extractedContent.figures.forEach(figure => {\n      parts.push(`\\n[${figure.id}] Page ${figure.pageNumber}`);\n      if (figure.caption) {\n        parts.push(`Caption: ${figure.caption}`);\n      }\n      parts.push(`Description: ${figure.description}`);\n    });\n  }\n  \n  if (extractedContent.tables.length > 0) {\n    parts.push('\\n=== DETAILED TABLE DESCRIPTIONS ===');\n    extractedContent.tables.forEach(table => {\n      parts.push(`\\n[${table.id}] Page ${table.pageNumber}`);\n      parts.push(`Headers: ${table.headers.join(' | ')}`);\n      parts.push(`Rows: ${table.rows.length}`);\n      parts.push(`Interpretation: ${table.interpretation}`);\n    });\n  }\n  \n  if (extractedContent.formulas.length > 0) {\n    parts.push('\\n=== DETAILED FORMULA DESCRIPTIONS ===');\n    extractedContent.formulas.forEach(formula => {\n      parts.push(`\\n[${formula.id}] Page ${formula.pageNumber}`);\n      parts.push(`LaTeX: ${formula.latex}`);\n      parts.push(`Explanation: ${formula.explanation}`);\n    });\n  }\n  \n  return parts.join('\\n');\n}\n\n/**\n * Interface for LLM segmentation response\n */\ninterface LLMSegmentResponse {\n  title: string;\n  contentIndices: {\n    pageRanges: number[][];\n    figureIds: string[];\n    tableIds: string[];\n    formulaIds: string[];\n    citationIds: string[];\n  };\n  prerequisites: number[];\n}\n\ninterface LLMSegmentationResponse {\n  segments: LLMSegmentResponse[];\n}\n\n/**\n * Build a dependency graph from segment prerequisites\n * Returns an adjacency list representation\n */\nexport function buildDependencyGraph(segments: LLMSegmentResponse[]): Map<number, number[]> {\n  const graph = new Map<number, number[]>();\n  \n  // Initialize graph with all segment indices\n  for (let i = 0; i < segments.length; i++) {\n    graph.set(i, []);\n  }\n  \n  // Add edges from prerequisites to dependents\n  segments.forEach((segment, index) => {\n    segment.prerequisites.forEach(prereqIndex => {\n      // Validate prerequisite index\n      if (prereqIndex >= 0 && prereqIndex < segments.length && prereqIndex !== index) {\n        const dependents = graph.get(prereqIndex) || [];\n        dependents.push(index);\n        graph.set(prereqIndex, dependents);\n      }\n    });\n  });\n  \n  return graph;\n}\n\n/**\n * Detect cycles in the dependency graph using DFS\n * Returns true if a cycle is detected\n */\nexport function hasCycle(graph: Map<number, number[]>, nodeCount: number): boolean {\n  const visited = new Set<number>();\n  const recursionStack = new Set<number>();\n  \n  function dfs(node: number): boolean {\n    visited.add(node);\n    recursionStack.add(node);\n    \n    const neighbors = graph.get(node) || [];\n    for (const neighbor of neighbors) {\n      if (!visited.has(neighbor)) {\n        if (dfs(neighbor)) {\n          return true;\n        }\n      } else if (recursionStack.has(neighbor)) {\n        // Found a back edge - cycle detected\n        return true;\n      }\n    }\n    \n    recursionStack.delete(node);\n    return false;\n  }\n  \n  // Check all nodes (graph might be disconnected)\n  for (let i = 0; i < nodeCount; i++) {\n    if (!visited.has(i)) {\n      if (dfs(i)) {\n        return true;\n      }\n    }\n  }\n  \n  return false;\n}\n\n/**\n * Perform topological sort on the dependency graph\n * Returns an ordered array of segment indices\n * Throws an error if a cycle is detected\n */\nexport function topologicalSort(segments: LLMSegmentResponse[]): number[] {\n  const graph = buildDependencyGraph(segments);\n  \n  // Check for cycles\n  if (hasCycle(graph, segments.length)) {\n    logger.warn('Circular dependencies detected in segments, using fallback ordering');\n    // Fallback: return original order\n    return segments.map((_, index) => index);\n  }\n  \n  // Kahn's algorithm for topological sort\n  const inDegree = new Map<number, number>();\n  \n  // Initialize in-degrees\n  for (let i = 0; i < segments.length; i++) {\n    inDegree.set(i, 0);\n  }\n  \n  // Calculate in-degrees\n  segments.forEach((segment, index) => {\n    segment.prerequisites.forEach(prereqIndex => {\n      if (prereqIndex >= 0 && prereqIndex < segments.length && prereqIndex !== index) {\n        inDegree.set(index, (inDegree.get(index) || 0) + 1);\n      }\n    });\n  });\n  \n  // Queue of nodes with no incoming edges\n  const queue: number[] = [];\n  for (let i = 0; i < segments.length; i++) {\n    if (inDegree.get(i) === 0) {\n      queue.push(i);\n    }\n  }\n  \n  const sorted: number[] = [];\n  \n  while (queue.length > 0) {\n    const node = queue.shift()!;\n    sorted.push(node);\n    \n    // Reduce in-degree for all dependents\n    const dependents = graph.get(node) || [];\n    dependents.forEach(dependent => {\n      const newInDegree = (inDegree.get(dependent) || 0) - 1;\n      inDegree.set(dependent, newInDegree);\n      \n      if (newInDegree === 0) {\n        queue.push(dependent);\n      }\n    });\n  }\n  \n  // If sorted doesn't contain all nodes, there's a cycle (shouldn't happen due to earlier check)\n  if (sorted.length !== segments.length) {\n    logger.warn('Topological sort incomplete, using fallback ordering');\n    return segments.map((_, index) => index);\n  }\n  \n  return sorted;\n}\n\n/**\n * Parse LLM response and convert to ContentSegment structures\n */\nexport function parseSegmentationResponse(\n  llmResponse: LLMSegmentationResponse,\n  extractedContent: ExtractedContent\n): ContentSegment[] {\n  const segments: ContentSegment[] = [];\n  \n  // Apply topological sort to get correct ordering\n  const sortedIndices = topologicalSort(llmResponse.segments);\n  \n  sortedIndices.forEach((originalIndex, newOrder) => {\n    const llmSegment = llmResponse.segments[originalIndex];\n    \n    // Build content blocks for this segment\n    const contentBlocks: ContentBlock[] = [];\n    \n    // Add text content from page ranges\n    llmSegment.contentIndices.pageRanges.forEach(([startPage, endPage]) => {\n      for (let pageNum = startPage; pageNum <= endPage; pageNum++) {\n        const page = extractedContent.pages.find(p => p.pageNumber === pageNum);\n        if (page && page.text.trim()) {\n          contentBlocks.push({\n            type: 'text',\n            content: page.text,\n            pageReference: pageNum,\n          });\n        }\n      }\n    });\n    \n    // Add figures\n    llmSegment.contentIndices.figureIds.forEach(figureId => {\n      const figure = extractedContent.figures.find(f => f.id === figureId);\n      if (figure) {\n        contentBlocks.push({\n          type: 'figure',\n          content: figure,\n          pageReference: figure.pageNumber,\n        });\n      }\n    });\n    \n    // Add tables\n    llmSegment.contentIndices.tableIds.forEach(tableId => {\n      const table = extractedContent.tables.find(t => t.id === tableId);\n      if (table) {\n        contentBlocks.push({\n          type: 'table',\n          content: table,\n          pageReference: table.pageNumber,\n        });\n      }\n    });\n    \n    // Add formulas\n    llmSegment.contentIndices.formulaIds.forEach(formulaId => {\n      const formula = extractedContent.formulas.find(f => f.id === formulaId);\n      if (formula) {\n        contentBlocks.push({\n          type: 'formula',\n          content: formula,\n          pageReference: formula.pageNumber,\n        });\n      }\n    });\n    \n    // Add citations\n    llmSegment.contentIndices.citationIds.forEach(citationId => {\n      const citation = extractedContent.citations.find(c => c.id === citationId);\n      if (citation) {\n        contentBlocks.push({\n          type: 'citation',\n          content: citation,\n          pageReference: 0, // Citations don't have a specific page\n        });\n      }\n    });\n    \n    // Map prerequisites to new ordering\n    const mappedPrerequisites = llmSegment.prerequisites\n      .map(oldIndex => sortedIndices.indexOf(oldIndex))\n      .filter(newIndex => newIndex !== -1 && newIndex < newOrder);\n    \n    const segment: ContentSegment = {\n      id: uuidv4(),\n      title: llmSegment.title,\n      order: newOrder,\n      contentBlocks,\n      prerequisites: mappedPrerequisites.map(idx => segments[idx]?.id).filter(Boolean),\n    };\n    \n    segments.push(segment);\n  });\n  \n  return segments;\n}\n\n/**\n * Mock implementation for segmentation (used when feature flag is disabled)\n */\nasync function mockSegmentationLLM(_prompt: string): Promise<LLMSegmentationResponse> {\n  logger.info('Using mock segmentation (feature flag disabled)');\n  \n  // Simulate API delay\n  await new Promise(resolve => setTimeout(resolve, 200));\n  \n  // Return a simple mock segmentation\n  return {\n    segments: [\n      {\n        title: 'Introduction and Background',\n        contentIndices: {\n          pageRanges: [[1, 2]],\n          figureIds: [],\n          tableIds: [],\n          formulaIds: [],\n          citationIds: [],\n        },\n        prerequisites: [],\n      },\n      {\n        title: 'Main Content',\n        contentIndices: {\n          pageRanges: [[3, 5]],\n          figureIds: [],\n          tableIds: [],\n          formulaIds: [],\n          citationIds: [],\n        },\n        prerequisites: [0],\n      },\n      {\n        title: 'Conclusion',\n        contentIndices: {\n          pageRanges: [[6, 6]],\n          figureIds: [],\n          tableIds: [],\n          formulaIds: [],\n          citationIds: [],\n        },\n        prerequisites: [1],\n      },\n    ],\n  };\n}\n\n/**\n * Call LLM API to segment content\n * Uses the existing LLM service to analyze content and create logical segments\n * Exported for testing purposes\n */\nexport async function callSegmentationLLM(prompt: string, correlationId?: string): Promise<LLMSegmentationResponse> {\n  // Check feature flag\n  if (!config.featureFlags.enableRealSegmentation) {\n    logger.info('Real segmentation disabled by feature flag, using mock implementation', {\n      correlationId,\n    });\n    return mockSegmentationLLM(prompt);\n  }\n  \n  const startTime = Date.now();\n  const requestId = correlationId || uuidv4();\n  let model: string | undefined;\n  \n  try {\n    model = getRecommendedModel('segmentation', llmService.getProvider());\n    \n    logger.info('Calling LLM for content segmentation', {\n      correlationId: requestId,\n      model,\n      provider: llmService.getProvider(),\n      promptLength: prompt.length,\n    });\n    \n    // The llmService.chat already includes retry logic via withRetry\n    // We'll track attempts through error handling\n    const response = await llmService.chat({\n      messages: [\n        {\n          role: 'system',\n          content: `You are an expert at analyzing scientific documents and organizing content into logical segments.\n\nYour task is to:\n1. Identify distinct topics and concepts in the content\n2. Group related concepts together\n3. Determine prerequisite relationships between segments\n4. Create a logical narrative flow\n\nReturn your response as JSON matching this exact structure:\n{\n  \"segments\": [\n    {\n      \"title\": \"string\",\n      \"contentIndices\": {\n        \"pageRanges\": [[startPage, endPage]],\n        \"figureIds\": [\"id1\", \"id2\"],\n        \"tableIds\": [\"id1\"],\n        \"formulaIds\": [\"id1\"],\n        \"citationIds\": [\"id1\"]\n      },\n      \"prerequisites\": [segmentIndex1, segmentIndex2]\n    }\n  ]\n}\n\nRespond ONLY with valid JSON, no additional text.`,\n        },\n        {\n          role: 'user',\n          content: prompt,\n        },\n      ],\n      model,\n      temperature: 0.7,\n      maxTokens: 2000,\n    });\n    \n    const apiCallDuration = Date.now() - startTime;\n    \n    logger.info('LLM API call completed', {\n      correlationId: requestId,\n      model,\n      duration: apiCallDuration,\n      responseLength: response.content.length,\n      tokensUsed: response.usage?.totalTokens,\n      promptTokens: response.usage?.promptTokens,\n      completionTokens: response.usage?.completionTokens,\n    });\n    \n    // Record operation-specific metrics\n    if (response.usage) {\n      recordLLMCallMetrics({\n        operation: 'segmentation',\n        model: response.model,\n        provider: llmService.getProvider(),\n        promptTokens: response.usage.promptTokens,\n        completionTokens: response.usage.completionTokens,\n        totalTokens: response.usage.totalTokens,\n        durationMs: apiCallDuration,\n        success: true,\n      });\n    }\n    \n    // Parse JSON response\n    let segmentationData: LLMSegmentationResponse;\n    try {\n      segmentationData = JSON.parse(response.content);\n    } catch (parseError) {\n      // Log detailed information about JSON parsing failure\n      const errorMessage = parseError instanceof Error ? parseError.message : 'Unknown parsing error';\n      const responsePreview = response.content.substring(0, 500);\n      const responseSuffix = response.content.length > 500 \n        ? `...[truncated, total length: ${response.content.length}]` \n        : '';\n      \n      logger.error('Failed to parse LLM response as JSON', {\n        error: errorMessage,\n        parseError: parseError,\n        model,\n        responsePreview: responsePreview + responseSuffix,\n        responseLength: response.content.length,\n        tokensUsed: response.usage?.totalTokens,\n      });\n      \n      throw new Error(\n        `LLM returned invalid JSON response. Parse error: ${errorMessage}. ` +\n        `Response preview: ${responsePreview.substring(0, 100)}...`\n      );\n    }\n    \n    // Validate structure\n    if (!segmentationData.segments || !Array.isArray(segmentationData.segments)) {\n      logger.error('Invalid segmentation response structure', {\n        model,\n        hasSegments: !!segmentationData.segments,\n        segmentsType: typeof segmentationData.segments,\n        responseKeys: Object.keys(segmentationData),\n      });\n      \n      throw new Error(\n        'Invalid segmentation response: missing or invalid segments array. ' +\n        `Expected array, got ${typeof segmentationData.segments}`\n      );\n    }\n    \n    if (segmentationData.segments.length === 0) {\n      logger.error('Empty segments array in response', {\n        model,\n        response: segmentationData,\n      });\n      \n      throw new Error('Invalid segmentation response: segments array is empty');\n    }\n    \n    // Validate each segment\n    for (let i = 0; i < segmentationData.segments.length; i++) {\n      const segment = segmentationData.segments[i];\n      \n      // Validate title\n      if (!segment.title || typeof segment.title !== 'string') {\n        logger.error('Invalid segment title', {\n          segmentIndex: i,\n          hasTitle: !!segment.title,\n          titleType: typeof segment.title,\n          segment,\n        });\n        \n        throw new Error(\n          `Invalid segment ${i}: missing or invalid title. ` +\n          `Expected string, got ${typeof segment.title}`\n        );\n      }\n      \n      if (segment.title.trim().length === 0) {\n        logger.error('Empty segment title', {\n          segmentIndex: i,\n          title: segment.title,\n        });\n        \n        throw new Error(`Invalid segment ${i}: title cannot be empty`);\n      }\n      \n      // Validate contentIndices exists\n      if (!segment.contentIndices) {\n        logger.error('Missing contentIndices', {\n          segmentIndex: i,\n          segmentKeys: Object.keys(segment),\n        });\n        \n        throw new Error(`Invalid segment ${i}: missing contentIndices`);\n      }\n      \n      // Validate contentIndices structure - pageRanges\n      if (!Array.isArray(segment.contentIndices.pageRanges)) {\n        logger.error('Invalid pageRanges structure', {\n          segmentIndex: i,\n          pageRangesType: typeof segment.contentIndices.pageRanges,\n        });\n        \n        throw new Error(\n          `Invalid segment ${i}: contentIndices.pageRanges must be an array. ` +\n          `Got ${typeof segment.contentIndices.pageRanges}`\n        );\n      }\n      \n      // Validate each page range\n      for (let j = 0; j < segment.contentIndices.pageRanges.length; j++) {\n        const range = segment.contentIndices.pageRanges[j];\n        \n        if (!Array.isArray(range) || range.length !== 2) {\n          logger.error('Invalid page range format', {\n            segmentIndex: i,\n            rangeIndex: j,\n            range,\n            isArray: Array.isArray(range),\n            length: Array.isArray(range) ? range.length : 'N/A',\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: pageRanges[${j}] must be an array of [startPage, endPage]. ` +\n            `Got ${Array.isArray(range) ? `array of length ${range.length}` : typeof range}`\n          );\n        }\n        \n        const [startPage, endPage] = range;\n        \n        if (typeof startPage !== 'number' || typeof endPage !== 'number') {\n          logger.error('Invalid page range types', {\n            segmentIndex: i,\n            rangeIndex: j,\n            startPageType: typeof startPage,\n            endPageType: typeof endPage,\n            range,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: pageRanges[${j}] must contain numbers. ` +\n            `Got [${typeof startPage}, ${typeof endPage}]`\n          );\n        }\n        \n        if (startPage < 1 || endPage < 1) {\n          logger.error('Invalid page numbers', {\n            segmentIndex: i,\n            rangeIndex: j,\n            startPage,\n            endPage,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: pageRanges[${j}] page numbers must be >= 1. ` +\n            `Got [${startPage}, ${endPage}]`\n          );\n        }\n        \n        if (startPage > endPage) {\n          logger.error('Invalid page range order', {\n            segmentIndex: i,\n            rangeIndex: j,\n            startPage,\n            endPage,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: pageRanges[${j}] startPage cannot be greater than endPage. ` +\n            `Got [${startPage}, ${endPage}]`\n          );\n        }\n      }\n      \n      // Validate contentIndices structure - ensure all required arrays exist\n      segment.contentIndices.figureIds = segment.contentIndices.figureIds || [];\n      segment.contentIndices.tableIds = segment.contentIndices.tableIds || [];\n      segment.contentIndices.formulaIds = segment.contentIndices.formulaIds || [];\n      segment.contentIndices.citationIds = segment.contentIndices.citationIds || [];\n      \n      // Validate that all ID arrays are actually arrays\n      const idArrays = [\n        { name: 'figureIds', value: segment.contentIndices.figureIds },\n        { name: 'tableIds', value: segment.contentIndices.tableIds },\n        { name: 'formulaIds', value: segment.contentIndices.formulaIds },\n        { name: 'citationIds', value: segment.contentIndices.citationIds },\n      ];\n      \n      for (const { name, value } of idArrays) {\n        if (!Array.isArray(value)) {\n          logger.error('Invalid ID array type', {\n            segmentIndex: i,\n            arrayName: name,\n            actualType: typeof value,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: contentIndices.${name} must be an array. ` +\n            `Got ${typeof value}`\n          );\n        }\n        \n        // Validate that all IDs are strings\n        for (let k = 0; k < value.length; k++) {\n          if (typeof value[k] !== 'string') {\n            logger.error('Invalid ID type in array', {\n              segmentIndex: i,\n              arrayName: name,\n              idIndex: k,\n              idType: typeof value[k],\n              idValue: value[k],\n            });\n            \n            throw new Error(\n              `Invalid segment ${i}: contentIndices.${name}[${k}] must be a string. ` +\n              `Got ${typeof value[k]}`\n            );\n          }\n        }\n      }\n      \n      // Validate prerequisites\n      if (!Array.isArray(segment.prerequisites)) {\n        logger.error('Invalid prerequisites type', {\n          segmentIndex: i,\n          prerequisitesType: typeof segment.prerequisites,\n        });\n        \n        throw new Error(\n          `Invalid segment ${i}: prerequisites must be an array. ` +\n          `Got ${typeof segment.prerequisites}`\n        );\n      }\n      \n      // Validate that prerequisites are valid indices\n      for (let k = 0; k < segment.prerequisites.length; k++) {\n        const prereqIndex = segment.prerequisites[k];\n        \n        if (typeof prereqIndex !== 'number') {\n          logger.error('Invalid prerequisite type', {\n            segmentIndex: i,\n            prerequisiteIndex: k,\n            prerequisiteType: typeof prereqIndex,\n            prerequisiteValue: prereqIndex,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: prerequisites[${k}] must be a number. ` +\n            `Got ${typeof prereqIndex}`\n          );\n        }\n        \n        if (!Number.isInteger(prereqIndex)) {\n          logger.error('Non-integer prerequisite index', {\n            segmentIndex: i,\n            prerequisiteIndex: k,\n            prerequisiteValue: prereqIndex,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: prerequisite indices must be integers. ` +\n            `Got ${prereqIndex}`\n          );\n        }\n        \n        if (prereqIndex < 0) {\n          logger.error('Negative prerequisite index', {\n            segmentIndex: i,\n            prerequisiteIndex: k,\n            prerequisiteValue: prereqIndex,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: prerequisite indices must be non-negative. ` +\n            `Got ${prereqIndex}`\n          );\n        }\n        \n        if (prereqIndex >= segmentationData.segments.length) {\n          logger.error('Prerequisite index out of bounds', {\n            segmentIndex: i,\n            prerequisiteIndex: k,\n            prerequisiteValue: prereqIndex,\n            maxValidIndex: segmentationData.segments.length - 1,\n            totalSegments: segmentationData.segments.length,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: prerequisite index ${prereqIndex} is out of bounds. ` +\n            `Valid range: 0-${segmentationData.segments.length - 1}`\n          );\n        }\n        \n        if (prereqIndex === i) {\n          logger.error('Self-referential prerequisite', {\n            segmentIndex: i,\n            prerequisiteIndex: k,\n            prerequisiteValue: prereqIndex,\n          });\n          \n          throw new Error(\n            `Invalid segment ${i}: segment cannot be a prerequisite of itself`\n          );\n        }\n      }\n    }\n    \n    const totalDuration = Date.now() - startTime;\n    \n    logger.info('Segmentation completed successfully', {\n      correlationId: requestId,\n      segmentCount: segmentationData.segments.length,\n      model,\n      totalDuration,\n      tokensUsed: response.usage?.totalTokens,\n    });\n    \n    return segmentationData;\n  } catch (error) {\n    const totalDuration = Date.now() - startTime;\n    \n    // Categorize and log error with full context\n    const errorType = categorizeSegmentationError(error);\n    const errorMessage = error instanceof Error ? error.message : 'Unknown error';\n    const errorStack = error instanceof Error ? error.stack : undefined;\n    \n    // Record failure metrics\n    recordLLMCallMetrics({\n      operation: 'segmentation',\n      model: model || 'unknown',\n      provider: llmService.getProvider(),\n      promptTokens: 0,\n      completionTokens: 0,\n      totalTokens: 0,\n      durationMs: totalDuration,\n      success: false,\n      errorType,\n    });\n    \n    logger.error('Segmentation LLM call failed', {\n      correlationId: requestId,\n      errorType,\n      errorMessage,\n      errorStack,\n      model,\n      provider: llmService.getProvider(),\n      duration: totalDuration,\n      promptLength: prompt.length,\n      // Include original error for debugging\n      originalError: error,\n    });\n    \n    // Re-throw with appropriate error type\n    if (errorType === 'JSON_PARSE_ERROR') {\n      throw new Error(`Segmentation failed: ${errorMessage}`);\n    } else if (errorType === 'VALIDATION_ERROR') {\n      throw new Error(`Segmentation validation failed: ${errorMessage}`);\n    } else if (errorType === 'API_ERROR') {\n      throw new Error(`LLM API error during segmentation: ${errorMessage}`);\n    } else {\n      throw new Error(`Failed to segment content: ${errorMessage}`);\n    }\n  }\n}\n\n/**\n * Categorize segmentation errors for better error handling and monitoring\n */\nfunction categorizeSegmentationError(error: any): string {\n  if (!error) {\n    return 'UNKNOWN_ERROR';\n  }\n  \n  const errorMessage = error.message?.toLowerCase() || '';\n  \n  // JSON parsing errors\n  if (error instanceof SyntaxError || errorMessage.includes('json') || errorMessage.includes('parse')) {\n    return 'JSON_PARSE_ERROR';\n  }\n  \n  // Validation errors\n  if (errorMessage.includes('invalid') || errorMessage.includes('missing') || errorMessage.includes('must be')) {\n    return 'VALIDATION_ERROR';\n  }\n  \n  // API errors\n  if (errorMessage.includes('api error') || errorMessage.includes('status') || errorMessage.includes('rate limit')) {\n    return 'API_ERROR';\n  }\n  \n  // Network errors\n  if (errorMessage.includes('timeout') || errorMessage.includes('connection') || errorMessage.includes('network')) {\n    return 'NETWORK_ERROR';\n  }\n  \n  return 'UNKNOWN_ERROR';\n}\n\n/**\n * Main segmentation function\n * Retrieves extracted content, segments it, and stores the result\n */\nexport async function segmentContent(jobId: string): Promise<SegmentedContent> {\n  const startTime = Date.now();\n  const correlationId = `seg-${jobId}-${uuidv4()}`;\n  \n  try {\n    logger.info('Starting content segmentation', { \n      jobId,\n      correlationId,\n    });\n    \n    // Import dynamodb functions here to avoid circular dependencies\n    const { getContent, updateContent } = require('./dynamodb');\n    \n    // Retrieve extracted content from database\n    let contentRecord;\n    try {\n      contentRecord = await getContent(jobId);\n    } catch (dbError) {\n      logger.error('Failed to retrieve content from database', {\n        jobId,\n        error: dbError,\n        errorMessage: dbError instanceof Error ? dbError.message : 'Unknown error',\n      });\n      throw new Error(`Database error: Failed to retrieve content for job ${jobId}`);\n    }\n    \n    if (!contentRecord) {\n      logger.error('Content record not found', { jobId });\n      throw new Error(`No content record found for job: ${jobId}`);\n    }\n    \n    if (!contentRecord.extractedContent) {\n      logger.error('Extracted content missing from record', {\n        jobId,\n        recordKeys: Object.keys(contentRecord),\n      });\n      throw new Error(`No extracted content found for job: ${jobId}`);\n    }\n    \n    const extractedContent = contentRecord.extractedContent;\n    \n    logger.info('Retrieved extracted content', {\n      jobId,\n      pageCount: extractedContent.pages.length,\n      figureCount: extractedContent.figures.length,\n      tableCount: extractedContent.tables.length,\n      formulaCount: extractedContent.formulas.length,\n      citationCount: extractedContent.citations.length,\n    });\n    \n    // Create segmentation prompt\n    let prompt: string;\n    try {\n      prompt = createSegmentationPrompt(extractedContent);\n      logger.info('Created segmentation prompt', {\n        jobId,\n        promptLength: prompt.length,\n      });\n    } catch (promptError) {\n      logger.error('Failed to create segmentation prompt', {\n        jobId,\n        error: promptError,\n        errorMessage: promptError instanceof Error ? promptError.message : 'Unknown error',\n      });\n      throw new Error(`Failed to create segmentation prompt: ${promptError instanceof Error ? promptError.message : 'Unknown error'}`);\n    }\n    \n    // Call LLM for segmentation (includes retry logic)\n    let llmResponse: LLMSegmentationResponse;\n    try {\n      llmResponse = await callSegmentationLLM(prompt, correlationId);\n    } catch (llmError) {\n      logger.error('LLM segmentation call failed after retries', {\n        jobId,\n        correlationId,\n        error: llmError,\n        errorMessage: llmError instanceof Error ? llmError.message : 'Unknown error',\n      });\n      // Re-throw with context\n      throw new Error(`LLM segmentation failed: ${llmError instanceof Error ? llmError.message : 'Unknown error'}`);\n    }\n    \n    // Parse LLM response and apply dependency-based ordering\n    let segments;\n    try {\n      segments = parseSegmentationResponse(llmResponse, extractedContent);\n      logger.info('Parsed segmentation response', {\n        jobId,\n        segmentCount: segments.length,\n      });\n    } catch (parseError) {\n      logger.error('Failed to parse segmentation response', {\n        jobId,\n        error: parseError,\n        errorMessage: parseError instanceof Error ? parseError.message : 'Unknown error',\n        segmentCount: llmResponse.segments.length,\n      });\n      throw new Error(`Failed to parse segmentation response: ${parseError instanceof Error ? parseError.message : 'Unknown error'}`);\n    }\n    \n    const segmentedContent: SegmentedContent = {\n      segments,\n    };\n    \n    // Store segmented content in database\n    try {\n      await updateContent(jobId, {\n        segmentedContent,\n      });\n      logger.info('Stored segmented content in database', {\n        jobId,\n        segmentCount: segments.length,\n      });\n    } catch (dbError) {\n      logger.error('Failed to store segmented content in database', {\n        jobId,\n        error: dbError,\n        errorMessage: dbError instanceof Error ? dbError.message : 'Unknown error',\n        segmentCount: segments.length,\n      });\n      throw new Error(`Database error: Failed to store segmented content for job ${jobId}`);\n    }\n    \n    const totalDuration = Date.now() - startTime;\n    \n    logger.info('Content segmentation completed successfully', {\n      jobId,\n      segmentCount: segments.length,\n      totalDuration,\n    });\n    \n    return segmentedContent;\n  } catch (error) {\n    const totalDuration = Date.now() - startTime;\n    \n    logger.error('Content segmentation failed', {\n      jobId,\n      error,\n      errorMessage: error instanceof Error ? error.message : 'Unknown error',\n      errorStack: error instanceof Error ? error.stack : undefined,\n      duration: totalDuration,\n    });\n    \n    throw error;\n  }\n}\n", "/**\n * LLM Service - Unified interface for multiple LLM providers via OpenRouter\n * \n * Supports:\n * - OpenRouter (unified access to OpenAI, Anthropic, Google, Meta, etc.)\n * - Direct OpenAI API\n * - Direct Anthropic API\n */\n\nimport { logger } from '../utils/logger';\nimport { withRetry } from '../utils/retry';\nimport { recordLLMCallMetrics } from '../utils/llm-metrics';\n\nexport interface LLMMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string;\n}\n\nexport interface LLMRequest {\n  messages: LLMMessage[];\n  model?: string;\n  temperature?: number;\n  maxTokens?: number;\n  stream?: boolean;\n}\n\nexport interface LLMResponse {\n  content: string;\n  model: string;\n  usage?: {\n    promptTokens: number;\n    completionTokens: number;\n    totalTokens: number;\n  };\n}\n\nexport interface VisionRequest {\n  imageUrl: string;\n  prompt: string;\n  model?: string;\n}\n\n/**\n * LLM Provider types\n */\nexport type LLMProvider = 'openrouter' | 'openai' | 'anthropic';\n\n/**\n * Rate limit error class\n */\nclass RateLimitError extends Error {\n  public retryable = true;\n  public retryAfter?: number;\n  \n  constructor(message: string, retryAfter?: number) {\n    super(message);\n    this.name = 'RateLimitError';\n    this.retryAfter = retryAfter;\n  }\n}\n\n/**\n * OpenRouter API client with enhanced rate limit handling\n */\nclass OpenRouterClient {\n  private apiKey: string;\n  private baseUrl: string = 'https://openrouter.ai/api/v1';\n  private appName: string = 'PDF Lecture Service';\n  private lastRequestTime: number = 0;\n  private minRequestInterval: number;\n  \n  constructor(apiKey: string) {\n    this.apiKey = apiKey;\n    // Configurable minimum interval between requests (default: 500ms for free tier)\n    this.minRequestInterval = parseInt(process.env.OPENROUTER_MIN_REQUEST_INTERVAL_MS || '500', 10);\n  }\n  \n  /**\n   * Rate limit requests to avoid hitting API limits\n   */\n  private async rateLimit(): Promise<void> {\n    const now = Date.now();\n    const timeSinceLastRequest = now - this.lastRequestTime;\n    \n    if (timeSinceLastRequest < this.minRequestInterval) {\n      const waitTime = this.minRequestInterval - timeSinceLastRequest;\n      logger.debug('Rate limiting OpenRouter request', { waitTime });\n      await new Promise(resolve => setTimeout(resolve, waitTime));\n    }\n    \n    this.lastRequestTime = Date.now();\n  }\n  \n  /**\n   * Parse error response and extract rate limit info\n   */\n  private parseErrorResponse(status: number, errorText: string): Error {\n    try {\n      const errorData = JSON.parse(errorText);\n      \n      // Check for rate limit error\n      if (status === 429 || errorData.error?.code === 429) {\n        const message = errorData.error?.message || 'Rate limit exceeded';\n        const retryAfter = errorData.error?.metadata?.headers?.['X-RateLimit-Reset'];\n        \n        logger.warn('OpenRouter rate limit hit', {\n          message,\n          retryAfter,\n          remaining: errorData.error?.metadata?.headers?.['X-RateLimit-Remaining'],\n        });\n        \n        return new RateLimitError(message, retryAfter);\n      }\n      \n      // Other API errors\n      return new Error(`OpenRouter API error: ${status} - ${errorData.error?.message || errorText}`);\n    } catch (e) {\n      // If we can't parse the error, return a generic error\n      return new Error(`OpenRouter API error: ${status} - ${errorText}`);\n    }\n  }\n  \n  async chat(request: LLMRequest): Promise<LLMResponse> {\n    const model = request.model || 'openai/gpt-4-turbo-preview';\n    const startTime = Date.now();\n    \n    logger.info('OpenRouter chat request', {\n      model,\n      messageCount: request.messages.length,\n    });\n    \n    try {\n      // Apply rate limiting\n      await this.rateLimit();\n      \n      const response = await fetch(`${this.baseUrl}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n          'HTTP-Referer': 'https://github.com/pdf-lecture-service',\n          'X-Title': this.appName,\n        },\n        body: JSON.stringify({\n          model,\n          messages: request.messages,\n          temperature: request.temperature ?? 0.7,\n          max_tokens: request.maxTokens ?? 4096,\n          stream: request.stream ?? false,\n        }),\n      });\n      \n      if (!response.ok) {\n        const error = await response.text();\n        logger.error('OpenRouter API error', { status: response.status, error });\n        throw this.parseErrorResponse(response.status, error);\n      }\n      \n      const data: any = await response.json();\n      const duration = Date.now() - startTime;\n      \n      // Log rate limit headers if available\n      const rateLimitHeaders = {\n        limit: response.headers.get('X-RateLimit-Limit'),\n        remaining: response.headers.get('X-RateLimit-Remaining'),\n        reset: response.headers.get('X-RateLimit-Reset'),\n      };\n      \n      if (rateLimitHeaders.remaining) {\n        logger.debug('OpenRouter rate limit status', rateLimitHeaders);\n      }\n      \n      const result = {\n        content: data.choices[0].message.content,\n        model: data.model,\n        usage: {\n          promptTokens: data.usage?.prompt_tokens || 0,\n          completionTokens: data.usage?.completion_tokens || 0,\n          totalTokens: data.usage?.total_tokens || 0,\n        },\n      };\n      \n      // Record metrics for successful call\n      recordLLMCallMetrics({\n        operation: 'chat',\n        model: data.model,\n        provider: 'openrouter',\n        promptTokens: result.usage.promptTokens,\n        completionTokens: result.usage.completionTokens,\n        totalTokens: result.usage.totalTokens,\n        durationMs: duration,\n        success: true,\n      });\n      \n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      // Record metrics for failed call\n      recordLLMCallMetrics({\n        operation: 'chat',\n        model,\n        provider: 'openrouter',\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n        durationMs: duration,\n        success: false,\n        errorType: error instanceof Error ? error.message : 'Unknown error',\n      });\n      \n      throw error;\n    }\n  }\n  \n  async vision(request: VisionRequest): Promise<string> {\n    const model = request.model || 'openai/gpt-4-vision-preview';\n    const startTime = Date.now();\n    \n    logger.info('OpenRouter vision request', { model });\n    \n    try {\n      // Apply rate limiting\n      await this.rateLimit();\n      \n      const response = await fetch(`${this.baseUrl}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n          'HTTP-Referer': 'https://github.com/pdf-lecture-service',\n          'X-Title': this.appName,\n        },\n        body: JSON.stringify({\n          model,\n          messages: [\n            {\n              role: 'user',\n              content: [\n                {\n                  type: 'text',\n                  text: request.prompt,\n                },\n                {\n                  type: 'image_url',\n                  image_url: {\n                    url: request.imageUrl,\n                  },\n                },\n              ],\n            },\n          ],\n          max_tokens: 1024,\n        }),\n      });\n      \n      if (!response.ok) {\n        const error = await response.text();\n        logger.error('OpenRouter vision API error', { status: response.status, error });\n        throw this.parseErrorResponse(response.status, error);\n      }\n      \n      const data: any = await response.json();\n      const duration = Date.now() - startTime;\n      \n      // Log rate limit headers if available\n      const rateLimitHeaders = {\n        limit: response.headers.get('X-RateLimit-Limit'),\n        remaining: response.headers.get('X-RateLimit-Remaining'),\n        reset: response.headers.get('X-RateLimit-Reset'),\n      };\n      \n      if (rateLimitHeaders.remaining) {\n        logger.debug('OpenRouter rate limit status', rateLimitHeaders);\n      }\n      \n      // Record metrics\n      recordLLMCallMetrics({\n        operation: 'vision',\n        model: data.model,\n        provider: 'openrouter',\n        promptTokens: data.usage?.prompt_tokens || 0,\n        completionTokens: data.usage?.completion_tokens || 0,\n        totalTokens: data.usage?.total_tokens || 0,\n        durationMs: duration,\n        success: true,\n      });\n      \n      return data.choices[0].message.content;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      // Record metrics for failed call\n      recordLLMCallMetrics({\n        operation: 'vision',\n        model,\n        provider: 'openrouter',\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n        durationMs: duration,\n        success: false,\n        errorType: error instanceof Error ? error.message : 'Unknown error',\n      });\n      \n      throw error;\n    }\n  }\n}\n\n/**\n * OpenAI API client (direct)\n */\nclass OpenAIClient {\n  private apiKey: string;\n  private baseUrl: string = 'https://api.openai.com/v1';\n  \n  constructor(apiKey: string) {\n    this.apiKey = apiKey;\n  }\n  \n  async chat(request: LLMRequest): Promise<LLMResponse> {\n    const model = request.model || 'gpt-4-turbo-preview';\n    const startTime = Date.now();\n    \n    logger.info('OpenAI chat request', {\n      model,\n      messageCount: request.messages.length,\n    });\n    \n    try {\n      const response = await fetch(`${this.baseUrl}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model,\n          messages: request.messages,\n          temperature: request.temperature ?? 0.7,\n          max_tokens: request.maxTokens ?? 4096,\n        }),\n      });\n      \n      if (!response.ok) {\n        const error = await response.text();\n        logger.error('OpenAI API error', { status: response.status, error });\n        throw new Error(`OpenAI API error: ${response.status} - ${error}`);\n      }\n      \n      const data: any = await response.json();\n      const duration = Date.now() - startTime;\n      \n      const result = {\n        content: data.choices[0].message.content,\n        model: data.model,\n        usage: {\n          promptTokens: data.usage.prompt_tokens,\n          completionTokens: data.usage.completion_tokens,\n          totalTokens: data.usage.total_tokens,\n        },\n      };\n      \n      // Record metrics for successful call\n      recordLLMCallMetrics({\n        operation: 'chat',\n        model: data.model,\n        provider: 'openai',\n        promptTokens: result.usage.promptTokens,\n        completionTokens: result.usage.completionTokens,\n        totalTokens: result.usage.totalTokens,\n        durationMs: duration,\n        success: true,\n      });\n      \n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      // Record metrics for failed call\n      recordLLMCallMetrics({\n        operation: 'chat',\n        model,\n        provider: 'openai',\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n        durationMs: duration,\n        success: false,\n        errorType: error instanceof Error ? error.message : 'Unknown error',\n      });\n      \n      throw error;\n    }\n  }\n  \n  async vision(request: VisionRequest): Promise<string> {\n    const model = request.model || 'gpt-4-vision-preview';\n    \n    logger.info('OpenAI vision request', { model });\n    \n    const response = await fetch(`${this.baseUrl}/chat/completions`, {\n      method: 'POST',\n      headers: {\n        'Authorization': `Bearer ${this.apiKey}`,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model,\n        messages: [\n          {\n            role: 'user',\n            content: [\n              {\n                type: 'text',\n                text: request.prompt,\n              },\n              {\n                type: 'image_url',\n                image_url: {\n                  url: request.imageUrl,\n                },\n              },\n            ],\n          },\n        ],\n        max_tokens: 1024,\n      }),\n    });\n    \n    if (!response.ok) {\n      const error = await response.text();\n      logger.error('OpenAI vision API error', { status: response.status, error });\n      throw new Error(`OpenAI vision API error: ${response.status} - ${error}`);\n    }\n    \n    const data: any = await response.json();\n    return data.choices[0].message.content;\n  }\n}\n\n/**\n * Anthropic API client (direct)\n */\nclass AnthropicClient {\n  private apiKey: string;\n  private baseUrl: string = 'https://api.anthropic.com/v1';\n  \n  constructor(apiKey: string) {\n    this.apiKey = apiKey;\n  }\n  \n  async chat(request: LLMRequest): Promise<LLMResponse> {\n    const model = request.model || 'claude-3-opus-20240229';\n    const startTime = Date.now();\n    \n    logger.info('Anthropic chat request', {\n      model,\n      messageCount: request.messages.length,\n    });\n    \n    try {\n      // Convert messages format for Anthropic\n      const systemMessage = request.messages.find(m => m.role === 'system');\n      const messages = request.messages\n        .filter(m => m.role !== 'system')\n        .map(m => ({\n          role: m.role === 'assistant' ? 'assistant' : 'user',\n          content: m.content,\n        }));\n      \n      const response = await fetch(`${this.baseUrl}/messages`, {\n        method: 'POST',\n        headers: {\n          'x-api-key': this.apiKey,\n          'anthropic-version': '2023-06-01',\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify({\n          model,\n          messages,\n          system: systemMessage?.content,\n          temperature: request.temperature ?? 0.7,\n          max_tokens: request.maxTokens ?? 4096,\n        }),\n      });\n      \n      if (!response.ok) {\n        const error = await response.text();\n        logger.error('Anthropic API error', { status: response.status, error });\n        throw new Error(`Anthropic API error: ${response.status} - ${error}`);\n      }\n      \n      const data: any = await response.json();\n      const duration = Date.now() - startTime;\n      \n      const result = {\n        content: data.content[0].text,\n        model: data.model,\n        usage: {\n          promptTokens: data.usage.input_tokens,\n          completionTokens: data.usage.output_tokens,\n          totalTokens: data.usage.input_tokens + data.usage.output_tokens,\n        },\n      };\n      \n      // Record metrics for successful call\n      recordLLMCallMetrics({\n        operation: 'chat',\n        model: data.model,\n        provider: 'anthropic',\n        promptTokens: result.usage.promptTokens,\n        completionTokens: result.usage.completionTokens,\n        totalTokens: result.usage.totalTokens,\n        durationMs: duration,\n        success: true,\n      });\n      \n      return result;\n    } catch (error) {\n      const duration = Date.now() - startTime;\n      \n      // Record metrics for failed call\n      recordLLMCallMetrics({\n        operation: 'chat',\n        model,\n        provider: 'anthropic',\n        promptTokens: 0,\n        completionTokens: 0,\n        totalTokens: 0,\n        durationMs: duration,\n        success: false,\n        errorType: error instanceof Error ? error.message : 'Unknown error',\n      });\n      \n      throw error;\n    }\n  }\n  \n  async vision(request: VisionRequest): Promise<string> {\n    const model = request.model || 'claude-3-opus-20240229';\n    \n    logger.info('Anthropic vision request', { model });\n    \n    const response = await fetch(`${this.baseUrl}/messages`, {\n      method: 'POST',\n      headers: {\n        'x-api-key': this.apiKey,\n        'anthropic-version': '2023-06-01',\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model,\n        messages: [\n          {\n            role: 'user',\n            content: [\n              {\n                type: 'image',\n                source: {\n                  type: 'url',\n                  url: request.imageUrl,\n                },\n              },\n              {\n                type: 'text',\n                text: request.prompt,\n              },\n            ],\n          },\n        ],\n        max_tokens: 1024,\n      }),\n    });\n    \n    if (!response.ok) {\n      const error = await response.text();\n      logger.error('Anthropic vision API error', { status: response.status, error });\n      throw new Error(`Anthropic vision API error: ${response.status} - ${error}`);\n    }\n    \n    const data: any = await response.json();\n    return data.content[0].text;\n  }\n}\n\n/**\n * LLM Service - Main interface\n */\nexport class LLMService {\n  private provider: LLMProvider;\n  private client: OpenRouterClient | OpenAIClient | AnthropicClient;\n  \n  constructor(provider?: LLMProvider) {\n    this.provider = provider || this.detectProvider();\n    this.client = this.createClient();\n    \n    logger.info('LLM Service initialized', { provider: this.provider });\n  }\n  \n  private detectProvider(): LLMProvider {\n    // Check environment variables to determine provider\n    if (process.env.OPENROUTER_API_KEY) {\n      return 'openrouter';\n    } else if (process.env.OPENAI_API_KEY) {\n      return 'openai';\n    } else if (process.env.ANTHROPIC_API_KEY) {\n      return 'anthropic';\n    }\n    \n    // Default to OpenRouter\n    return 'openrouter';\n  }\n  \n  private createClient(): OpenRouterClient | OpenAIClient | AnthropicClient {\n    switch (this.provider) {\n      case 'openrouter':\n        const openrouterKey = process.env.OPENROUTER_API_KEY || process.env.OPENAI_API_KEY;\n        if (!openrouterKey) {\n          throw new Error('OPENROUTER_API_KEY or OPENAI_API_KEY not set');\n        }\n        return new OpenRouterClient(openrouterKey);\n      \n      case 'openai':\n        const openaiKey = process.env.OPENAI_API_KEY;\n        if (!openaiKey) {\n          throw new Error('OPENAI_API_KEY not set');\n        }\n        return new OpenAIClient(openaiKey);\n      \n      case 'anthropic':\n        const anthropicKey = process.env.ANTHROPIC_API_KEY;\n        if (!anthropicKey) {\n          throw new Error('ANTHROPIC_API_KEY not set');\n        }\n        return new AnthropicClient(anthropicKey);\n      \n      default:\n        throw new Error(`Unknown provider: ${this.provider}`);\n    }\n  }\n  \n  /**\n   * Send a chat completion request with retry logic\n   */\n  async chat(request: LLMRequest): Promise<LLMResponse> {\n    // Configurable retry settings for OpenRouter\n    const maxAttempts = parseInt(process.env.LLM_MAX_RETRY_ATTEMPTS || '5', 10);\n    const initialDelay = parseInt(process.env.LLM_INITIAL_RETRY_DELAY_MS || '2000', 10);\n    const maxDelay = parseInt(process.env.LLM_MAX_RETRY_DELAY_MS || '30000', 10);\n    \n    return withRetry(\n      async () => this.client.chat(request),\n      {\n        maxAttempts,\n        initialDelayMs: initialDelay,\n        maxDelayMs: maxDelay,\n        backoffMultiplier: 2,\n        retryableErrors: ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'ECONNREFUSED', 'RateLimitError'],\n      }\n    );\n  }\n  \n  /**\n   * Analyze an image with vision model with retry logic\n   */\n  async vision(request: VisionRequest): Promise<string> {\n    // More aggressive retry for vision (often hits rate limits)\n    const maxAttempts = parseInt(process.env.LLM_VISION_MAX_RETRY_ATTEMPTS || '5', 10);\n    const initialDelay = parseInt(process.env.LLM_VISION_INITIAL_RETRY_DELAY_MS || '3000', 10);\n    const maxDelay = parseInt(process.env.LLM_VISION_MAX_RETRY_DELAY_MS || '60000', 10);\n    \n    return withRetry(\n      async () => this.client.vision(request),\n      {\n        maxAttempts,\n        initialDelayMs: initialDelay,\n        maxDelayMs: maxDelay,\n        backoffMultiplier: 2,\n        retryableErrors: ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'ECONNREFUSED', 'RateLimitError'],\n      }\n    );\n  }\n  \n  /**\n   * Get the current provider\n   */\n  getProvider(): LLMProvider {\n    return this.provider;\n  }\n}\n\n/**\n * Default LLM service instance\n */\nexport const llmService = new LLMService();\n\n/**\n * Model recommendations for different tasks\n */\nexport const RECOMMENDED_MODELS = {\n  // Content analysis - needs good reasoning\n  analysis: {\n    openrouter: 'openai/gpt-4-turbo-preview',\n    openai: 'gpt-4-turbo-preview',\n    anthropic: 'claude-3-opus-20240229',\n  },\n  \n  // Vision - for figures and diagrams\n  vision: {\n    openrouter: 'openai/gpt-4-vision-preview',\n    openai: 'gpt-4-vision-preview',\n    anthropic: 'claude-3-opus-20240229',\n  },\n  \n  // Segmentation - needs good structure understanding\n  segmentation: {\n    openrouter: 'anthropic/claude-3-opus',\n    openai: 'gpt-4-turbo-preview',\n    anthropic: 'claude-3-opus-20240229',\n  },\n  \n  // Script generation - needs creativity\n  script: {\n    openrouter: 'openai/gpt-4-turbo-preview',\n    openai: 'gpt-4-turbo-preview',\n    anthropic: 'claude-3-opus-20240229',\n  },\n  \n  // Fast/cheap for testing\n  fast: {\n    openrouter: 'openai/gpt-3.5-turbo',\n    openai: 'gpt-3.5-turbo',\n    anthropic: 'claude-3-haiku-20240307',\n  },\n};\n\n/**\n * Get recommended model for a task\n */\nexport function getRecommendedModel(\n  task: keyof typeof RECOMMENDED_MODELS,\n  provider?: LLMProvider\n): string {\n  // Check for environment variable override first\n  const envVarMap: Record<string, string> = {\n    'analysis': process.env.LLM_MODEL_ANALYSIS || '',\n    'vision': process.env.LLM_MODEL_VISION || '',\n    'segmentation': process.env.LLM_MODEL_SEGMENTATION || '',\n    'script': process.env.LLM_MODEL_SCRIPT || '',\n    'fast': process.env.LLM_MODEL_FAST || '',\n  };\n  \n  if (envVarMap[task]) {\n    return envVarMap[task];\n  }\n  \n  // Fall back to recommended models\n  const detectedProvider = provider || (process.env.OPENROUTER_API_KEY ? 'openrouter' : 'openai');\n  return RECOMMENDED_MODELS[task][detectedProvider];\n}\n", "// Retry logic and circuit breaker utilities\n\nimport { logger } from './logger';\nimport { ExternalServiceError, ResourceError } from './errors';\n\nexport interface RetryOptions {\n  maxAttempts?: number;\n  initialDelayMs?: number;\n  maxDelayMs?: number;\n  backoffMultiplier?: number;\n  retryableErrors?: string[];\n}\n\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n  maxAttempts: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 10000,\n  backoffMultiplier: 2,\n  retryableErrors: ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'ECONNREFUSED'],\n};\n\n/**\n * Delays execution for the specified number of milliseconds\n */\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Determines if an error is retryable\n */\nfunction isRetryableError(error: any, retryableErrors: string[]): boolean {\n  if (!error) return false;\n  \n  // Check if error has retryable flag\n  if (typeof error.retryable === 'boolean') {\n    return error.retryable;\n  }\n  \n  // Check error name (for custom error classes)\n  if (error.name && retryableErrors.includes(error.name)) {\n    return true;\n  }\n  \n  // Check error code\n  if (error.code && retryableErrors.includes(error.code)) {\n    return true;\n  }\n  \n  // Check for common transient error messages\n  const message = error.message?.toLowerCase() || '';\n  return (\n    message.includes('timeout') ||\n    message.includes('connection') ||\n    message.includes('network') ||\n    message.includes('temporary') ||\n    message.includes('rate limit') ||\n    message.includes('429') ||\n    message.includes('too many requests')\n  );\n}\n\n/**\n * Executes a function with exponential backoff retry logic\n * @param fn Function to execute\n * @param options Retry configuration options\n * @returns Result of the function\n * @throws Last error if all retries fail\n */\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const opts = { ...DEFAULT_RETRY_OPTIONS, ...options };\n  let lastError: any;\n  let delayMs = opts.initialDelayMs;\n  \n  for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {\n    try {\n      const result = await fn();\n      \n      if (attempt > 1) {\n        logger.info('Operation succeeded after retry', { attempt });\n      }\n      \n      return result;\n    } catch (error) {\n      lastError = error;\n      \n      const isRetryable = isRetryableError(error, opts.retryableErrors);\n      const isLastAttempt = attempt === opts.maxAttempts;\n      \n      logger.warn('Operation failed', {\n        attempt,\n        maxAttempts: opts.maxAttempts,\n        isRetryable,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      \n      if (!isRetryable || isLastAttempt) {\n        throw error;\n      }\n      \n      // Wait before retrying\n      logger.info('Retrying operation', { attempt, delayMs });\n      await delay(delayMs);\n      \n      // Increase delay for next attempt (exponential backoff)\n      delayMs = Math.min(delayMs * opts.backoffMultiplier, opts.maxDelayMs);\n    }\n  }\n  \n  throw lastError;\n}\n\n// ============================================================================\n// Circuit Breaker\n// ============================================================================\n\nexport enum CircuitState {\n  CLOSED = 'CLOSED',     // Normal operation\n  OPEN = 'OPEN',         // Failing, reject requests\n  HALF_OPEN = 'HALF_OPEN', // Testing if service recovered\n}\n\nexport interface CircuitBreakerOptions {\n  failureThreshold?: number;\n  successThreshold?: number;\n  timeout?: number;\n  resetTimeoutMs?: number;\n}\n\nconst DEFAULT_CIRCUIT_OPTIONS: Required<CircuitBreakerOptions> = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeout: 30000,\n  resetTimeoutMs: 60000,\n};\n\n/**\n * Circuit breaker implementation for external service calls\n */\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failureCount = 0;\n  private successCount = 0;\n  private nextAttemptTime = 0;\n  private readonly options: Required<CircuitBreakerOptions>;\n  \n  constructor(\n    private readonly serviceName: string,\n    options: CircuitBreakerOptions = {}\n  ) {\n    this.options = { ...DEFAULT_CIRCUIT_OPTIONS, ...options };\n  }\n  \n  /**\n   * Executes a function with circuit breaker protection\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextAttemptTime) {\n        logger.warn('Circuit breaker is OPEN, rejecting request', {\n          service: this.serviceName,\n          nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n        });\n        throw new ExternalServiceError(\n          `Service ${this.serviceName} is currently unavailable (circuit breaker OPEN)`,\n          this.serviceName\n        );\n      }\n      \n      // Try to recover\n      this.state = CircuitState.HALF_OPEN;\n      this.successCount = 0;\n      logger.info('Circuit breaker entering HALF_OPEN state', {\n        service: this.serviceName,\n      });\n    }\n    \n    try {\n      // Execute with timeout\n      const result = await this.executeWithTimeout(fn);\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  /**\n   * Executes function with timeout\n   */\n  private async executeWithTimeout<T>(fn: () => Promise<T>): Promise<T> {\n    return Promise.race([\n      fn(),\n      new Promise<T>((_, reject) =>\n        setTimeout(\n          () => reject(new ResourceError('Operation timeout', { timeout: this.options.timeout })),\n          this.options.timeout\n        )\n      ),\n    ]);\n  }\n  \n  /**\n   * Handles successful execution\n   */\n  private onSuccess(): void {\n    this.failureCount = 0;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      this.successCount++;\n      \n      if (this.successCount >= this.options.successThreshold) {\n        this.state = CircuitState.CLOSED;\n        this.successCount = 0;\n        logger.info('Circuit breaker closed', { service: this.serviceName });\n      }\n    }\n  }\n  \n  /**\n   * Handles failed execution\n   */\n  private onFailure(): void {\n    this.failureCount++;\n    this.successCount = 0;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      this.state = CircuitState.OPEN;\n      this.nextAttemptTime = Date.now() + this.options.resetTimeoutMs;\n      logger.warn('Circuit breaker opened from HALF_OPEN', {\n        service: this.serviceName,\n        nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n      });\n    } else if (this.failureCount >= this.options.failureThreshold) {\n      this.state = CircuitState.OPEN;\n      this.nextAttemptTime = Date.now() + this.options.resetTimeoutMs;\n      logger.warn('Circuit breaker opened', {\n        service: this.serviceName,\n        failureCount: this.failureCount,\n        nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n      });\n    }\n  }\n  \n  /**\n   * Gets current circuit breaker state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n  \n  /**\n   * Resets circuit breaker to closed state\n   */\n  reset(): void {\n    this.state = CircuitState.CLOSED;\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.nextAttemptTime = 0;\n    logger.info('Circuit breaker manually reset', { service: this.serviceName });\n  }\n}\n\n// ============================================================================\n// Global Circuit Breakers\n// ============================================================================\n\nconst circuitBreakers = new Map<string, CircuitBreaker>();\n\n/**\n * Gets or creates a circuit breaker for a service\n */\nexport function getCircuitBreaker(\n  serviceName: string,\n  options?: CircuitBreakerOptions\n): CircuitBreaker {\n  if (!circuitBreakers.has(serviceName)) {\n    circuitBreakers.set(serviceName, new CircuitBreaker(serviceName, options));\n  }\n  return circuitBreakers.get(serviceName)!;\n}\n\n/**\n * Executes a function with both retry logic and circuit breaker protection\n */\nexport async function withRetryAndCircuitBreaker<T>(\n  serviceName: string,\n  fn: () => Promise<T>,\n  retryOptions?: RetryOptions,\n  circuitOptions?: CircuitBreakerOptions\n): Promise<T> {\n  const circuitBreaker = getCircuitBreaker(serviceName, circuitOptions);\n  \n  return withRetry(\n    () => circuitBreaker.execute(fn),\n    retryOptions\n  );\n}\n", "// LLM-specific metrics tracking for monitoring API usage, costs, and performance\n\nimport { logger } from './logger';\nimport { metrics } from './metrics';\n\n/**\n * Model pricing per 1M tokens (approximate, as of 2024-2025)\n * These are rough estimates and should be updated based on actual provider pricing\n */\nconst MODEL_PRICING = {\n  // OpenAI models\n  'gpt-4-turbo-preview': { input: 10.0, output: 30.0 },\n  'gpt-4-vision-preview': { input: 10.0, output: 30.0 },\n  'gpt-3.5-turbo': { input: 0.5, output: 1.5 },\n  \n  // Anthropic models\n  'claude-3-opus-20240229': { input: 15.0, output: 75.0 },\n  'claude-3-sonnet-20240229': { input: 3.0, output: 15.0 },\n  'claude-3-haiku-20240307': { input: 0.25, output: 1.25 },\n  \n  // OpenRouter models (using base model pricing)\n  'openai/gpt-4-turbo-preview': { input: 10.0, output: 30.0 },\n  'openai/gpt-4-vision-preview': { input: 10.0, output: 30.0 },\n  'openai/gpt-3.5-turbo': { input: 0.5, output: 1.5 },\n  'anthropic/claude-3-opus': { input: 15.0, output: 75.0 },\n  'anthropic/claude-3-sonnet': { input: 3.0, output: 15.0 },\n  'anthropic/claude-3-5-sonnet': { input: 3.0, output: 15.0 },\n  'anthropic/claude-3-haiku': { input: 0.25, output: 1.25 },\n  \n  // FREE OpenRouter models (cost = $0)\n  'google/gemini-2.0-flash-exp:free': { input: 0.0, output: 0.0 },\n  'google/gemini-pro-vision': { input: 0.0, output: 0.0 },\n  'x-ai/grok-4.1-fast:free': { input: 0.0, output: 0.0 },\n  'meta-llama/llama-3.3-70b-instruct:free': { input: 0.0, output: 0.0 },\n  'meta-llama/llama-3.1-405b-instruct:free': { input: 0.0, output: 0.0 },\n  'qwen/qwen-2.5-72b-instruct:free': { input: 0.0, output: 0.0 },\n  'mistralai/mistral-7b-instruct:free': { input: 0.0, output: 0.0 },\n  \n  // Default fallback pricing\n  'default': { input: 5.0, output: 15.0 },\n};\n\n/**\n * Calculate cost for an LLM API call based on token usage\n */\nexport function calculateLLMCost(\n  model: string,\n  promptTokens: number,\n  completionTokens: number\n): number {\n  // Get pricing for the model, or use default\n  const pricing = MODEL_PRICING[model as keyof typeof MODEL_PRICING] || MODEL_PRICING.default;\n  \n  // Calculate cost (pricing is per 1M tokens, so divide by 1,000,000)\n  const inputCost = (promptTokens / 1_000_000) * pricing.input;\n  const outputCost = (completionTokens / 1_000_000) * pricing.output;\n  \n  return inputCost + outputCost;\n}\n\n/**\n * Track metrics for an LLM API call\n */\nexport interface LLMCallMetrics {\n  operation: string; // e.g., 'segmentation', 'script_generation', 'vision_analysis'\n  model: string;\n  provider: string;\n  promptTokens: number;\n  completionTokens: number;\n  totalTokens: number;\n  durationMs: number;\n  success: boolean;\n  errorType?: string;\n  jobId?: string;\n}\n\n/**\n * Record metrics for an LLM API call\n */\nexport function recordLLMCallMetrics(callMetrics: LLMCallMetrics): void {\n  const dimensions = {\n    operation: callMetrics.operation,\n    model: callMetrics.model,\n    provider: callMetrics.provider,\n    success: callMetrics.success.toString(),\n  };\n  \n  // Record success/failure count\n  if (callMetrics.success) {\n    metrics.recordCount('LLMCallSuccess', 1, dimensions);\n  } else {\n    metrics.recordCount('LLMCallFailure', 1, {\n      ...dimensions,\n      errorType: callMetrics.errorType || 'Unknown',\n    });\n  }\n  \n  // Record response time\n  metrics.recordDuration('LLMCallDuration', callMetrics.durationMs, dimensions);\n  \n  // Record token usage\n  metrics.recordCount('LLMPromptTokens', callMetrics.promptTokens, dimensions);\n  metrics.recordCount('LLMCompletionTokens', callMetrics.completionTokens, dimensions);\n  metrics.recordCount('LLMTotalTokens', callMetrics.totalTokens, dimensions);\n  \n  // Calculate and record cost\n  const cost = calculateLLMCost(\n    callMetrics.model,\n    callMetrics.promptTokens,\n    callMetrics.completionTokens\n  );\n  \n  // Record cost in cents (multiply by 100 to avoid floating point issues)\n  metrics.recordCount('LLMCallCostCents', Math.round(cost * 100), dimensions);\n  \n  // Log detailed metrics\n  logger.info('LLM call metrics recorded', {\n    ...callMetrics,\n    estimatedCost: cost,\n    costFormatted: `$${cost.toFixed(4)}`,\n  });\n}\n\n/**\n * Helper class to track LLM metrics for a specific job\n */\nexport class JobLLMMetrics {\n  private jobId: string;\n  private totalCost: number = 0;\n  private totalTokens: number = 0;\n  private totalCalls: number = 0;\n  private callsByOperation: Map<string, number> = new Map();\n  \n  constructor(jobId: string) {\n    this.jobId = jobId;\n  }\n  \n  /**\n   * Record an LLM call for this job\n   */\n  recordCall(callMetrics: Omit<LLMCallMetrics, 'jobId'>): void {\n    // Add jobId to metrics\n    const fullMetrics: LLMCallMetrics = {\n      ...callMetrics,\n      jobId: this.jobId,\n    };\n    \n    // Record global metrics\n    recordLLMCallMetrics(fullMetrics);\n    \n    // Update job-specific tracking\n    if (callMetrics.success) {\n      this.totalCalls++;\n      this.totalTokens += callMetrics.totalTokens;\n      \n      const cost = calculateLLMCost(\n        callMetrics.model,\n        callMetrics.promptTokens,\n        callMetrics.completionTokens\n      );\n      this.totalCost += cost;\n      \n      // Track calls by operation\n      const currentCount = this.callsByOperation.get(callMetrics.operation) || 0;\n      this.callsByOperation.set(callMetrics.operation, currentCount + 1);\n    }\n  }\n  \n  /**\n   * Get summary of LLM usage for this job\n   */\n  getSummary(): {\n    jobId: string;\n    totalCalls: number;\n    totalTokens: number;\n    totalCost: number;\n    callsByOperation: Record<string, number>;\n  } {\n    return {\n      jobId: this.jobId,\n      totalCalls: this.totalCalls,\n      totalTokens: this.totalTokens,\n      totalCost: this.totalCost,\n      callsByOperation: Object.fromEntries(this.callsByOperation),\n    };\n  }\n  \n  /**\n   * Log final summary for this job\n   */\n  logSummary(): void {\n    const summary = this.getSummary();\n    \n    logger.info('Job LLM metrics summary', {\n      ...summary,\n      costFormatted: `$${summary.totalCost.toFixed(4)}`,\n    });\n    \n    // Record job-level metrics\n    metrics.recordCount('JobLLMCalls', summary.totalCalls, { jobId: this.jobId });\n    metrics.recordCount('JobLLMTokens', summary.totalTokens, { jobId: this.jobId });\n    metrics.recordCount('JobLLMCostCents', Math.round(summary.totalCost * 100), { jobId: this.jobId });\n  }\n}\n\n/**\n * Calculate success rate for LLM calls\n */\nexport function calculateLLMSuccessRate(\n  successCount: number,\n  failureCount: number\n): number {\n  const total = successCount + failureCount;\n  if (total === 0) return 100;\n  return (successCount / total) * 100;\n}\n", "// Metrics collection utility for tracking request counts, error rates, processing times, and storage usage\n\nimport { logger } from './logger';\n\nexport enum MetricType {\n  COUNT = 'Count',\n  DURATION = 'Duration',\n  SIZE = 'Size',\n  RATE = 'Rate',\n}\n\nexport enum MetricUnit {\n  COUNT = 'Count',\n  MILLISECONDS = 'Milliseconds',\n  SECONDS = 'Seconds',\n  BYTES = 'Bytes',\n  MEGABYTES = 'Megabytes',\n  PERCENT = 'Percent',\n}\n\ninterface MetricData {\n  name: string;\n  value: number;\n  unit: MetricUnit;\n  timestamp: Date;\n  dimensions?: Record<string, string>;\n}\n\ninterface TimerHandle {\n  name: string;\n  startTime: number;\n  dimensions?: Record<string, string>;\n}\n\nclass MetricsCollector {\n  private metrics: MetricData[] = [];\n  private activeTimers: Map<string, TimerHandle> = new Map();\n\n  /**\n   * Record a count metric (e.g., request count, error count)\n   */\n  recordCount(name: string, value: number = 1, dimensions?: Record<string, string>) {\n    this.recordMetric(name, value, MetricUnit.COUNT, dimensions);\n  }\n\n  /**\n   * Record a duration metric in milliseconds\n   */\n  recordDuration(name: string, durationMs: number, dimensions?: Record<string, string>) {\n    this.recordMetric(name, durationMs, MetricUnit.MILLISECONDS, dimensions);\n  }\n\n  /**\n   * Record a size metric in bytes\n   */\n  recordSize(name: string, sizeBytes: number, dimensions?: Record<string, string>) {\n    this.recordMetric(name, sizeBytes, MetricUnit.BYTES, dimensions);\n  }\n\n  /**\n   * Record a rate metric (e.g., error rate as percentage)\n   */\n  recordRate(name: string, rate: number, dimensions?: Record<string, string>) {\n    this.recordMetric(name, rate, MetricUnit.PERCENT, dimensions);\n  }\n\n  /**\n   * Start a timer for measuring duration\n   */\n  startTimer(name: string, dimensions?: Record<string, string>): string {\n    const timerId = `${name}-${Date.now()}-${Math.random()}`;\n    this.activeTimers.set(timerId, {\n      name,\n      startTime: Date.now(),\n      dimensions,\n    });\n    return timerId;\n  }\n\n  /**\n   * Stop a timer and record the duration\n   */\n  stopTimer(timerId: string): number | null {\n    const timer = this.activeTimers.get(timerId);\n    if (!timer) {\n      logger.warn('Attempted to stop non-existent timer', { timerId });\n      return null;\n    }\n\n    const duration = Date.now() - timer.startTime;\n    this.recordDuration(timer.name, duration, timer.dimensions);\n    this.activeTimers.delete(timerId);\n    return duration;\n  }\n\n  /**\n   * Record a generic metric\n   */\n  private recordMetric(\n    name: string,\n    value: number,\n    unit: MetricUnit,\n    dimensions?: Record<string, string>\n  ) {\n    const metric: MetricData = {\n      name,\n      value,\n      unit,\n      timestamp: new Date(),\n      dimensions,\n    };\n\n    this.metrics.push(metric);\n\n    // Log the metric for CloudWatch ingestion\n    logger.info('Metric recorded', {\n      metric: {\n        name: metric.name,\n        value: metric.value,\n        unit: metric.unit,\n        dimensions: metric.dimensions,\n      },\n    });\n\n    // In production, this would also publish to CloudWatch\n    if (process.env.NODE_ENV === 'production') {\n      this.publishToCloudWatch(metric);\n    }\n  }\n\n  /**\n   * Publish metric to CloudWatch\n   */\n  private async publishToCloudWatch(metric: MetricData) {\n    // Dynamically import to avoid circular dependencies\n    const { publishMetric } = await import('./cloudwatch');\n    \n    await publishMetric({\n      name: metric.name,\n      value: metric.value,\n      unit: metric.unit,\n      dimensions: metric.dimensions,\n      timestamp: metric.timestamp,\n    });\n  }\n\n  /**\n   * Get all recorded metrics (useful for testing)\n   */\n  getMetrics(): MetricData[] {\n    return [...this.metrics];\n  }\n\n  /**\n   * Clear all recorded metrics\n   */\n  clearMetrics() {\n    this.metrics = [];\n  }\n}\n\n// Singleton instance\nexport const metrics = new MetricsCollector();\n\n/**\n * Decorator for measuring function execution time\n */\nexport function measureExecutionTime(metricName: string, dimensions?: Record<string, string>) {\n  return function (\n    _target: any,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const timerId = metrics.startTimer(metricName, dimensions);\n      try {\n        const result = await originalMethod.apply(this, args);\n        metrics.stopTimer(timerId);\n        return result;\n      } catch (error) {\n        metrics.stopTimer(timerId);\n        throw error;\n      }\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * Helper to track request metrics\n */\nexport class RequestMetrics {\n  private requestCount = 0;\n  private errorCount = 0;\n  private successCount = 0;\n\n  incrementRequest(endpoint: string) {\n    this.requestCount++;\n    metrics.recordCount('RequestCount', 1, { endpoint });\n  }\n\n  incrementError(endpoint: string, errorType?: string) {\n    this.errorCount++;\n    metrics.recordCount('ErrorCount', 1, { endpoint, errorType: errorType || 'Unknown' });\n  }\n\n  incrementSuccess(endpoint: string) {\n    this.successCount++;\n    metrics.recordCount('SuccessCount', 1, { endpoint });\n  }\n\n  getErrorRate(): number {\n    if (this.requestCount === 0) return 0;\n    return (this.errorCount / this.requestCount) * 100;\n  }\n\n  recordErrorRate(endpoint: string) {\n    const rate = this.getErrorRate();\n    metrics.recordRate('ErrorRate', rate, { endpoint });\n  }\n}\n\n/**\n * Helper to track processing stage metrics\n */\nexport class StageMetrics {\n  recordStageStart(stage: string, jobId: string) {\n    metrics.recordCount('StageStarted', 1, { stage, jobId });\n  }\n\n  recordStageComplete(stage: string, jobId: string, durationMs: number) {\n    metrics.recordCount('StageCompleted', 1, { stage, jobId });\n    metrics.recordDuration('StageDuration', durationMs, { stage, jobId });\n  }\n\n  recordStageFailed(stage: string, jobId: string, errorType: string) {\n    metrics.recordCount('StageFailed', 1, { stage, jobId, errorType });\n  }\n}\n\n/**\n * Helper to track external API metrics\n */\nexport class ExternalAPIMetrics {\n  recordAPICall(apiName: string, operation: string) {\n    metrics.recordCount('ExternalAPICall', 1, { apiName, operation });\n  }\n\n  recordAPILatency(apiName: string, operation: string, latencyMs: number) {\n    metrics.recordDuration('ExternalAPILatency', latencyMs, { apiName, operation });\n  }\n\n  recordAPIError(apiName: string, operation: string, errorType: string) {\n    metrics.recordCount('ExternalAPIError', 1, { apiName, operation, errorType });\n  }\n}\n\n/**\n * Helper to track storage metrics\n */\nexport class StorageMetrics {\n  recordStorageWrite(storageType: string, sizeBytes: number) {\n    metrics.recordCount('StorageWrite', 1, { storageType });\n    metrics.recordSize('StorageWriteSize', sizeBytes, { storageType });\n  }\n\n  recordStorageRead(storageType: string, sizeBytes: number) {\n    metrics.recordCount('StorageRead', 1, { storageType });\n    metrics.recordSize('StorageReadSize', sizeBytes, { storageType });\n  }\n\n  recordStorageUsage(storageType: string, totalBytes: number) {\n    metrics.recordSize('StorageUsage', totalBytes, { storageType });\n  }\n}\n", "// EventBridge service for asynchronous function triggering\nimport { EventBridge } from 'aws-sdk';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\n\nconst eventBridge = new EventBridge({\n  endpoint: config.isLocal ? 'http://localhost:4566' : undefined,\n  region: config.awsRegion,\n});\n\nexport interface PipelineEvent {\n  jobId: string;\n  agentId?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Publish an event to EventBridge to trigger the next stage in the pipeline\n */\nexport async function publishPipelineEvent(\n  detailType: string,\n  detail: PipelineEvent\n): Promise<void> {\n  const eventBusName = config.eventBusName || 'pdf-lecture-service-events';\n  \n  try {\n    logger.info('Publishing pipeline event', { detailType, jobId: detail.jobId });\n    \n    const params: EventBridge.PutEventsRequest = {\n      Entries: [\n        {\n          Source: 'pdf-lecture-service',\n          DetailType: detailType,\n          Detail: JSON.stringify(detail),\n          EventBusName: eventBusName,\n        },\n      ],\n    };\n    \n    const result = await eventBridge.putEvents(params).promise();\n    \n    if (result.FailedEntryCount && result.FailedEntryCount > 0) {\n      const errors = result.Entries?.filter(e => e.ErrorCode).map(e => ({\n        code: e.ErrorCode,\n        message: e.ErrorMessage,\n      }));\n      throw new Error(`Failed to publish event: ${JSON.stringify(errors)}`);\n    }\n    \n    logger.info('Pipeline event published successfully', { detailType, jobId: detail.jobId });\n  } catch (error) {\n    logger.error('Failed to publish pipeline event', { error, detailType, jobId: detail.jobId });\n    throw error;\n  }\n}\n\n/**\n * Trigger the content analysis stage\n */\nexport async function triggerAnalysis(jobId: string): Promise<void> {\n  await publishPipelineEvent('JobCreated', { jobId });\n}\n\n/**\n * Trigger the content segmentation stage\n */\nexport async function triggerSegmentation(jobId: string): Promise<void> {\n  await publishPipelineEvent('AnalysisCompleted', { jobId });\n}\n\n/**\n * Trigger the script generation stage\n */\nexport async function triggerScriptGeneration(jobId: string, agentId?: string): Promise<void> {\n  await publishPipelineEvent('SegmentationCompleted', { jobId, agentId });\n}\n\n/**\n * Trigger the audio synthesis stage\n */\nexport async function triggerAudioSynthesis(jobId: string): Promise<void> {\n  await publishPipelineEvent('ScriptGenerationCompleted', { jobId });\n}\n\n/**\n * Publish a job completion event\n */\nexport async function publishJobCompleted(jobId: string): Promise<void> {\n  await publishPipelineEvent('JobCompleted', { jobId });\n}\n\n/**\n * Publish a job failure event\n */\nexport async function publishJobFailed(jobId: string, error: string): Promise<void> {\n  await publishPipelineEvent('JobFailed', { \n    jobId, \n    metadata: { error } \n  });\n}\n"],
  "mappings": "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",
  "names": ["SENSITIVE_PATTERNS", "Logger", "logger", "init_logger", "__esmMin", "_Logger", "envLogLevel", "id", "name", "data", "item", "redacted", "key", "value", "pattern", "level", "levels", "currentLevelIndex", "minLevelIndex", "message", "metadata", "entry", "correlationId", "childLogger", "require_package", "__commonJSMin", "exports", "module", "require_main", "__commonJSMin", "exports", "module", "fs", "path", "os", "crypto", "packageJson", "version", "LINE", "parse", "src", "obj", "lines", "match", "key", "value", "maybeQuote", "_parseVault", "options", "vaultPath", "_vaultPath", "result", "DotenvModule", "err", "keys", "_dotenvKey", "length", "decrypted", "attrs", "_instructions", "error", "_warn", "message", "_debug", "_log", "dotenvKey", "uri", "environment", "environmentKey", "ciphertext", "possibleVaultPath", "filepath", "_resolveHome", "envPath", "_configVault", "debug", "quiet", "parsed", "processEnv", "configDotenv", "dotenvPath", "encoding", "optionPaths", "lastError", "parsedAll", "e", "keysCount", "shortPaths", "filePath", "relative", "config", "decrypt", "encrypted", "keyStr", "nonce", "authTag", "aesgcm", "isRange", "invalidKeyLength", "decryptionFailed", "populate", "override", "import_dotenv", "config", "init_config", "__esmMin", "dotenv", "cloudwatch_exports", "__export", "createAlarm", "createStandardAlarmsForFunction", "publishMetric", "publishMetrics", "metric", "config", "logger", "dimensions", "name", "value", "cloudwatch", "error", "metrics", "metricData", "batchSize", "i", "batch", "params", "functionName", "timeoutMs", "AWS", "init_cloudwatch", "__esmMin", "init_config", "init_logger", "max_default", "init_max", "__esmMin", "nil_default", "init_nil", "__esmMin", "regex_default", "init_regex", "__esmMin", "validate", "uuid", "regex_default", "validate_default", "init_validate", "__esmMin", "init_regex", "parse", "uuid", "validate_default", "v", "parse_default", "init_parse", "__esmMin", "init_validate", "unsafeStringify", "arr", "offset", "byteToHex", "stringify", "uuid", "validate_default", "stringify_default", "init_stringify", "__esmMin", "init_validate", "i", "rng", "poolPtr", "rnds8Pool", "import_node_crypto", "init_rng", "__esmMin", "v1", "options", "buf", "offset", "bytes", "isV6", "optionsKeys", "v1Bytes", "rng", "now", "rnds", "updateV1State", "_state", "unsafeStringify", "state", "msecs", "nsecs", "clockseq", "node", "tl", "tmh", "n", "v1_default", "init_v1", "__esmMin", "init_rng", "init_stringify", "v1ToV6", "uuid", "v1Bytes", "parse_default", "v6Bytes", "_v1ToV6", "unsafeStringify", "init_v1ToV6", "__esmMin", "init_parse", "init_stringify", "md5", "bytes", "import_node_crypto", "md5_default", "init_md5", "__esmMin", "stringToBytes", "str", "bytes", "i", "v35", "version", "hash", "value", "namespace", "buf", "offset", "valueBytes", "namespaceBytes", "parse_default", "unsafeStringify", "DNS", "URL", "init_v35", "__esmMin", "init_parse", "init_stringify", "v3", "value", "namespace", "buf", "offset", "v35", "md5_default", "v3_default", "init_v3", "__esmMin", "init_md5", "init_v35", "DNS", "URL", "import_node_crypto", "native_default", "init_native", "__esmMin", "_v4", "options", "buf", "offset", "rnds", "rng", "i", "unsafeStringify", "v4", "native_default", "v4_default", "init_v4", "__esmMin", "init_native", "init_rng", "init_stringify", "sha1", "bytes", "import_node_crypto", "sha1_default", "init_sha1", "__esmMin", "v5", "value", "namespace", "buf", "offset", "v35", "sha1_default", "v5_default", "init_v5", "__esmMin", "init_sha1", "init_v35", "DNS", "URL", "v6", "options", "buf", "offset", "bytes", "v1_default", "v1ToV6", "i", "unsafeStringify", "v6_default", "init_v6", "__esmMin", "init_stringify", "init_v1", "init_v1ToV6", "v6ToV1", "uuid", "v6Bytes", "parse_default", "v1Bytes", "_v6ToV1", "unsafeStringify", "init_v6ToV1", "__esmMin", "init_parse", "init_stringify", "v7", "options", "buf", "offset", "bytes", "v7Bytes", "rng", "now", "rnds", "updateV7State", "_state", "unsafeStringify", "state", "msecs", "seq", "v7_default", "init_v7", "__esmMin", "init_rng", "init_stringify", "version", "uuid", "validate_default", "version_default", "init_version", "__esmMin", "init_validate", "dist_node_exports", "__export", "max_default", "nil_default", "parse_default", "stringify_default", "v1_default", "v1ToV6", "v3_default", "v4_default", "v5_default", "v6_default", "v6ToV1", "v7_default", "validate_default", "version_default", "init_dist_node", "__esmMin", "init_max", "init_nil", "init_parse", "init_stringify", "init_v1", "init_v1ToV6", "init_v3", "init_v4", "init_v5", "init_v6", "init_v6ToV1", "init_v7", "init_validate", "init_version", "dynamodb_exports", "__export", "createAgent", "createContent", "createJob", "createTablesIfNotExist", "deleteAgent", "deleteContent", "deleteJob", "getAgent", "getContent", "getJob", "listAgents", "listJobs", "updateAgent", "updateContent", "updateJob", "handleDynamoDBError", "error", "operation", "logger", "jobToRecord", "job", "recordToJob", "record", "stage", "dynamoDB", "config", "jobId", "result", "updates", "current", "updated", "item", "agentToRecord", "agent", "recordToAgent", "a", "id", "dynamoDBClient", "AWS", "dynamoDBConfig", "tables", "tableConfig", "createError", "import_aws_sdk", "init_dynamodb", "__esmMin", "init_config", "init_logger", "segmenter_exports", "__export", "segmenterHandler", "__toCommonJS", "init_logger", "init_config", "init_logger", "init_logger", "DEFAULT_RETRY_OPTIONS", "delay", "ms", "resolve", "isRetryableError", "error", "retryableErrors", "message", "withRetry", "fn", "options", "opts", "lastError", "delayMs", "attempt", "result", "logger", "isRetryable", "isLastAttempt", "init_logger", "init_logger", "MetricsCollector", "name", "value", "dimensions", "durationMs", "sizeBytes", "rate", "timerId", "timer", "logger", "duration", "unit", "metric", "publishMetric", "metrics", "MODEL_PRICING", "calculateLLMCost", "model", "promptTokens", "completionTokens", "pricing", "inputCost", "outputCost", "recordLLMCallMetrics", "callMetrics", "dimensions", "metrics", "cost", "logger", "RateLimitError", "message", "retryAfter", "OpenRouterClient", "apiKey", "timeSinceLastRequest", "waitTime", "logger", "resolve", "status", "errorText", "errorData", "request", "model", "startTime", "response", "error", "data", "duration", "rateLimitHeaders", "result", "recordLLMCallMetrics", "OpenAIClient", "AnthropicClient", "systemMessage", "m", "messages", "LLMService", "provider", "openrouterKey", "openaiKey", "anthropicKey", "maxAttempts", "initialDelay", "maxDelay", "withRetry", "llmService", "RECOMMENDED_MODELS", "getRecommendedModel", "task", "envVarMap", "detectedProvider", "uuidv4", "createSegmentationPrompt", "extractedContent", "buildContentSummary", "parts", "totalElements", "complexity", "figure", "caption", "table", "headerSummary", "formula", "latexPreview", "citationsToShow", "citation", "authorStr", "page", "pageElements", "pageFigures", "f", "pageTables", "t", "pageFormulas", "maxTextLength", "truncated", "lastPeriod", "text", "buildDependencyGraph", "segments", "graph", "i", "segment", "index", "prereqIndex", "dependents", "hasCycle", "nodeCount", "visited", "recursionStack", "dfs", "node", "neighbors", "neighbor", "topologicalSort", "logger", "_", "inDegree", "queue", "sorted", "dependent", "newInDegree", "parseSegmentationResponse", "llmResponse", "sortedIndices", "originalIndex", "newOrder", "llmSegment", "contentBlocks", "startPage", "endPage", "pageNum", "p", "figureId", "tableId", "formulaId", "citationId", "c", "mappedPrerequisites", "oldIndex", "newIndex", "idx", "mockSegmentationLLM", "_prompt", "resolve", "callSegmentationLLM", "prompt", "correlationId", "config", "startTime", "requestId", "model", "getRecommendedModel", "llmService", "response", "apiCallDuration", "recordLLMCallMetrics", "segmentationData", "parseError", "errorMessage", "responsePreview", "responseSuffix", "j", "range", "idArrays", "name", "value", "k", "totalDuration", "error", "errorType", "categorizeSegmentationError", "errorStack", "segmentContent", "jobId", "getContent", "updateContent", "contentRecord", "dbError", "promptError", "llmError", "segmentedContent", "init_dynamodb", "import_aws_sdk", "init_config", "init_logger", "eventBridge", "config", "publishPipelineEvent", "detailType", "detail", "eventBusName", "logger", "params", "result", "errors", "e", "error", "triggerScriptGeneration", "jobId", "agentId", "publishPipelineEvent", "init_logger", "init_config", "segmenterHandler", "event", "logger", "jobId", "job", "getJob", "updateJob", "stage", "segmentedContent", "segmentContent", "config", "triggerScriptGeneration", "error", "errorResponse", "updateError"]
}
