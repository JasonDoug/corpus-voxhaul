{
  "version": 3,
  "sources": ["../../../../../../../tmp/tmpmcpa065k/node_modules/dotenv/package.json", "../../../../../../../tmp/tmpmcpa065k/node_modules/dotenv/lib/main.js", "../../../../../../../tmp/tmpmcpa065k/src/functions/status.ts", "../../../../../../../tmp/tmpmcpa065k/src/services/dynamodb.ts", "../../../../../../../tmp/tmpmcpa065k/src/utils/config.ts", "../../../../../../../tmp/tmpmcpa065k/src/utils/logger.ts", "../../../../../../../tmp/tmpmcpa065k/src/services/status.ts"],
  "sourcesContent": ["{\n  \"name\": \"dotenv\",\n  \"version\": \"16.6.1\",\n  \"description\": \"Loads environment variables from .env file\",\n  \"main\": \"lib/main.js\",\n  \"types\": \"lib/main.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./lib/main.d.ts\",\n      \"require\": \"./lib/main.js\",\n      \"default\": \"./lib/main.js\"\n    },\n    \"./config\": \"./config.js\",\n    \"./config.js\": \"./config.js\",\n    \"./lib/env-options\": \"./lib/env-options.js\",\n    \"./lib/env-options.js\": \"./lib/env-options.js\",\n    \"./lib/cli-options\": \"./lib/cli-options.js\",\n    \"./lib/cli-options.js\": \"./lib/cli-options.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"dts-check\": \"tsc --project tests/types/tsconfig.json\",\n    \"lint\": \"standard\",\n    \"pretest\": \"npm run lint && npm run dts-check\",\n    \"test\": \"tap run --allow-empty-coverage --disable-coverage --timeout=60000\",\n    \"test:coverage\": \"tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\n    \"prerelease\": \"npm test\",\n    \"release\": \"standard-version\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/motdotla/dotenv.git\"\n  },\n  \"homepage\": \"https://github.com/motdotla/dotenv#readme\",\n  \"funding\": \"https://dotenvx.com\",\n  \"keywords\": [\n    \"dotenv\",\n    \"env\",\n    \".env\",\n    \"environment\",\n    \"variables\",\n    \"config\",\n    \"settings\"\n  ],\n  \"readmeFilename\": \"README.md\",\n  \"license\": \"BSD-2-Clause\",\n  \"devDependencies\": {\n    \"@types/node\": \"^18.11.3\",\n    \"decache\": \"^4.6.2\",\n    \"sinon\": \"^14.0.1\",\n    \"standard\": \"^17.0.0\",\n    \"standard-version\": \"^9.5.0\",\n    \"tap\": \"^19.2.0\",\n    \"typescript\": \"^4.8.4\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"browser\": {\n    \"fs\": false\n  }\n}\n", "const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.log(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsedAll, options)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(parsedAll).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n    }\n  }\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n", "// Status query function - Serverless function wrapper\nimport { getJobStatus, StatusQueryRequest, StatusQueryResponse } from '../services/status';\nimport { ErrorResponse } from '../models/errors';\nimport { logger } from '../utils/logger';\n\n/**\n * Lambda handler for job status queries\n * This function retrieves the current status of a job by its ID,\n * including stage progress and any error information.\n */\nexport async function statusHandler(event: any): Promise<any> {\n  try {\n    logger.info('Status query function invoked');\n    \n    // Parse the request\n    const jobId = event.jobId || event.pathParameters?.jobId;\n    \n    if (!jobId) {\n      throw new Error('jobId is required');\n    }\n    \n    const request: StatusQueryRequest = { jobId };\n    \n    // Get job status\n    const response: StatusQueryResponse = await getJobStatus(request);\n    \n    logger.info('Status query completed successfully', { jobId });\n    \n    return {\n      statusCode: 200,\n      body: JSON.stringify(response),\n    };\n  } catch (error) {\n    logger.error('Status handler error', { error });\n    \n    // Check if this is a \"not found\" error\n    const isNotFound = error instanceof Error && error.message.includes('not found');\n    \n    const errorResponse: ErrorResponse = {\n      error: error instanceof Error ? error.message : 'Unknown error',\n      code: isNotFound ? 'JOB_NOT_FOUND' : 'STATUS_QUERY_FAILED',\n      jobId: event.jobId || event.pathParameters?.jobId,\n      retryable: !isNotFound, // Don't retry if job doesn't exist\n    };\n    \n    return {\n      statusCode: isNotFound ? 404 : 500,\n      body: JSON.stringify(errorResponse),\n    };\n  }\n}\n", "// DynamoDB client wrapper with local/production mode support\nimport AWS from 'aws-sdk';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\nimport { Job, JobStatus, StageStatus } from '../models/job';\nimport { LectureAgent } from '../models/agent';\nimport { ExtractedContent, SegmentedContent } from '../models/content';\nimport { WordTiming } from '../models/audio';\n\n// Configure AWS SDK based on environment\nconst dynamoDBConfig: AWS.DynamoDB.ClientConfiguration = {\n  region: config.aws.region,\n};\n\nif (config.localstack.useLocalStack) {\n  dynamoDBConfig.endpoint = config.localstack.endpoint;\n  dynamoDBConfig.accessKeyId = 'test';\n  dynamoDBConfig.secretAccessKey = 'test';\n} else if (config.aws.accessKeyId && config.aws.secretAccessKey) {\n  dynamoDBConfig.accessKeyId = config.aws.accessKeyId;\n  dynamoDBConfig.secretAccessKey = config.aws.secretAccessKey;\n}\n\nconst dynamoDB = new AWS.DynamoDB.DocumentClient(dynamoDBConfig);\n\n// Helper function to handle DynamoDB errors\nfunction handleDynamoDBError(error: any, operation: string): never {\n  logger.error(`DynamoDB ${operation} failed`, { error: error.message });\n  throw new Error(`Database operation failed: ${operation}`);\n}\n\n// ============================================================================\n// Jobs Table Operations\n// ============================================================================\n\nexport interface JobRecord {\n  jobId: string;\n  status: JobStatus;\n  createdAt: string;\n  updatedAt: string;\n  pdfFilename: string;\n  pdfUrl: string;\n  agentId?: string;\n  stages: StageStatus[];\n  error?: string;\n}\n\nfunction jobToRecord(job: Job): JobRecord {\n  return {\n    ...job,\n    createdAt: job.createdAt.toISOString(),\n    updatedAt: job.updatedAt.toISOString(),\n  };\n}\n\nfunction recordToJob(record: JobRecord): Job {\n  return {\n    ...record,\n    createdAt: new Date(record.createdAt),\n    updatedAt: new Date(record.updatedAt),\n    stages: record.stages.map(stage => ({\n      ...stage,\n      startedAt: stage.startedAt ? new Date(stage.startedAt) : undefined,\n      completedAt: stage.completedAt ? new Date(stage.completedAt) : undefined,\n    })),\n  };\n}\n\nexport async function createJob(job: Job): Promise<Job> {\n  try {\n    const record = jobToRecord(job);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job created', { jobId: job.jobId });\n    return job;\n  } catch (error) {\n    handleDynamoDBError(error, 'createJob');\n  }\n}\n\nexport async function getJob(jobId: string): Promise<Job | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToJob(result.Item as JobRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getJob');\n  }\n}\n\nexport async function updateJob(jobId: string, updates: Partial<Job>): Promise<Job> {\n  try {\n    const current = await getJob(jobId);\n    if (!current) {\n      throw new Error(`Job not found: ${jobId}`);\n    }\n    \n    const updated: Job = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date(),\n    };\n    \n    const record = jobToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateJob');\n  }\n}\n\nexport async function deleteJob(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Job deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteJob');\n  }\n}\n\nexport async function listJobs(): Promise<Job[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.jobsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToJob(item as JobRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listJobs');\n  }\n}\n\n// ============================================================================\n// Agents Table Operations\n// ============================================================================\n\nexport interface AgentRecord {\n  id: string;\n  name: string;\n  description: string;\n  personality: {\n    instructions: string;\n    tone: string;\n    examples?: string[];\n  };\n  voice: {\n    voiceId: string;\n    speed: number;\n    pitch: number;\n  };\n  createdAt: string;\n}\n\nfunction agentToRecord(agent: LectureAgent): AgentRecord {\n  return {\n    ...agent,\n    createdAt: agent.createdAt.toISOString(),\n  };\n}\n\nfunction recordToAgent(record: AgentRecord): LectureAgent {\n  return {\n    ...record,\n    personality: {\n      ...record.personality,\n      tone: record.personality.tone as any,\n    },\n    createdAt: new Date(record.createdAt),\n  };\n}\n\nexport async function createAgent(agent: LectureAgent): Promise<LectureAgent> {\n  try {\n    // Check for unique name\n    const existing = await listAgents();\n    if (existing.some(a => a.name === agent.name && a.id !== agent.id)) {\n      throw new Error(`Agent with name \"${agent.name}\" already exists`);\n    }\n    \n    const record = agentToRecord(agent);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent created', { agentId: agent.id, name: agent.name });\n    return agent;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('already exists')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'createAgent');\n  }\n}\n\nexport async function getAgent(id: string): Promise<LectureAgent | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToAgent(result.Item as AgentRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getAgent');\n  }\n}\n\nexport async function updateAgent(id: string, updates: Partial<LectureAgent>): Promise<LectureAgent> {\n  try {\n    const current = await getAgent(id);\n    if (!current) {\n      throw new Error(`Agent not found: ${id}`);\n    }\n    \n    // Check for unique name if name is being updated\n    if (updates.name && updates.name !== current.name) {\n      const existing = await listAgents();\n      if (existing.some(a => a.name === updates.name && a.id !== id)) {\n        throw new Error(`Agent with name \"${updates.name}\" already exists`);\n      }\n    }\n    \n    const updated: LectureAgent = {\n      ...current,\n      ...updates,\n      id, // Ensure id doesn't change\n      // Deep merge nested objects\n      personality: updates.personality ? {\n        ...current.personality,\n        ...updates.personality,\n      } : current.personality,\n      voice: updates.voice ? {\n        ...current.voice,\n        ...updates.voice,\n      } : current.voice,\n    };\n    \n    const record = agentToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent updated', { agentId: id });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && (error.message.includes('already exists') || error.message.includes('not found'))) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateAgent');\n  }\n}\n\nexport async function deleteAgent(id: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    logger.info('Agent deleted', { agentId: id });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteAgent');\n  }\n}\n\nexport async function listAgents(): Promise<LectureAgent[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.agentsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToAgent(item as AgentRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listAgents');\n  }\n}\n\n// ============================================================================\n// Content Table Operations\n// ============================================================================\n\nexport interface ContentRecord {\n  jobId: string;\n  extractedContent?: ExtractedContent;\n  segmentedContent?: SegmentedContent;\n  script?: any; // LectureScript type from script model\n  audioUrl?: string;\n  wordTimings?: WordTiming[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport async function createContent(jobId: string): Promise<ContentRecord> {\n  try {\n    const record: ContentRecord = {\n      jobId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Content record created', { jobId });\n    return record;\n  } catch (error) {\n    handleDynamoDBError(error, 'createContent');\n  }\n}\n\nexport async function getContent(jobId: string): Promise<ContentRecord | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return result.Item as ContentRecord;\n  } catch (error) {\n    handleDynamoDBError(error, 'getContent');\n  }\n}\n\nexport async function updateContent(jobId: string, updates: Partial<ContentRecord>): Promise<ContentRecord> {\n  try {\n    const current = await getContent(jobId);\n    if (!current) {\n      throw new Error(`Content not found for job: ${jobId}`);\n    }\n    \n    const updated: ContentRecord = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: updated,\n    }).promise();\n    \n    logger.info('Content updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateContent');\n  }\n}\n\nexport async function deleteContent(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Content deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteContent');\n  }\n}\n\n// ============================================================================\n// Table Creation (for local development)\n// ============================================================================\n\nexport async function createTablesIfNotExist(): Promise<void> {\n  if (!config.localstack.useLocalStack) {\n    logger.info('Skipping table creation in production mode');\n    return;\n  }\n  \n  const dynamoDBClient = new AWS.DynamoDB(dynamoDBConfig);\n  \n  const tables = [\n    {\n      TableName: config.dynamodb.jobsTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.agentsTable,\n      KeySchema: [{ AttributeName: 'id', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'id', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.contentTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n  ];\n  \n  for (const tableConfig of tables) {\n    try {\n      await dynamoDBClient.describeTable({ TableName: tableConfig.TableName }).promise();\n      logger.info(`Table ${tableConfig.TableName} already exists`);\n    } catch (error: any) {\n      if (error.code === 'ResourceNotFoundException') {\n        try {\n          await dynamoDBClient.createTable({\n            ...tableConfig,\n            BillingMode: 'PAY_PER_REQUEST',\n          }).promise();\n          logger.info(`Table ${tableConfig.TableName} created`);\n        } catch (createError) {\n          logger.error(`Failed to create table ${tableConfig.TableName}`, { error: createError });\n        }\n      }\n    }\n  }\n}\n", "// Configuration utilities\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const config = {\n  nodeEnv: process.env.NODE_ENV || 'development',\n  port: parseInt(process.env.PORT || '3000', 10),\n  localMode: process.env.LOCAL_MODE === 'true',\n  isLocal: process.env.NODE_ENV !== 'production',\n  awsRegion: process.env.AWS_REGION || 'us-east-1',\n  eventBusName: process.env.EVENT_BUS_NAME || 'pdf-lecture-service-events',\n  \n  aws: {\n    region: process.env.AWS_REGION || 'us-east-1',\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  },\n  \n  localstack: {\n    endpoint: process.env.LOCALSTACK_ENDPOINT || 'http://localhost:4566',\n    useLocalStack: process.env.USE_LOCALSTACK === 'true',\n  },\n  \n  s3: {\n    bucketName: process.env.S3_BUCKET_NAME || 'pdf-lecture-service',\n    pdfPrefix: process.env.S3_PDF_PREFIX || 'pdfs',\n    audioPrefix: process.env.S3_AUDIO_PREFIX || 'audio',\n    cachePrefix: process.env.S3_CACHE_PREFIX || 'cache',\n  },\n  \n  dynamodb: {\n    jobsTable: process.env.DYNAMODB_JOBS_TABLE || 'pdf-lecture-jobs',\n    agentsTable: process.env.DYNAMODB_AGENTS_TABLE || 'pdf-lecture-agents',\n    contentTable: process.env.DYNAMODB_CONTENT_TABLE || 'pdf-lecture-content',\n  },\n  \n  processing: {\n    maxPdfSizeMB: parseInt(process.env.MAX_PDF_SIZE_MB || '100', 10),\n    analysisTimeoutMs: parseInt(process.env.ANALYSIS_TIMEOUT_MS || '300000', 10),\n    audioSynthesisTimeoutMs: parseInt(process.env.AUDIO_SYNTHESIS_TIMEOUT_MS || '600000', 10),\n  },\n  \n  featureFlags: {\n    enableRealSegmentation: process.env.ENABLE_REAL_SEGMENTATION === 'true',\n    enableRealScriptGeneration: process.env.ENABLE_REAL_SCRIPT_GENERATION === 'true',\n    enableImageExtraction: process.env.ENABLE_IMAGE_EXTRACTION === 'true',\n    enableVisionFirstPipeline: process.env.ENABLE_VISION_FIRST_PIPELINE === 'true',\n  },\n  \n  vision: {\n    model: process.env.VISION_MODEL || 'google/gemini-2.0-flash-exp:free',\n    temperature: parseFloat(process.env.VISION_LLM_TEMPERATURE || '0.3'),\n    maxTokens: parseInt(process.env.VISION_LLM_MAX_TOKENS || '4000', 10),\n  },\n};\n", "// Logging utility with structured JSON logging, correlation IDs, and sensitive data redaction\n\nexport enum LogLevel {\n  ERROR = 'ERROR',\n  WARN = 'WARN',\n  INFO = 'INFO',\n  DEBUG = 'DEBUG',\n}\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  correlationId?: string;\n  metadata?: Record<string, any>;\n  service?: string;\n  function?: string;\n}\n\n// Sensitive field patterns to redact\nconst SENSITIVE_PATTERNS = [\n  /password/i,\n  /secret/i,\n  /token/i,\n  /apikey/i,\n  /api[_-]?key/i,\n  /authorization/i,\n  /auth/i,\n  /credential/i,\n  /private[_-]?key/i,\n  /access[_-]?key/i,\n];\n\nclass Logger {\n  private correlationId?: string;\n  private serviceName?: string;\n  private functionName?: string;\n  private minLogLevel: LogLevel;\n\n  constructor() {\n    // Set minimum log level from environment or default to INFO\n    const envLogLevel = process.env.LOG_LEVEL?.toUpperCase() as LogLevel;\n    this.minLogLevel = envLogLevel || LogLevel.INFO;\n  }\n\n  setCorrelationId(id: string) {\n    this.correlationId = id;\n  }\n\n  getCorrelationId(): string | undefined {\n    return this.correlationId;\n  }\n\n  setServiceName(name: string) {\n    this.serviceName = name;\n  }\n\n  setFunctionName(name: string) {\n    this.functionName = name;\n  }\n\n  /**\n   * Redact sensitive data from metadata\n   */\n  private redactSensitiveData(data: any): any {\n    if (data === null || data === undefined) {\n      return data;\n    }\n\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(item => this.redactSensitiveData(item));\n    }\n\n    if (typeof data === 'object') {\n      const redacted: Record<string, any> = {};\n      for (const [key, value] of Object.entries(data)) {\n        // Check if key matches sensitive patterns\n        const isSensitive = SENSITIVE_PATTERNS.some(pattern => pattern.test(key));\n        \n        if (isSensitive) {\n          redacted[key] = '[REDACTED]';\n        } else if (typeof value === 'object' && value !== null) {\n          redacted[key] = this.redactSensitiveData(value);\n        } else {\n          redacted[key] = value;\n        }\n      }\n      return redacted;\n    }\n\n    return data;\n  }\n\n  /**\n   * Check if log level should be logged based on minimum level\n   */\n  private shouldLog(level: LogLevel): boolean {\n    const levels = [LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG];\n    const currentLevelIndex = levels.indexOf(level);\n    const minLevelIndex = levels.indexOf(this.minLogLevel);\n    return currentLevelIndex <= minLevelIndex;\n  }\n\n  private log(level: LogLevel, message: string, metadata?: Record<string, any>) {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      correlationId: this.correlationId,\n      service: this.serviceName,\n      function: this.functionName,\n      metadata: metadata ? this.redactSensitiveData(metadata) : undefined,\n    };\n    \n    // Output as JSON for structured logging\n    console.log(JSON.stringify(entry));\n  }\n\n  error(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.ERROR, message, metadata);\n  }\n\n  warn(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.WARN, message, metadata);\n  }\n\n  info(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.INFO, message, metadata);\n  }\n\n  debug(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.DEBUG, message, metadata);\n  }\n\n  /**\n   * Create a child logger with a specific correlation ID\n   */\n  child(correlationId: string): Logger {\n    const childLogger = new Logger();\n    childLogger.setCorrelationId(correlationId);\n    childLogger.setServiceName(this.serviceName || '');\n    childLogger.setFunctionName(this.functionName || '');\n    return childLogger;\n  }\n}\n\nexport const logger = new Logger();\n", "// Status query service\nimport { getJob, getContent } from './dynamodb';\nimport { Job } from '../models/job';\nimport { PlaybackState } from '../models/playback';\nimport { logger } from '../utils/logger';\n\nexport interface StatusQueryRequest {\n  jobId: string;\n}\n\nexport interface StatusQueryResponse {\n  jobId: string;\n  status: Job['status'];\n  createdAt: Date;\n  updatedAt: Date;\n  pdfFilename: string;\n  agentId?: string;\n  stages: Job['stages'];\n  error?: string;\n}\n\n/**\n * Retrieve job status by job ID\n * Returns job status, stage progress, and error information\n * Throws error if job ID does not exist\n */\nexport async function getJobStatus(request: StatusQueryRequest): Promise<StatusQueryResponse> {\n  const { jobId } = request;\n  \n  logger.info('Retrieving job status', { jobId });\n  \n  // Retrieve job from database\n  const job = await getJob(jobId);\n  \n  // Handle non-existent job IDs\n  if (!job) {\n    logger.warn('Job not found', { jobId });\n    throw new Error(`Job not found: ${jobId}`);\n  }\n  \n  // Return job status information\n  const response: StatusQueryResponse = {\n    jobId: job.jobId,\n    status: job.status,\n    createdAt: job.createdAt,\n    updatedAt: job.updatedAt,\n    pdfFilename: job.pdfFilename,\n    agentId: job.agentId,\n    stages: job.stages,\n    error: job.error,\n  };\n  \n  logger.info('Job status retrieved', { jobId, status: job.status });\n  \n  return response;\n}\n\n/**\n * Retrieve playback data for a completed job\n * Returns all data needed for the Immersive Reader interface\n */\nexport async function getPlaybackData(jobId: string): Promise<PlaybackState> {\n  logger.info('Retrieving playback data', { jobId });\n  \n  // Retrieve job from database\n  const job = await getJob(jobId);\n  \n  if (!job) {\n    logger.warn('Job not found', { jobId });\n    throw new Error(`Job not found: ${jobId}`);\n  }\n  \n  // Check if job is completed\n  if (job.status !== 'completed') {\n    logger.warn('Job not completed', { jobId, status: job.status });\n    throw new Error(`Job not completed: ${job.status}`);\n  }\n  \n  // Retrieve content data\n  const content = await getContent(jobId);\n  \n  if (!content) {\n    logger.warn('Content not found', { jobId });\n    throw new Error(`Content not found for job: ${jobId}`);\n  }\n  \n  // Construct playback state\n  const playbackState: PlaybackState = {\n    jobId: job.jobId,\n    pdfUrl: job.pdfUrl,\n    script: content.script,\n    audioUrl: content.audioUrl || '',\n    wordTimings: content.wordTimings || [],\n    currentTime: 0,\n    isPlaying: false,\n  };\n  \n  logger.info('Playback data retrieved', { jobId });\n  \n  return playbackState;\n}\n"],
  "mappings": "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",
  "names": ["require_package", "__commonJSMin", "exports", "module", "require_main", "__commonJSMin", "exports", "module", "fs", "path", "os", "crypto", "packageJson", "version", "LINE", "parse", "src", "obj", "lines", "match", "key", "value", "maybeQuote", "_parseVault", "options", "vaultPath", "_vaultPath", "result", "DotenvModule", "err", "keys", "_dotenvKey", "length", "decrypted", "i", "attrs", "_instructions", "error", "_warn", "message", "_debug", "_log", "dotenvKey", "uri", "environment", "environmentKey", "ciphertext", "possibleVaultPath", "filepath", "_resolveHome", "envPath", "_configVault", "debug", "quiet", "parsed", "processEnv", "configDotenv", "dotenvPath", "encoding", "optionPaths", "lastError", "parsedAll", "e", "keysCount", "shortPaths", "filePath", "relative", "config", "decrypt", "encrypted", "keyStr", "nonce", "authTag", "aesgcm", "isRange", "invalidKeyLength", "decryptionFailed", "populate", "override", "status_exports", "__export", "statusHandler", "__toCommonJS", "import_aws_sdk", "import_dotenv", "dotenv", "config", "SENSITIVE_PATTERNS", "Logger", "_Logger", "envLogLevel", "id", "name", "data", "item", "redacted", "key", "value", "pattern", "level", "levels", "currentLevelIndex", "minLevelIndex", "message", "metadata", "entry", "correlationId", "childLogger", "logger", "dynamoDBConfig", "config", "dynamoDB", "AWS", "handleDynamoDBError", "error", "operation", "logger", "recordToJob", "record", "stage", "getJob", "jobId", "result", "dynamoDB", "config", "recordToJob", "error", "handleDynamoDBError", "getJobStatus", "request", "jobId", "logger", "job", "getJob", "response", "statusHandler", "event", "logger", "jobId", "response", "getJobStatus", "error", "isNotFound", "errorResponse"]
}
