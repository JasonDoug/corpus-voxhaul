{
  "version": 3,
  "sources": ["../../../../../../../tmp/tmpjsw6gkc8/node_modules/dotenv/package.json", "../../../../../../../tmp/tmpjsw6gkc8/node_modules/dotenv/lib/main.js", "../../../../../../../tmp/tmpjsw6gkc8/src/utils/config.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/utils/logger.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/utils/cloudwatch.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/functions/upload.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/services/upload.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/utils/errors.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/services/s3.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/utils/retry.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/services/dynamodb.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/services/eventbridge.ts", "../../../../../../../tmp/tmpjsw6gkc8/src/utils/metrics.ts"],
  "sourcesContent": ["{\n  \"name\": \"dotenv\",\n  \"version\": \"16.6.1\",\n  \"description\": \"Loads environment variables from .env file\",\n  \"main\": \"lib/main.js\",\n  \"types\": \"lib/main.d.ts\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./lib/main.d.ts\",\n      \"require\": \"./lib/main.js\",\n      \"default\": \"./lib/main.js\"\n    },\n    \"./config\": \"./config.js\",\n    \"./config.js\": \"./config.js\",\n    \"./lib/env-options\": \"./lib/env-options.js\",\n    \"./lib/env-options.js\": \"./lib/env-options.js\",\n    \"./lib/cli-options\": \"./lib/cli-options.js\",\n    \"./lib/cli-options.js\": \"./lib/cli-options.js\",\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"dts-check\": \"tsc --project tests/types/tsconfig.json\",\n    \"lint\": \"standard\",\n    \"pretest\": \"npm run lint && npm run dts-check\",\n    \"test\": \"tap run --allow-empty-coverage --disable-coverage --timeout=60000\",\n    \"test:coverage\": \"tap run --show-full-coverage --timeout=60000 --coverage-report=text --coverage-report=lcov\",\n    \"prerelease\": \"npm test\",\n    \"release\": \"standard-version\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git://github.com/motdotla/dotenv.git\"\n  },\n  \"homepage\": \"https://github.com/motdotla/dotenv#readme\",\n  \"funding\": \"https://dotenvx.com\",\n  \"keywords\": [\n    \"dotenv\",\n    \"env\",\n    \".env\",\n    \"environment\",\n    \"variables\",\n    \"config\",\n    \"settings\"\n  ],\n  \"readmeFilename\": \"README.md\",\n  \"license\": \"BSD-2-Clause\",\n  \"devDependencies\": {\n    \"@types/node\": \"^18.11.3\",\n    \"decache\": \"^4.6.2\",\n    \"sinon\": \"^14.0.1\",\n    \"standard\": \"^17.0.0\",\n    \"standard-version\": \"^9.5.0\",\n    \"tap\": \"^19.2.0\",\n    \"typescript\": \"^4.8.4\"\n  },\n  \"engines\": {\n    \"node\": \">=12\"\n  },\n  \"browser\": {\n    \"fs\": false\n  }\n}\n", "const fs = require('fs')\nconst path = require('path')\nconst os = require('os')\nconst crypto = require('crypto')\nconst packageJson = require('../package.json')\n\nconst version = packageJson.version\n\nconst LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg\n\n// Parse src into an Object\nfunction parse (src) {\n  const obj = {}\n\n  // Convert buffer to string\n  let lines = src.toString()\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n')\n\n  let match\n  while ((match = LINE.exec(lines)) != null) {\n    const key = match[1]\n\n    // Default undefined or null to empty string\n    let value = (match[2] || '')\n\n    // Remove whitespace\n    value = value.trim()\n\n    // Check if double quoted\n    const maybeQuote = value[0]\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2')\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n')\n      value = value.replace(/\\\\r/g, '\\r')\n    }\n\n    // Add to object\n    obj[key] = value\n  }\n\n  return obj\n}\n\nfunction _parseVault (options) {\n  options = options || {}\n\n  const vaultPath = _vaultPath(options)\n  options.path = vaultPath // parse .env.vault\n  const result = DotenvModule.configDotenv(options)\n  if (!result.parsed) {\n    const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`)\n    err.code = 'MISSING_DATA'\n    throw err\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  const keys = _dotenvKey(options).split(',')\n  const length = keys.length\n\n  let decrypted\n  for (let i = 0; i < length; i++) {\n    try {\n      // Get full key\n      const key = keys[i].trim()\n\n      // Get instructions for decrypt\n      const attrs = _instructions(result, key)\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key)\n\n      break\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted)\n}\n\nfunction _warn (message) {\n  console.log(`[dotenv@${version}][WARN] ${message}`)\n}\n\nfunction _debug (message) {\n  console.log(`[dotenv@${version}][DEBUG] ${message}`)\n}\n\nfunction _log (message) {\n  console.log(`[dotenv@${version}] ${message}`)\n}\n\nfunction _dotenvKey (options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {\n    return process.env.DOTENV_KEY\n  }\n\n  // fallback to empty string\n  return ''\n}\n\nfunction _instructions (result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  let uri\n  try {\n    uri = new URL(dotenvKey)\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      const err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    }\n\n    throw error\n  }\n\n  // Get decrypt key\n  const key = uri.password\n  if (!key) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing key part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get environment\n  const environment = uri.searchParams.get('environment')\n  if (!environment) {\n    const err = new Error('INVALID_DOTENV_KEY: Missing environment part')\n    err.code = 'INVALID_DOTENV_KEY'\n    throw err\n  }\n\n  // Get ciphertext payload\n  const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`\n  const ciphertext = result.parsed[environmentKey] // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`)\n    err.code = 'NOT_FOUND_DOTENV_ENVIRONMENT'\n    throw err\n  }\n\n  return { ciphertext, key }\n}\n\nfunction _vaultPath (options) {\n  let possibleVaultPath = null\n\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      for (const filepath of options.path) {\n        if (fs.existsSync(filepath)) {\n          possibleVaultPath = filepath.endsWith('.vault') ? filepath : `${filepath}.vault`\n        }\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : `${options.path}.vault`\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault')\n  }\n\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath\n  }\n\n  return null\n}\n\nfunction _resolveHome (envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath\n}\n\nfunction _configVault (options) {\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (debug || !quiet) {\n    _log('Loading env from encrypted .env.vault')\n  }\n\n  const parsed = DotenvModule._parseVault(options)\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsed, options)\n\n  return { parsed }\n}\n\nfunction configDotenv (options) {\n  const dotenvPath = path.resolve(process.cwd(), '.env')\n  let encoding = 'utf8'\n  const debug = Boolean(options && options.debug)\n  const quiet = options && 'quiet' in options ? options.quiet : true\n\n  if (options && options.encoding) {\n    encoding = options.encoding\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default')\n    }\n  }\n\n  let optionPaths = [dotenvPath] // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)]\n    } else {\n      optionPaths = [] // reset default\n      for (const filepath of options.path) {\n        optionPaths.push(_resolveHome(filepath))\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  let lastError\n  const parsedAll = {}\n  for (const path of optionPaths) {\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      const parsed = DotenvModule.parse(fs.readFileSync(path, { encoding }))\n\n      DotenvModule.populate(parsedAll, parsed, options)\n    } catch (e) {\n      if (debug) {\n        _debug(`Failed to load ${path} ${e.message}`)\n      }\n      lastError = e\n    }\n  }\n\n  let processEnv = process.env\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv\n  }\n\n  DotenvModule.populate(processEnv, parsedAll, options)\n\n  if (debug || !quiet) {\n    const keysCount = Object.keys(parsedAll).length\n    const shortPaths = []\n    for (const filePath of optionPaths) {\n      try {\n        const relative = path.relative(process.cwd(), filePath)\n        shortPaths.push(relative)\n      } catch (e) {\n        if (debug) {\n          _debug(`Failed to load ${filePath} ${e.message}`)\n        }\n        lastError = e\n      }\n    }\n\n    _log(`injecting env (${keysCount}) from ${shortPaths.join(',')}`)\n  }\n\n  if (lastError) {\n    return { parsed: parsedAll, error: lastError }\n  } else {\n    return { parsed: parsedAll }\n  }\n}\n\n// Populates process.env from .env file\nfunction config (options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options)\n  }\n\n  const vaultPath = _vaultPath(options)\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`)\n\n    return DotenvModule.configDotenv(options)\n  }\n\n  return DotenvModule._configVault(options)\n}\n\nfunction decrypt (encrypted, keyStr) {\n  const key = Buffer.from(keyStr.slice(-64), 'hex')\n  let ciphertext = Buffer.from(encrypted, 'base64')\n\n  const nonce = ciphertext.subarray(0, 12)\n  const authTag = ciphertext.subarray(-16)\n  ciphertext = ciphertext.subarray(12, -16)\n\n  try {\n    const aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce)\n    aesgcm.setAuthTag(authTag)\n    return `${aesgcm.update(ciphertext)}${aesgcm.final()}`\n  } catch (error) {\n    const isRange = error instanceof RangeError\n    const invalidKeyLength = error.message === 'Invalid key length'\n    const decryptionFailed = error.message === 'Unsupported state or unable to authenticate data'\n\n    if (isRange || invalidKeyLength) {\n      const err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)')\n      err.code = 'INVALID_DOTENV_KEY'\n      throw err\n    } else if (decryptionFailed) {\n      const err = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY')\n      err.code = 'DECRYPTION_FAILED'\n      throw err\n    } else {\n      throw error\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate (processEnv, parsed, options = {}) {\n  const debug = Boolean(options && options.debug)\n  const override = Boolean(options && options.override)\n\n  if (typeof parsed !== 'object') {\n    const err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate')\n    err.code = 'OBJECT_REQUIRED'\n    throw err\n  }\n\n  // Set process.env\n  for (const key of Object.keys(parsed)) {\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key]\n      }\n\n      if (debug) {\n        if (override === true) {\n          _debug(`\"${key}\" is already defined and WAS overwritten`)\n        } else {\n          _debug(`\"${key}\" is already defined and was NOT overwritten`)\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key]\n    }\n  }\n}\n\nconst DotenvModule = {\n  configDotenv,\n  _configVault,\n  _parseVault,\n  config,\n  decrypt,\n  parse,\n  populate\n}\n\nmodule.exports.configDotenv = DotenvModule.configDotenv\nmodule.exports._configVault = DotenvModule._configVault\nmodule.exports._parseVault = DotenvModule._parseVault\nmodule.exports.config = DotenvModule.config\nmodule.exports.decrypt = DotenvModule.decrypt\nmodule.exports.parse = DotenvModule.parse\nmodule.exports.populate = DotenvModule.populate\n\nmodule.exports = DotenvModule\n", "// Configuration utilities\nimport dotenv from 'dotenv';\n\ndotenv.config();\n\nexport const config = {\n  nodeEnv: process.env.NODE_ENV || 'development',\n  port: parseInt(process.env.PORT || '3000', 10),\n  localMode: process.env.LOCAL_MODE === 'true',\n  isLocal: process.env.NODE_ENV !== 'production',\n  awsRegion: process.env.AWS_REGION || 'us-east-1',\n  eventBusName: process.env.EVENT_BUS_NAME || 'pdf-lecture-service-events',\n  \n  aws: {\n    region: process.env.AWS_REGION || 'us-east-1',\n    accessKeyId: process.env.AWS_ACCESS_KEY_ID,\n    secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,\n  },\n  \n  localstack: {\n    endpoint: process.env.LOCALSTACK_ENDPOINT || 'http://localhost:4566',\n    useLocalStack: process.env.USE_LOCALSTACK === 'true',\n  },\n  \n  s3: {\n    bucketName: process.env.S3_BUCKET_NAME || 'pdf-lecture-service',\n    pdfPrefix: process.env.S3_PDF_PREFIX || 'pdfs',\n    audioPrefix: process.env.S3_AUDIO_PREFIX || 'audio',\n    cachePrefix: process.env.S3_CACHE_PREFIX || 'cache',\n  },\n  \n  dynamodb: {\n    jobsTable: process.env.DYNAMODB_JOBS_TABLE || 'pdf-lecture-jobs',\n    agentsTable: process.env.DYNAMODB_AGENTS_TABLE || 'pdf-lecture-agents',\n    contentTable: process.env.DYNAMODB_CONTENT_TABLE || 'pdf-lecture-content',\n  },\n  \n  processing: {\n    maxPdfSizeMB: parseInt(process.env.MAX_PDF_SIZE_MB || '100', 10),\n    analysisTimeoutMs: parseInt(process.env.ANALYSIS_TIMEOUT_MS || '300000', 10),\n    audioSynthesisTimeoutMs: parseInt(process.env.AUDIO_SYNTHESIS_TIMEOUT_MS || '600000', 10),\n  },\n  \n  featureFlags: {\n    enableRealSegmentation: process.env.ENABLE_REAL_SEGMENTATION === 'true',\n    enableRealScriptGeneration: process.env.ENABLE_REAL_SCRIPT_GENERATION === 'true',\n    enableImageExtraction: process.env.ENABLE_IMAGE_EXTRACTION === 'true',\n    enableVisionFirstPipeline: process.env.ENABLE_VISION_FIRST_PIPELINE === 'true',\n  },\n  \n  vision: {\n    model: process.env.VISION_MODEL || 'google/gemini-2.0-flash-exp:free',\n    temperature: parseFloat(process.env.VISION_LLM_TEMPERATURE || '0.3'),\n    maxTokens: parseInt(process.env.VISION_LLM_MAX_TOKENS || '4000', 10),\n  },\n};\n", "// Logging utility with structured JSON logging, correlation IDs, and sensitive data redaction\n\nexport enum LogLevel {\n  ERROR = 'ERROR',\n  WARN = 'WARN',\n  INFO = 'INFO',\n  DEBUG = 'DEBUG',\n}\n\ninterface LogEntry {\n  level: LogLevel;\n  message: string;\n  timestamp: string;\n  correlationId?: string;\n  metadata?: Record<string, any>;\n  service?: string;\n  function?: string;\n}\n\n// Sensitive field patterns to redact\nconst SENSITIVE_PATTERNS = [\n  /password/i,\n  /secret/i,\n  /token/i,\n  /apikey/i,\n  /api[_-]?key/i,\n  /authorization/i,\n  /auth/i,\n  /credential/i,\n  /private[_-]?key/i,\n  /access[_-]?key/i,\n];\n\nclass Logger {\n  private correlationId?: string;\n  private serviceName?: string;\n  private functionName?: string;\n  private minLogLevel: LogLevel;\n\n  constructor() {\n    // Set minimum log level from environment or default to INFO\n    const envLogLevel = process.env.LOG_LEVEL?.toUpperCase() as LogLevel;\n    this.minLogLevel = envLogLevel || LogLevel.INFO;\n  }\n\n  setCorrelationId(id: string) {\n    this.correlationId = id;\n  }\n\n  getCorrelationId(): string | undefined {\n    return this.correlationId;\n  }\n\n  setServiceName(name: string) {\n    this.serviceName = name;\n  }\n\n  setFunctionName(name: string) {\n    this.functionName = name;\n  }\n\n  /**\n   * Redact sensitive data from metadata\n   */\n  private redactSensitiveData(data: any): any {\n    if (data === null || data === undefined) {\n      return data;\n    }\n\n    if (typeof data === 'string') {\n      return data;\n    }\n\n    if (Array.isArray(data)) {\n      return data.map(item => this.redactSensitiveData(item));\n    }\n\n    if (typeof data === 'object') {\n      const redacted: Record<string, any> = {};\n      for (const [key, value] of Object.entries(data)) {\n        // Check if key matches sensitive patterns\n        const isSensitive = SENSITIVE_PATTERNS.some(pattern => pattern.test(key));\n        \n        if (isSensitive) {\n          redacted[key] = '[REDACTED]';\n        } else if (typeof value === 'object' && value !== null) {\n          redacted[key] = this.redactSensitiveData(value);\n        } else {\n          redacted[key] = value;\n        }\n      }\n      return redacted;\n    }\n\n    return data;\n  }\n\n  /**\n   * Check if log level should be logged based on minimum level\n   */\n  private shouldLog(level: LogLevel): boolean {\n    const levels = [LogLevel.ERROR, LogLevel.WARN, LogLevel.INFO, LogLevel.DEBUG];\n    const currentLevelIndex = levels.indexOf(level);\n    const minLevelIndex = levels.indexOf(this.minLogLevel);\n    return currentLevelIndex <= minLevelIndex;\n  }\n\n  private log(level: LogLevel, message: string, metadata?: Record<string, any>) {\n    if (!this.shouldLog(level)) {\n      return;\n    }\n\n    const entry: LogEntry = {\n      level,\n      message,\n      timestamp: new Date().toISOString(),\n      correlationId: this.correlationId,\n      service: this.serviceName,\n      function: this.functionName,\n      metadata: metadata ? this.redactSensitiveData(metadata) : undefined,\n    };\n    \n    // Output as JSON for structured logging\n    console.log(JSON.stringify(entry));\n  }\n\n  error(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.ERROR, message, metadata);\n  }\n\n  warn(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.WARN, message, metadata);\n  }\n\n  info(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.INFO, message, metadata);\n  }\n\n  debug(message: string, metadata?: Record<string, any>) {\n    this.log(LogLevel.DEBUG, message, metadata);\n  }\n\n  /**\n   * Create a child logger with a specific correlation ID\n   */\n  child(correlationId: string): Logger {\n    const childLogger = new Logger();\n    childLogger.setCorrelationId(correlationId);\n    childLogger.setServiceName(this.serviceName || '');\n    childLogger.setFunctionName(this.functionName || '');\n    return childLogger;\n  }\n}\n\nexport const logger = new Logger();\n", "// CloudWatch integration for metrics and logs\nimport * as AWS from 'aws-sdk';\nimport { config } from './config';\nimport { logger } from './logger';\n\n// Initialize CloudWatch client\nconst cloudwatch = new AWS.CloudWatch({\n  region: config.aws.region,\n  ...(config.localstack.useLocalStack && {\n    endpoint: config.localstack.endpoint,\n  }),\n});\n\nexport interface CloudWatchMetric {\n  name: string;\n  value: number;\n  unit: string;\n  dimensions?: Record<string, string>;\n  timestamp?: Date;\n}\n\n/**\n * Publish a single metric to CloudWatch\n */\nexport async function publishMetric(metric: CloudWatchMetric): Promise<void> {\n  // Skip CloudWatch publishing in local mode\n  if (config.isLocal && !config.localstack.useLocalStack) {\n    logger.debug('Skipping CloudWatch metric in local mode', { metric });\n    return;\n  }\n\n  try {\n    const dimensions = metric.dimensions\n      ? Object.entries(metric.dimensions).map(([name, value]) => ({\n          Name: name,\n          Value: value,\n        }))\n      : [];\n\n    await cloudwatch\n      .putMetricData({\n        Namespace: 'PDFLectureService',\n        MetricData: [\n          {\n            MetricName: metric.name,\n            Value: metric.value,\n            Unit: metric.unit as any,\n            Timestamp: metric.timestamp || new Date(),\n            Dimensions: dimensions,\n          },\n        ],\n      })\n      .promise();\n\n    logger.debug('Metric published to CloudWatch', { metric });\n  } catch (error) {\n    logger.error('Failed to publish metric to CloudWatch', {\n      metric,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Publish multiple metrics to CloudWatch in a batch\n */\nexport async function publishMetrics(metrics: CloudWatchMetric[]): Promise<void> {\n  // Skip CloudWatch publishing in local mode\n  if (config.isLocal && !config.localstack.useLocalStack) {\n    logger.debug('Skipping CloudWatch metrics in local mode', { count: metrics.length });\n    return;\n  }\n\n  try {\n    const metricData = metrics.map((metric) => {\n      const dimensions = metric.dimensions\n        ? Object.entries(metric.dimensions).map(([name, value]) => ({\n            Name: name,\n            Value: value,\n          }))\n        : [];\n\n      return {\n        MetricName: metric.name,\n        Value: metric.value,\n        Unit: metric.unit as any,\n        Timestamp: metric.timestamp || new Date(),\n        Dimensions: dimensions,\n      };\n    });\n\n    // CloudWatch allows max 20 metrics per request\n    const batchSize = 20;\n    for (let i = 0; i < metricData.length; i += batchSize) {\n      const batch = metricData.slice(i, i + batchSize);\n      await cloudwatch\n        .putMetricData({\n          Namespace: 'PDFLectureService',\n          MetricData: batch,\n        })\n        .promise();\n    }\n\n    logger.debug('Metrics published to CloudWatch', { count: metrics.length });\n  } catch (error) {\n    logger.error('Failed to publish metrics to CloudWatch', {\n      count: metrics.length,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Create a CloudWatch alarm programmatically\n */\nexport async function createAlarm(params: {\n  alarmName: string;\n  metricName: string;\n  threshold: number;\n  comparisonOperator: string;\n  evaluationPeriods: number;\n  period: number;\n  statistic: string;\n  dimensions?: Record<string, string>;\n}): Promise<void> {\n  try {\n    const dimensions = params.dimensions\n      ? Object.entries(params.dimensions).map(([name, value]) => ({\n          Name: name,\n          Value: value,\n        }))\n      : [];\n\n    await cloudwatch\n      .putMetricAlarm({\n        AlarmName: params.alarmName,\n        MetricName: params.metricName,\n        Namespace: 'PDFLectureService',\n        Statistic: params.statistic,\n        Period: params.period,\n        EvaluationPeriods: params.evaluationPeriods,\n        Threshold: params.threshold,\n        ComparisonOperator: params.comparisonOperator,\n        Dimensions: dimensions,\n        TreatMissingData: 'notBreaching',\n      })\n      .promise();\n\n    logger.info('CloudWatch alarm created', { alarmName: params.alarmName });\n  } catch (error) {\n    logger.error('Failed to create CloudWatch alarm', {\n      alarmName: params.alarmName,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\n/**\n * Helper to create standard alarms for a Lambda function\n */\nexport async function createStandardAlarmsForFunction(\n  functionName: string,\n  timeoutMs: number\n): Promise<void> {\n  // Error rate alarm\n  await createAlarm({\n    alarmName: `${functionName}-ErrorRate`,\n    metricName: 'Errors',\n    threshold: 5,\n    comparisonOperator: 'GreaterThanThreshold',\n    evaluationPeriods: 1,\n    period: 300,\n    statistic: 'Sum',\n    dimensions: { FunctionName: functionName },\n  });\n\n  // Timeout alarm (90% of actual timeout)\n  await createAlarm({\n    alarmName: `${functionName}-Timeout`,\n    metricName: 'Duration',\n    threshold: timeoutMs * 0.9,\n    comparisonOperator: 'GreaterThanThreshold',\n    evaluationPeriods: 1,\n    period: 300,\n    statistic: 'Maximum',\n    dimensions: { FunctionName: functionName },\n  });\n\n  // Throttle alarm\n  await createAlarm({\n    alarmName: `${functionName}-Throttles`,\n    metricName: 'Throttles',\n    threshold: 1,\n    comparisonOperator: 'GreaterThanThreshold',\n    evaluationPeriods: 1,\n    period: 300,\n    statistic: 'Sum',\n    dimensions: { FunctionName: functionName },\n  });\n}\n", "// Upload function - Serverless function wrapper\nimport { handleUpload, UploadRequest, UploadResponse, generateErrorResponse } from '../services/upload';\nimport { ErrorResponse } from '../models/errors';\nimport { logger } from '../utils/logger';\nimport { metrics, RequestMetrics } from '../utils/metrics';\nimport { randomUUID } from 'crypto';\n\n// Initialize request metrics tracker\nconst requestMetrics = new RequestMetrics();\n\n/**\n * Lambda handler for PDF upload\n * This function accepts a PDF file, validates it, stores it in S3,\n * creates a job record, and triggers the analysis pipeline.\n */\nexport async function uploadHandler(event: any): Promise<any> {\n  // Generate correlation ID for request tracking\n  const correlationId = event.requestContext?.requestId || randomUUID();\n  logger.setCorrelationId(correlationId);\n  logger.setFunctionName('UploadFunction');\n  \n  // Start timing the request\n  const timerId = metrics.startTimer('UploadFunctionDuration', { function: 'upload' });\n  \n  try {\n    logger.info('Upload function invoked', { correlationId });\n    requestMetrics.incrementRequest('upload');\n    \n    // Parse the request\n    // In a real Lambda with API Gateway, the file would come from event.body\n    // For now, we expect the event to have the structure we need\n    const request: UploadRequest = {\n      file: event.file, // Buffer\n      filename: event.filename,\n      agentId: event.agentId,\n    };\n    \n    // Track file size\n    if (request.file) {\n      metrics.recordSize('UploadFileSize', request.file.length, { function: 'upload' });\n    }\n    \n    // Handle the upload\n    const response: UploadResponse = await handleUpload(request);\n    \n    logger.info('Upload completed successfully', { jobId: response.jobId, correlationId });\n    requestMetrics.incrementSuccess('upload');\n    metrics.stopTimer(timerId);\n    \n    return {\n      statusCode: 200,\n      body: JSON.stringify(response),\n    };\n  } catch (error) {\n    logger.error('Upload handler error', { error, correlationId });\n    \n    const errorType = (error as any).code || 'UnknownError';\n    requestMetrics.incrementError('upload', errorType);\n    metrics.recordCount('UploadError', 1, { function: 'upload', errorType });\n    metrics.stopTimer(timerId);\n    \n    const errorResponse: ErrorResponse = generateErrorResponse(error as any);\n    \n    // Determine HTTP status code based on error type\n    let statusCode = 500;\n    if ('code' in (error as any)) {\n      const code = (error as any).code;\n      if (code === 'FILE_TOO_LARGE' || code === 'INVALID_PDF') {\n        statusCode = 400; // Bad Request\n      }\n    }\n    \n    return {\n      statusCode,\n      body: JSON.stringify(errorResponse),\n    };\n  }\n}\n", "// Upload validation and handling service\nimport { randomUUID } from 'crypto';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\nimport { ErrorResponse } from '../models/errors';\nimport { \n  ValidationError, \n  validateFileSize as validateFileSizeUtil, \n  validatePDFFormat as validatePDFFormatUtil,\n  AppError \n} from '../utils/errors';\nimport { Job, JobStatus, StageStatus } from '../models/job';\nimport { uploadPDF } from './s3';\nimport { createJob, createContent } from './dynamodb';\nimport { triggerAnalysis } from './eventbridge';\n\n// ============================================================================\n// Validation Functions\n// ============================================================================\n\n/**\n * Validates the complete upload request\n * @param buffer File buffer\n * @param filename Original filename\n * @throws ValidationError if validation fails\n */\nexport function validateUpload(buffer: Buffer, filename: string): void {\n  const maxSizeBytes = config.processing.maxPdfSizeMB * 1024 * 1024;\n  \n  // Validate file size\n  try {\n    validateFileSizeUtil(buffer.length, maxSizeBytes);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      logger.warn('File size validation failed', { \n        fileSize: buffer.length, \n        maxSize: maxSizeBytes,\n        filename \n      });\n    }\n    throw error;\n  }\n  \n  // Validate PDF format\n  try {\n    validatePDFFormatUtil(buffer);\n  } catch (error) {\n    if (error instanceof ValidationError) {\n      logger.warn('PDF format validation failed', { filename });\n    }\n    throw error;\n  }\n  \n  logger.info('Upload validation passed', { filename, size: buffer.length });\n}\n\n/**\n * Generates an error response for upload failures\n * @param error The error that occurred\n * @param jobId Optional job ID if available\n * @returns Formatted error response\n */\nexport function generateErrorResponse(error: Error, jobId?: string): ErrorResponse {\n  if (error instanceof AppError) {\n    return error.toResponse(jobId);\n  }\n  \n  // Handle legacy UploadError format\n  if ('code' in error && typeof (error as any).code === 'string') {\n    const uploadError = error as any;\n    return {\n      error: uploadError.error || error.message,\n      code: uploadError.code,\n      jobId,\n      retryable: uploadError.code === 'UPLOAD_FAILED',\n    };\n  }\n  \n  // Generic error\n  return {\n    error: error.message || 'An unexpected error occurred',\n    code: 'UPLOAD_FAILED',\n    jobId,\n    retryable: true,\n  };\n}\n\n// ============================================================================\n// Upload Handler\n// ============================================================================\n\nexport interface UploadRequest {\n  file: Buffer;\n  filename: string;\n  agentId?: string;\n}\n\nexport interface UploadResponse {\n  jobId: string;\n  status: JobStatus;\n  message: string;\n}\n\n/**\n * Handles the complete PDF upload process\n * @param request Upload request containing file buffer and metadata\n * @returns Upload response with job ID\n * @throws ValidationError for validation failures\n * @throws AppError for processing failures\n */\nexport async function handleUpload(request: UploadRequest): Promise<UploadResponse> {\n  const { file, filename, agentId } = request;\n  \n  // Validate the upload (throws ValidationError if invalid)\n  validateUpload(file, filename);\n  \n  // Generate unique job ID\n  const jobId = randomUUID();\n  logger.info('Starting upload process', { jobId, filename, agentId });\n  \n  try {\n    // Upload PDF to S3\n    const pdfUrl = await uploadPDF(jobId, file, filename);\n    logger.info('PDF uploaded to storage', { jobId, pdfUrl });\n    \n    // Create job record in database\n    const job: Job = {\n      jobId,\n      status: 'queued',\n      createdAt: new Date(),\n      updatedAt: new Date(),\n      pdfFilename: filename,\n      pdfUrl,\n      agentId,\n      stages: initializeStages(),\n    };\n    \n    await createJob(job);\n    logger.info('Job record created', { jobId });\n    \n    // Create content record\n    await createContent(jobId);\n    logger.info('Content record created', { jobId });\n    \n    // Trigger Content Analysis function asynchronously\n    // In production, this publishes an event to EventBridge\n    // In local mode, the local server will handle this synchronously\n    if (config.nodeEnv === 'production') {\n      await triggerAnalysis(jobId);\n      logger.info('Analysis triggered asynchronously', { jobId });\n    } else {\n      logger.info('Job queued for analysis (local mode)', { jobId });\n    }\n    \n    return {\n      jobId,\n      status: 'queued',\n      message: 'PDF uploaded successfully and queued for processing',\n    };\n  } catch (error) {\n    logger.error('Upload failed', { jobId, error });\n    \n    // If it's already an AppError, rethrow it\n    if (error instanceof AppError) {\n      throw error;\n    }\n    \n    // Otherwise, wrap it in a ProcessingError\n    throw new AppError(\n      error instanceof Error ? error.message : 'Upload failed',\n      'UPLOAD_FAILED',\n      500,\n      true\n    );\n  }\n}\n\n/**\n * Initializes the stages array for a new job\n * @returns Array of stage statuses\n */\nfunction initializeStages(): StageStatus[] {\n  const stageNames = [\n    'upload',\n    'analysis',\n    'segmentation',\n    'script_generation',\n    'audio_synthesis',\n  ];\n  \n  return stageNames.map((stage, index) => ({\n    stage,\n    status: index === 0 ? 'completed' : 'pending', // Upload stage is completed\n  }));\n}\n", "// Error handling utilities\n\nexport interface ErrorResponse {\n  error: string;\n  code: string;\n  jobId?: string;\n  details?: Record<string, any>;\n  retryable: boolean;\n}\n\nexport class AppError extends Error {\n  constructor(\n    message: string,\n    public code: string,\n    public statusCode: number = 500,\n    public retryable: boolean = false,\n    public details?: Record<string, any>\n  ) {\n    super(message);\n    this.name = 'AppError';\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  toResponse(jobId?: string): ErrorResponse {\n    return {\n      error: this.message,\n      code: this.code,\n      jobId,\n      details: this.details,\n      retryable: this.retryable,\n    };\n  }\n}\n\nexport class ValidationError extends AppError {\n  constructor(message: string, details?: Record<string, any>) {\n    super(message, 'VALIDATION_ERROR', 400, false, details);\n    this.name = 'ValidationError';\n  }\n}\n\nexport class ProcessingError extends AppError {\n  constructor(message: string, retryable: boolean = true, details?: Record<string, any>) {\n    super(message, 'PROCESSING_ERROR', 500, retryable, details);\n    this.name = 'ProcessingError';\n  }\n}\n\nexport class ExternalServiceError extends AppError {\n  constructor(message: string, service: string, details?: Record<string, any>) {\n    super(message, 'EXTERNAL_SERVICE_ERROR', 502, true, { service, ...details });\n    this.name = 'ExternalServiceError';\n  }\n}\n\nexport class ResourceError extends AppError {\n  constructor(message: string, details?: Record<string, any>) {\n    super(message, 'RESOURCE_ERROR', 503, true, details);\n    this.name = 'ResourceError';\n  }\n}\n\n// Validation helpers\nexport function validateRequired(value: any, fieldName: string): void {\n  if (value === undefined || value === null) {\n    throw new ValidationError(`${fieldName} is required`);\n  }\n}\n\nexport function validateString(value: any, fieldName: string, minLength?: number, maxLength?: number): void {\n  validateRequired(value, fieldName);\n  if (typeof value !== 'string') {\n    throw new ValidationError(`${fieldName} must be a string`);\n  }\n  if (minLength !== undefined && value.length < minLength) {\n    throw new ValidationError(`${fieldName} must be at least ${minLength} characters`);\n  }\n  if (maxLength !== undefined && value.length > maxLength) {\n    throw new ValidationError(`${fieldName} must be at most ${maxLength} characters`);\n  }\n}\n\nexport function validateNumber(value: any, fieldName: string, min?: number, max?: number): void {\n  validateRequired(value, fieldName);\n  if (typeof value !== 'number' || isNaN(value)) {\n    throw new ValidationError(`${fieldName} must be a number`);\n  }\n  if (min !== undefined && value < min) {\n    throw new ValidationError(`${fieldName} must be at least ${min}`);\n  }\n  if (max !== undefined && value > max) {\n    throw new ValidationError(`${fieldName} must be at most ${max}`);\n  }\n}\n\nexport function validateEnum<T extends string>(value: any, fieldName: string, allowedValues: T[]): void {\n  validateRequired(value, fieldName);\n  if (!allowedValues.includes(value)) {\n    throw new ValidationError(`${fieldName} must be one of: ${allowedValues.join(', ')}`);\n  }\n}\n\nexport function validateArray(value: any, fieldName: string, itemValidator?: (item: any, index: number) => void): void {\n  validateRequired(value, fieldName);\n  if (!Array.isArray(value)) {\n    throw new ValidationError(`${fieldName} must be an array`);\n  }\n  if (itemValidator) {\n    value.forEach((item, index) => {\n      try {\n        itemValidator(item, index);\n      } catch (error) {\n        if (error instanceof ValidationError) {\n          throw new ValidationError(`${fieldName}[${index}]: ${error.message}`);\n        }\n        throw error;\n      }\n    });\n  }\n}\n\nexport function validateFileSize(size: number, maxSize: number): void {\n  if (size > maxSize) {\n    throw new ValidationError(`File size exceeds maximum allowed size of ${maxSize} bytes`, {\n      actualSize: size,\n      maxSize,\n    });\n  }\n}\n\nexport function validatePDFFormat(buffer: Buffer): void {\n  // Check PDF magic bytes: %PDF-\n  if (buffer.length < 5) {\n    throw new ValidationError('File is too small to be a valid PDF');\n  }\n  \n  const header = buffer.slice(0, 5).toString('ascii');\n  if (header !== '%PDF-') {\n    throw new ValidationError('File is not a valid PDF (invalid magic bytes)', {\n      actualHeader: header,\n    });\n  }\n}\n", "// S3 client wrapper with local/production mode support\nimport AWS from 'aws-sdk';\nimport { Readable } from 'stream';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\nimport { ResourceError, ExternalServiceError } from '../utils/errors';\nimport { withRetry } from '../utils/retry';\n\n// Configure AWS SDK based on environment\nconst s3Config: AWS.S3.ClientConfiguration = {\n  region: config.aws.region,\n  s3ForcePathStyle: true, // Required for LocalStack\n  httpOptions: {\n    timeout: 30000, // 30 second timeout for operations\n    connectTimeout: 5000, // 5 second connection timeout\n  },\n  maxRetries: 0, // We handle retries ourselves\n};\n\nif (config.localstack.useLocalStack) {\n  s3Config.endpoint = config.localstack.endpoint;\n  s3Config.accessKeyId = 'test';\n  s3Config.secretAccessKey = 'test';\n} else if (config.aws.accessKeyId && config.aws.secretAccessKey) {\n  s3Config.accessKeyId = config.aws.accessKeyId;\n  s3Config.secretAccessKey = config.aws.secretAccessKey;\n}\n\nconst s3 = new AWS.S3(s3Config);\n\n// Helper function to handle S3 errors\nfunction handleS3Error(error: any, operation: string): never {\n  logger.error(`S3 ${operation} failed`, { error: error.message, code: error.code });\n  \n  // Check for timeout errors\n  if (error.code === 'RequestTimeout' || error.code === 'TimeoutError') {\n    throw new ResourceError(`Storage operation timed out: ${operation}`, { error: error.message });\n  }\n  \n  // Check for resource errors\n  if (error.code === 'NoSuchBucket' || error.code === 'NoSuchKey') {\n    throw new ResourceError(`Storage resource not found: ${operation}`, { error: error.message });\n  }\n  \n  // Other errors are external service errors\n  throw new ExternalServiceError(`Storage operation failed: ${operation}`, 's3', { error: error.message });\n}\n\n// ============================================================================\n// PDF Operations\n// ============================================================================\n\nexport async function uploadPDF(jobId: string, pdfBuffer: Buffer, filename: string): Promise<string> {\n  return withRetry(async () => {\n    try {\n      const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n      \n      await s3.putObject({\n        Bucket: config.s3.bucketName,\n        Key: key,\n        Body: pdfBuffer,\n        ContentType: 'application/pdf',\n        Metadata: {\n          originalFilename: filename,\n          jobId,\n        },\n      }).promise();\n      \n      logger.info('PDF uploaded', { jobId, key });\n      \n      // Return the S3 URL\n      if (config.localstack.useLocalStack) {\n        return `${config.localstack.endpoint}/${config.s3.bucketName}/${key}`;\n      }\n      return `https://${config.s3.bucketName}.s3.${config.aws.region}.amazonaws.com/${key}`;\n    } catch (error) {\n      handleS3Error(error, 'uploadPDF');\n    }\n  }, { maxAttempts: 3, initialDelayMs: 1000 });\n}\n\nexport async function downloadPDF(jobId: string): Promise<Buffer> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    const result = await s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('PDF downloaded', { jobId, key });\n    return result.Body as Buffer;\n  } catch (error) {\n    handleS3Error(error, 'downloadPDF');\n  }\n}\n\nexport async function streamPDF(jobId: string): Promise<Readable> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    const stream = s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).createReadStream();\n    \n    logger.info('PDF stream created', { jobId, key });\n    return stream;\n  } catch (error) {\n    handleS3Error(error, 'streamPDF');\n  }\n}\n\nexport async function deletePDF(jobId: string): Promise<void> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    await s3.deleteObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('PDF deleted', { jobId, key });\n  } catch (error) {\n    handleS3Error(error, 'deletePDF');\n  }\n}\n\nexport async function getPDFSignedUrl(jobId: string, expiresIn: number = 3600): Promise<string> {\n  try {\n    const key = `${config.s3.pdfPrefix}/${jobId}/original.pdf`;\n    \n    const url = s3.getSignedUrl('getObject', {\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Expires: expiresIn,\n    });\n    \n    logger.info('PDF signed URL generated', { jobId, expiresIn });\n    return url;\n  } catch (error) {\n    handleS3Error(error, 'getPDFSignedUrl');\n  }\n}\n\n// ============================================================================\n// Audio Operations\n// ============================================================================\n\nexport async function uploadAudio(jobId: string, audioBuffer: Buffer): Promise<string> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    await s3.putObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Body: audioBuffer,\n      ContentType: 'audio/mpeg',\n      Metadata: {\n        jobId,\n      },\n    }).promise();\n    \n    logger.info('Audio uploaded', { jobId, key });\n    \n    // Return the S3 URL\n    if (config.localstack.useLocalStack) {\n      return `${config.localstack.endpoint}/${config.s3.bucketName}/${key}`;\n    }\n    return `https://${config.s3.bucketName}.s3.${config.aws.region}.amazonaws.com/${key}`;\n  } catch (error) {\n    handleS3Error(error, 'uploadAudio');\n  }\n}\n\nexport async function downloadAudio(jobId: string): Promise<Buffer> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    const result = await s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('Audio downloaded', { jobId, key });\n    return result.Body as Buffer;\n  } catch (error) {\n    handleS3Error(error, 'downloadAudio');\n  }\n}\n\nexport async function streamAudio(jobId: string): Promise<Readable> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    const stream = s3.getObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).createReadStream();\n    \n    logger.info('Audio stream created', { jobId, key });\n    return stream;\n  } catch (error) {\n    handleS3Error(error, 'streamAudio');\n  }\n}\n\nexport async function deleteAudio(jobId: string): Promise<void> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    await s3.deleteObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n    }).promise();\n    \n    logger.info('Audio deleted', { jobId, key });\n  } catch (error) {\n    handleS3Error(error, 'deleteAudio');\n  }\n}\n\nexport async function getAudioSignedUrl(jobId: string, expiresIn: number = 3600): Promise<string> {\n  try {\n    const key = `${config.s3.audioPrefix}/${jobId}/lecture.mp3`;\n    \n    const url = s3.getSignedUrl('getObject', {\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Expires: expiresIn,\n    });\n    \n    logger.info('Audio signed URL generated', { jobId, expiresIn });\n    return url;\n  } catch (error) {\n    handleS3Error(error, 'getAudioSignedUrl');\n  }\n}\n\n// ============================================================================\n// Cache Operations (for figures, etc.)\n// ============================================================================\n\nexport async function uploadCacheFile(\n  jobId: string,\n  fileType: 'figure' | 'table',\n  fileId: string,\n  buffer: Buffer,\n  contentType: string\n): Promise<string> {\n  try {\n    const extension = contentType.includes('png') ? 'png' : 'jpg';\n    const key = `${config.s3.cachePrefix}/${jobId}/${fileType}s/${fileId}.${extension}`;\n    \n    await s3.putObject({\n      Bucket: config.s3.bucketName,\n      Key: key,\n      Body: buffer,\n      ContentType: contentType,\n      Metadata: {\n        jobId,\n        fileType,\n        fileId,\n      },\n    }).promise();\n    \n    logger.info('Cache file uploaded', { jobId, fileType, fileId, key });\n    \n    // Return the S3 URL\n    if (config.localstack.useLocalStack) {\n      return `${config.localstack.endpoint}/${config.s3.bucketName}/${key}`;\n    }\n    return `https://${config.s3.bucketName}.s3.${config.aws.region}.amazonaws.com/${key}`;\n  } catch (error) {\n    handleS3Error(error, 'uploadCacheFile');\n  }\n}\n\nexport async function downloadCacheFile(jobId: string, fileType: string, fileId: string): Promise<Buffer> {\n  try {\n    // Try both png and jpg extensions\n    const extensions = ['png', 'jpg'];\n    let lastError: any;\n    \n    for (const ext of extensions) {\n      try {\n        const key = `${config.s3.cachePrefix}/${jobId}/${fileType}s/${fileId}.${ext}`;\n        const result = await s3.getObject({\n          Bucket: config.s3.bucketName,\n          Key: key,\n        }).promise();\n        \n        logger.info('Cache file downloaded', { jobId, fileType, fileId, key });\n        return result.Body as Buffer;\n      } catch (error: any) {\n        lastError = error;\n        if (error.code !== 'NoSuchKey') {\n          throw error;\n        }\n      }\n    }\n    \n    throw lastError;\n  } catch (error) {\n    handleS3Error(error, 'downloadCacheFile');\n  }\n}\n\nexport async function deleteCacheFiles(jobId: string): Promise<void> {\n  try {\n    const prefix = `${config.s3.cachePrefix}/${jobId}/`;\n    \n    // List all objects with the prefix\n    const listResult = await s3.listObjectsV2({\n      Bucket: config.s3.bucketName,\n      Prefix: prefix,\n    }).promise();\n    \n    if (!listResult.Contents || listResult.Contents.length === 0) {\n      logger.info('No cache files to delete', { jobId });\n      return;\n    }\n    \n    // Delete all objects\n    await s3.deleteObjects({\n      Bucket: config.s3.bucketName,\n      Delete: {\n        Objects: listResult.Contents.map(obj => ({ Key: obj.Key! })),\n      },\n    }).promise();\n    \n    logger.info('Cache files deleted', { jobId, count: listResult.Contents.length });\n  } catch (error) {\n    handleS3Error(error, 'deleteCacheFiles');\n  }\n}\n\n// ============================================================================\n// Bucket Management (for local development)\n// ============================================================================\n\nexport async function createBucketIfNotExists(): Promise<void> {\n  if (!config.localstack.useLocalStack) {\n    logger.info('Skipping bucket creation in production mode');\n    return;\n  }\n  \n  try {\n    await s3.headBucket({ Bucket: config.s3.bucketName }).promise();\n    logger.info(`Bucket ${config.s3.bucketName} already exists`);\n  } catch (error: any) {\n    if (error.code === 'NotFound' || error.code === 'NoSuchBucket') {\n      try {\n        await s3.createBucket({ Bucket: config.s3.bucketName }).promise();\n        logger.info(`Bucket ${config.s3.bucketName} created`);\n      } catch (createError) {\n        logger.error(`Failed to create bucket ${config.s3.bucketName}`, { error: createError });\n      }\n    } else {\n      logger.error('Error checking bucket existence', { error });\n    }\n  }\n}\n\n// ============================================================================\n// Cleanup Operations\n// ============================================================================\n\nexport async function deleteAllJobFiles(jobId: string): Promise<void> {\n  try {\n    await Promise.all([\n      deletePDF(jobId).catch(err => logger.warn('Failed to delete PDF', { jobId, error: err.message })),\n      deleteAudio(jobId).catch(err => logger.warn('Failed to delete audio', { jobId, error: err.message })),\n      deleteCacheFiles(jobId).catch(err => logger.warn('Failed to delete cache files', { jobId, error: err.message })),\n    ]);\n    \n    logger.info('All job files deleted', { jobId });\n  } catch (error) {\n    logger.error('Error during job file cleanup', { jobId, error });\n  }\n}\n", "// Retry logic and circuit breaker utilities\n\nimport { logger } from './logger';\nimport { ExternalServiceError, ResourceError } from './errors';\n\nexport interface RetryOptions {\n  maxAttempts?: number;\n  initialDelayMs?: number;\n  maxDelayMs?: number;\n  backoffMultiplier?: number;\n  retryableErrors?: string[];\n}\n\nconst DEFAULT_RETRY_OPTIONS: Required<RetryOptions> = {\n  maxAttempts: 3,\n  initialDelayMs: 1000,\n  maxDelayMs: 10000,\n  backoffMultiplier: 2,\n  retryableErrors: ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND', 'ECONNREFUSED'],\n};\n\n/**\n * Delays execution for the specified number of milliseconds\n */\nfunction delay(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Determines if an error is retryable\n */\nfunction isRetryableError(error: any, retryableErrors: string[]): boolean {\n  if (!error) return false;\n  \n  // Check if error has retryable flag\n  if (typeof error.retryable === 'boolean') {\n    return error.retryable;\n  }\n  \n  // Check error name (for custom error classes)\n  if (error.name && retryableErrors.includes(error.name)) {\n    return true;\n  }\n  \n  // Check error code\n  if (error.code && retryableErrors.includes(error.code)) {\n    return true;\n  }\n  \n  // Check for common transient error messages\n  const message = error.message?.toLowerCase() || '';\n  return (\n    message.includes('timeout') ||\n    message.includes('connection') ||\n    message.includes('network') ||\n    message.includes('temporary') ||\n    message.includes('rate limit') ||\n    message.includes('429') ||\n    message.includes('too many requests')\n  );\n}\n\n/**\n * Executes a function with exponential backoff retry logic\n * @param fn Function to execute\n * @param options Retry configuration options\n * @returns Result of the function\n * @throws Last error if all retries fail\n */\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const opts = { ...DEFAULT_RETRY_OPTIONS, ...options };\n  let lastError: any;\n  let delayMs = opts.initialDelayMs;\n  \n  for (let attempt = 1; attempt <= opts.maxAttempts; attempt++) {\n    try {\n      const result = await fn();\n      \n      if (attempt > 1) {\n        logger.info('Operation succeeded after retry', { attempt });\n      }\n      \n      return result;\n    } catch (error) {\n      lastError = error;\n      \n      const isRetryable = isRetryableError(error, opts.retryableErrors);\n      const isLastAttempt = attempt === opts.maxAttempts;\n      \n      logger.warn('Operation failed', {\n        attempt,\n        maxAttempts: opts.maxAttempts,\n        isRetryable,\n        error: error instanceof Error ? error.message : String(error),\n      });\n      \n      if (!isRetryable || isLastAttempt) {\n        throw error;\n      }\n      \n      // Wait before retrying\n      logger.info('Retrying operation', { attempt, delayMs });\n      await delay(delayMs);\n      \n      // Increase delay for next attempt (exponential backoff)\n      delayMs = Math.min(delayMs * opts.backoffMultiplier, opts.maxDelayMs);\n    }\n  }\n  \n  throw lastError;\n}\n\n// ============================================================================\n// Circuit Breaker\n// ============================================================================\n\nexport enum CircuitState {\n  CLOSED = 'CLOSED',     // Normal operation\n  OPEN = 'OPEN',         // Failing, reject requests\n  HALF_OPEN = 'HALF_OPEN', // Testing if service recovered\n}\n\nexport interface CircuitBreakerOptions {\n  failureThreshold?: number;\n  successThreshold?: number;\n  timeout?: number;\n  resetTimeoutMs?: number;\n}\n\nconst DEFAULT_CIRCUIT_OPTIONS: Required<CircuitBreakerOptions> = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeout: 30000,\n  resetTimeoutMs: 60000,\n};\n\n/**\n * Circuit breaker implementation for external service calls\n */\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failureCount = 0;\n  private successCount = 0;\n  private nextAttemptTime = 0;\n  private readonly options: Required<CircuitBreakerOptions>;\n  \n  constructor(\n    private readonly serviceName: string,\n    options: CircuitBreakerOptions = {}\n  ) {\n    this.options = { ...DEFAULT_CIRCUIT_OPTIONS, ...options };\n  }\n  \n  /**\n   * Executes a function with circuit breaker protection\n   */\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    if (this.state === CircuitState.OPEN) {\n      if (Date.now() < this.nextAttemptTime) {\n        logger.warn('Circuit breaker is OPEN, rejecting request', {\n          service: this.serviceName,\n          nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n        });\n        throw new ExternalServiceError(\n          `Service ${this.serviceName} is currently unavailable (circuit breaker OPEN)`,\n          this.serviceName\n        );\n      }\n      \n      // Try to recover\n      this.state = CircuitState.HALF_OPEN;\n      this.successCount = 0;\n      logger.info('Circuit breaker entering HALF_OPEN state', {\n        service: this.serviceName,\n      });\n    }\n    \n    try {\n      // Execute with timeout\n      const result = await this.executeWithTimeout(fn);\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  /**\n   * Executes function with timeout\n   */\n  private async executeWithTimeout<T>(fn: () => Promise<T>): Promise<T> {\n    return Promise.race([\n      fn(),\n      new Promise<T>((_, reject) =>\n        setTimeout(\n          () => reject(new ResourceError('Operation timeout', { timeout: this.options.timeout })),\n          this.options.timeout\n        )\n      ),\n    ]);\n  }\n  \n  /**\n   * Handles successful execution\n   */\n  private onSuccess(): void {\n    this.failureCount = 0;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      this.successCount++;\n      \n      if (this.successCount >= this.options.successThreshold) {\n        this.state = CircuitState.CLOSED;\n        this.successCount = 0;\n        logger.info('Circuit breaker closed', { service: this.serviceName });\n      }\n    }\n  }\n  \n  /**\n   * Handles failed execution\n   */\n  private onFailure(): void {\n    this.failureCount++;\n    this.successCount = 0;\n    \n    if (this.state === CircuitState.HALF_OPEN) {\n      this.state = CircuitState.OPEN;\n      this.nextAttemptTime = Date.now() + this.options.resetTimeoutMs;\n      logger.warn('Circuit breaker opened from HALF_OPEN', {\n        service: this.serviceName,\n        nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n      });\n    } else if (this.failureCount >= this.options.failureThreshold) {\n      this.state = CircuitState.OPEN;\n      this.nextAttemptTime = Date.now() + this.options.resetTimeoutMs;\n      logger.warn('Circuit breaker opened', {\n        service: this.serviceName,\n        failureCount: this.failureCount,\n        nextAttemptTime: new Date(this.nextAttemptTime).toISOString(),\n      });\n    }\n  }\n  \n  /**\n   * Gets current circuit breaker state\n   */\n  getState(): CircuitState {\n    return this.state;\n  }\n  \n  /**\n   * Resets circuit breaker to closed state\n   */\n  reset(): void {\n    this.state = CircuitState.CLOSED;\n    this.failureCount = 0;\n    this.successCount = 0;\n    this.nextAttemptTime = 0;\n    logger.info('Circuit breaker manually reset', { service: this.serviceName });\n  }\n}\n\n// ============================================================================\n// Global Circuit Breakers\n// ============================================================================\n\nconst circuitBreakers = new Map<string, CircuitBreaker>();\n\n/**\n * Gets or creates a circuit breaker for a service\n */\nexport function getCircuitBreaker(\n  serviceName: string,\n  options?: CircuitBreakerOptions\n): CircuitBreaker {\n  if (!circuitBreakers.has(serviceName)) {\n    circuitBreakers.set(serviceName, new CircuitBreaker(serviceName, options));\n  }\n  return circuitBreakers.get(serviceName)!;\n}\n\n/**\n * Executes a function with both retry logic and circuit breaker protection\n */\nexport async function withRetryAndCircuitBreaker<T>(\n  serviceName: string,\n  fn: () => Promise<T>,\n  retryOptions?: RetryOptions,\n  circuitOptions?: CircuitBreakerOptions\n): Promise<T> {\n  const circuitBreaker = getCircuitBreaker(serviceName, circuitOptions);\n  \n  return withRetry(\n    () => circuitBreaker.execute(fn),\n    retryOptions\n  );\n}\n", "// DynamoDB client wrapper with local/production mode support\nimport AWS from 'aws-sdk';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\nimport { Job, JobStatus, StageStatus } from '../models/job';\nimport { LectureAgent } from '../models/agent';\nimport { ExtractedContent, SegmentedContent } from '../models/content';\nimport { WordTiming } from '../models/audio';\n\n// Configure AWS SDK based on environment\nconst dynamoDBConfig: AWS.DynamoDB.ClientConfiguration = {\n  region: config.aws.region,\n};\n\nif (config.localstack.useLocalStack) {\n  dynamoDBConfig.endpoint = config.localstack.endpoint;\n  dynamoDBConfig.accessKeyId = 'test';\n  dynamoDBConfig.secretAccessKey = 'test';\n} else if (config.aws.accessKeyId && config.aws.secretAccessKey) {\n  dynamoDBConfig.accessKeyId = config.aws.accessKeyId;\n  dynamoDBConfig.secretAccessKey = config.aws.secretAccessKey;\n}\n\nconst dynamoDB = new AWS.DynamoDB.DocumentClient(dynamoDBConfig);\n\n// Helper function to handle DynamoDB errors\nfunction handleDynamoDBError(error: any, operation: string): never {\n  logger.error(`DynamoDB ${operation} failed`, { error: error.message });\n  throw new Error(`Database operation failed: ${operation}`);\n}\n\n// ============================================================================\n// Jobs Table Operations\n// ============================================================================\n\nexport interface JobRecord {\n  jobId: string;\n  status: JobStatus;\n  createdAt: string;\n  updatedAt: string;\n  pdfFilename: string;\n  pdfUrl: string;\n  agentId?: string;\n  stages: StageStatus[];\n  error?: string;\n}\n\nfunction jobToRecord(job: Job): JobRecord {\n  return {\n    ...job,\n    createdAt: job.createdAt.toISOString(),\n    updatedAt: job.updatedAt.toISOString(),\n  };\n}\n\nfunction recordToJob(record: JobRecord): Job {\n  return {\n    ...record,\n    createdAt: new Date(record.createdAt),\n    updatedAt: new Date(record.updatedAt),\n    stages: record.stages.map(stage => ({\n      ...stage,\n      startedAt: stage.startedAt ? new Date(stage.startedAt) : undefined,\n      completedAt: stage.completedAt ? new Date(stage.completedAt) : undefined,\n    })),\n  };\n}\n\nexport async function createJob(job: Job): Promise<Job> {\n  try {\n    const record = jobToRecord(job);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job created', { jobId: job.jobId });\n    return job;\n  } catch (error) {\n    handleDynamoDBError(error, 'createJob');\n  }\n}\n\nexport async function getJob(jobId: string): Promise<Job | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToJob(result.Item as JobRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getJob');\n  }\n}\n\nexport async function updateJob(jobId: string, updates: Partial<Job>): Promise<Job> {\n  try {\n    const current = await getJob(jobId);\n    if (!current) {\n      throw new Error(`Job not found: ${jobId}`);\n    }\n    \n    const updated: Job = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date(),\n    };\n    \n    const record = jobToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.jobsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Job updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateJob');\n  }\n}\n\nexport async function deleteJob(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.jobsTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Job deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteJob');\n  }\n}\n\nexport async function listJobs(): Promise<Job[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.jobsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToJob(item as JobRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listJobs');\n  }\n}\n\n// ============================================================================\n// Agents Table Operations\n// ============================================================================\n\nexport interface AgentRecord {\n  id: string;\n  name: string;\n  description: string;\n  personality: {\n    instructions: string;\n    tone: string;\n    examples?: string[];\n  };\n  voice: {\n    voiceId: string;\n    speed: number;\n    pitch: number;\n  };\n  createdAt: string;\n}\n\nfunction agentToRecord(agent: LectureAgent): AgentRecord {\n  return {\n    ...agent,\n    createdAt: agent.createdAt.toISOString(),\n  };\n}\n\nfunction recordToAgent(record: AgentRecord): LectureAgent {\n  return {\n    ...record,\n    personality: {\n      ...record.personality,\n      tone: record.personality.tone as any,\n    },\n    createdAt: new Date(record.createdAt),\n  };\n}\n\nexport async function createAgent(agent: LectureAgent): Promise<LectureAgent> {\n  try {\n    // Check for unique name\n    const existing = await listAgents();\n    if (existing.some(a => a.name === agent.name && a.id !== agent.id)) {\n      throw new Error(`Agent with name \"${agent.name}\" already exists`);\n    }\n    \n    const record = agentToRecord(agent);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent created', { agentId: agent.id, name: agent.name });\n    return agent;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('already exists')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'createAgent');\n  }\n}\n\nexport async function getAgent(id: string): Promise<LectureAgent | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return recordToAgent(result.Item as AgentRecord);\n  } catch (error) {\n    handleDynamoDBError(error, 'getAgent');\n  }\n}\n\nexport async function updateAgent(id: string, updates: Partial<LectureAgent>): Promise<LectureAgent> {\n  try {\n    const current = await getAgent(id);\n    if (!current) {\n      throw new Error(`Agent not found: ${id}`);\n    }\n    \n    // Check for unique name if name is being updated\n    if (updates.name && updates.name !== current.name) {\n      const existing = await listAgents();\n      if (existing.some(a => a.name === updates.name && a.id !== id)) {\n        throw new Error(`Agent with name \"${updates.name}\" already exists`);\n      }\n    }\n    \n    const updated: LectureAgent = {\n      ...current,\n      ...updates,\n      id, // Ensure id doesn't change\n      // Deep merge nested objects\n      personality: updates.personality ? {\n        ...current.personality,\n        ...updates.personality,\n      } : current.personality,\n      voice: updates.voice ? {\n        ...current.voice,\n        ...updates.voice,\n      } : current.voice,\n    };\n    \n    const record = agentToRecord(updated);\n    await dynamoDB.put({\n      TableName: config.dynamodb.agentsTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Agent updated', { agentId: id });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && (error.message.includes('already exists') || error.message.includes('not found'))) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateAgent');\n  }\n}\n\nexport async function deleteAgent(id: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.agentsTable,\n      Key: { id },\n    }).promise();\n    \n    logger.info('Agent deleted', { agentId: id });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteAgent');\n  }\n}\n\nexport async function listAgents(): Promise<LectureAgent[]> {\n  try {\n    const result = await dynamoDB.scan({\n      TableName: config.dynamodb.agentsTable,\n    }).promise();\n    \n    return (result.Items || []).map(item => recordToAgent(item as AgentRecord));\n  } catch (error) {\n    handleDynamoDBError(error, 'listAgents');\n  }\n}\n\n// ============================================================================\n// Content Table Operations\n// ============================================================================\n\nexport interface ContentRecord {\n  jobId: string;\n  extractedContent?: ExtractedContent;\n  segmentedContent?: SegmentedContent;\n  script?: any; // LectureScript type from script model\n  audioUrl?: string;\n  wordTimings?: WordTiming[];\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport async function createContent(jobId: string): Promise<ContentRecord> {\n  try {\n    const record: ContentRecord = {\n      jobId,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: record,\n    }).promise();\n    \n    logger.info('Content record created', { jobId });\n    return record;\n  } catch (error) {\n    handleDynamoDBError(error, 'createContent');\n  }\n}\n\nexport async function getContent(jobId: string): Promise<ContentRecord | null> {\n  try {\n    const result = await dynamoDB.get({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    if (!result.Item) {\n      return null;\n    }\n    \n    return result.Item as ContentRecord;\n  } catch (error) {\n    handleDynamoDBError(error, 'getContent');\n  }\n}\n\nexport async function updateContent(jobId: string, updates: Partial<ContentRecord>): Promise<ContentRecord> {\n  try {\n    const current = await getContent(jobId);\n    if (!current) {\n      throw new Error(`Content not found for job: ${jobId}`);\n    }\n    \n    const updated: ContentRecord = {\n      ...current,\n      ...updates,\n      jobId, // Ensure jobId doesn't change\n      updatedAt: new Date().toISOString(),\n    };\n    \n    await dynamoDB.put({\n      TableName: config.dynamodb.contentTable,\n      Item: updated,\n    }).promise();\n    \n    logger.info('Content updated', { jobId });\n    return updated;\n  } catch (error) {\n    if (error instanceof Error && error.message.includes('not found')) {\n      throw error;\n    }\n    handleDynamoDBError(error, 'updateContent');\n  }\n}\n\nexport async function deleteContent(jobId: string): Promise<void> {\n  try {\n    await dynamoDB.delete({\n      TableName: config.dynamodb.contentTable,\n      Key: { jobId },\n    }).promise();\n    \n    logger.info('Content deleted', { jobId });\n  } catch (error) {\n    handleDynamoDBError(error, 'deleteContent');\n  }\n}\n\n// ============================================================================\n// Table Creation (for local development)\n// ============================================================================\n\nexport async function createTablesIfNotExist(): Promise<void> {\n  if (!config.localstack.useLocalStack) {\n    logger.info('Skipping table creation in production mode');\n    return;\n  }\n  \n  const dynamoDBClient = new AWS.DynamoDB(dynamoDBConfig);\n  \n  const tables = [\n    {\n      TableName: config.dynamodb.jobsTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.agentsTable,\n      KeySchema: [{ AttributeName: 'id', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'id', AttributeType: 'S' }],\n    },\n    {\n      TableName: config.dynamodb.contentTable,\n      KeySchema: [{ AttributeName: 'jobId', KeyType: 'HASH' }],\n      AttributeDefinitions: [{ AttributeName: 'jobId', AttributeType: 'S' }],\n    },\n  ];\n  \n  for (const tableConfig of tables) {\n    try {\n      await dynamoDBClient.describeTable({ TableName: tableConfig.TableName }).promise();\n      logger.info(`Table ${tableConfig.TableName} already exists`);\n    } catch (error: any) {\n      if (error.code === 'ResourceNotFoundException') {\n        try {\n          await dynamoDBClient.createTable({\n            ...tableConfig,\n            BillingMode: 'PAY_PER_REQUEST',\n          }).promise();\n          logger.info(`Table ${tableConfig.TableName} created`);\n        } catch (createError) {\n          logger.error(`Failed to create table ${tableConfig.TableName}`, { error: createError });\n        }\n      }\n    }\n  }\n}\n", "// EventBridge service for asynchronous function triggering\nimport { EventBridge } from 'aws-sdk';\nimport { config } from '../utils/config';\nimport { logger } from '../utils/logger';\n\nconst eventBridge = new EventBridge({\n  endpoint: config.isLocal ? 'http://localhost:4566' : undefined,\n  region: config.awsRegion,\n});\n\nexport interface PipelineEvent {\n  jobId: string;\n  agentId?: string;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Publish an event to EventBridge to trigger the next stage in the pipeline\n */\nexport async function publishPipelineEvent(\n  detailType: string,\n  detail: PipelineEvent\n): Promise<void> {\n  const eventBusName = config.eventBusName || 'pdf-lecture-service-events';\n  \n  try {\n    logger.info('Publishing pipeline event', { detailType, jobId: detail.jobId });\n    \n    const params: EventBridge.PutEventsRequest = {\n      Entries: [\n        {\n          Source: 'pdf-lecture-service',\n          DetailType: detailType,\n          Detail: JSON.stringify(detail),\n          EventBusName: eventBusName,\n        },\n      ],\n    };\n    \n    const result = await eventBridge.putEvents(params).promise();\n    \n    if (result.FailedEntryCount && result.FailedEntryCount > 0) {\n      const errors = result.Entries?.filter(e => e.ErrorCode).map(e => ({\n        code: e.ErrorCode,\n        message: e.ErrorMessage,\n      }));\n      throw new Error(`Failed to publish event: ${JSON.stringify(errors)}`);\n    }\n    \n    logger.info('Pipeline event published successfully', { detailType, jobId: detail.jobId });\n  } catch (error) {\n    logger.error('Failed to publish pipeline event', { error, detailType, jobId: detail.jobId });\n    throw error;\n  }\n}\n\n/**\n * Trigger the content analysis stage\n */\nexport async function triggerAnalysis(jobId: string): Promise<void> {\n  await publishPipelineEvent('JobCreated', { jobId });\n}\n\n/**\n * Trigger the content segmentation stage\n */\nexport async function triggerSegmentation(jobId: string): Promise<void> {\n  await publishPipelineEvent('AnalysisCompleted', { jobId });\n}\n\n/**\n * Trigger the script generation stage\n */\nexport async function triggerScriptGeneration(jobId: string, agentId?: string): Promise<void> {\n  await publishPipelineEvent('SegmentationCompleted', { jobId, agentId });\n}\n\n/**\n * Trigger the audio synthesis stage\n */\nexport async function triggerAudioSynthesis(jobId: string): Promise<void> {\n  await publishPipelineEvent('ScriptGenerationCompleted', { jobId });\n}\n\n/**\n * Publish a job completion event\n */\nexport async function publishJobCompleted(jobId: string): Promise<void> {\n  await publishPipelineEvent('JobCompleted', { jobId });\n}\n\n/**\n * Publish a job failure event\n */\nexport async function publishJobFailed(jobId: string, error: string): Promise<void> {\n  await publishPipelineEvent('JobFailed', { \n    jobId, \n    metadata: { error } \n  });\n}\n", "// Metrics collection utility for tracking request counts, error rates, processing times, and storage usage\n\nimport { logger } from './logger';\n\nexport enum MetricType {\n  COUNT = 'Count',\n  DURATION = 'Duration',\n  SIZE = 'Size',\n  RATE = 'Rate',\n}\n\nexport enum MetricUnit {\n  COUNT = 'Count',\n  MILLISECONDS = 'Milliseconds',\n  SECONDS = 'Seconds',\n  BYTES = 'Bytes',\n  MEGABYTES = 'Megabytes',\n  PERCENT = 'Percent',\n}\n\ninterface MetricData {\n  name: string;\n  value: number;\n  unit: MetricUnit;\n  timestamp: Date;\n  dimensions?: Record<string, string>;\n}\n\ninterface TimerHandle {\n  name: string;\n  startTime: number;\n  dimensions?: Record<string, string>;\n}\n\nclass MetricsCollector {\n  private metrics: MetricData[] = [];\n  private activeTimers: Map<string, TimerHandle> = new Map();\n\n  /**\n   * Record a count metric (e.g., request count, error count)\n   */\n  recordCount(name: string, value: number = 1, dimensions?: Record<string, string>) {\n    this.recordMetric(name, value, MetricUnit.COUNT, dimensions);\n  }\n\n  /**\n   * Record a duration metric in milliseconds\n   */\n  recordDuration(name: string, durationMs: number, dimensions?: Record<string, string>) {\n    this.recordMetric(name, durationMs, MetricUnit.MILLISECONDS, dimensions);\n  }\n\n  /**\n   * Record a size metric in bytes\n   */\n  recordSize(name: string, sizeBytes: number, dimensions?: Record<string, string>) {\n    this.recordMetric(name, sizeBytes, MetricUnit.BYTES, dimensions);\n  }\n\n  /**\n   * Record a rate metric (e.g., error rate as percentage)\n   */\n  recordRate(name: string, rate: number, dimensions?: Record<string, string>) {\n    this.recordMetric(name, rate, MetricUnit.PERCENT, dimensions);\n  }\n\n  /**\n   * Start a timer for measuring duration\n   */\n  startTimer(name: string, dimensions?: Record<string, string>): string {\n    const timerId = `${name}-${Date.now()}-${Math.random()}`;\n    this.activeTimers.set(timerId, {\n      name,\n      startTime: Date.now(),\n      dimensions,\n    });\n    return timerId;\n  }\n\n  /**\n   * Stop a timer and record the duration\n   */\n  stopTimer(timerId: string): number | null {\n    const timer = this.activeTimers.get(timerId);\n    if (!timer) {\n      logger.warn('Attempted to stop non-existent timer', { timerId });\n      return null;\n    }\n\n    const duration = Date.now() - timer.startTime;\n    this.recordDuration(timer.name, duration, timer.dimensions);\n    this.activeTimers.delete(timerId);\n    return duration;\n  }\n\n  /**\n   * Record a generic metric\n   */\n  private recordMetric(\n    name: string,\n    value: number,\n    unit: MetricUnit,\n    dimensions?: Record<string, string>\n  ) {\n    const metric: MetricData = {\n      name,\n      value,\n      unit,\n      timestamp: new Date(),\n      dimensions,\n    };\n\n    this.metrics.push(metric);\n\n    // Log the metric for CloudWatch ingestion\n    logger.info('Metric recorded', {\n      metric: {\n        name: metric.name,\n        value: metric.value,\n        unit: metric.unit,\n        dimensions: metric.dimensions,\n      },\n    });\n\n    // In production, this would also publish to CloudWatch\n    if (process.env.NODE_ENV === 'production') {\n      this.publishToCloudWatch(metric);\n    }\n  }\n\n  /**\n   * Publish metric to CloudWatch\n   */\n  private async publishToCloudWatch(metric: MetricData) {\n    // Dynamically import to avoid circular dependencies\n    const { publishMetric } = await import('./cloudwatch');\n    \n    await publishMetric({\n      name: metric.name,\n      value: metric.value,\n      unit: metric.unit,\n      dimensions: metric.dimensions,\n      timestamp: metric.timestamp,\n    });\n  }\n\n  /**\n   * Get all recorded metrics (useful for testing)\n   */\n  getMetrics(): MetricData[] {\n    return [...this.metrics];\n  }\n\n  /**\n   * Clear all recorded metrics\n   */\n  clearMetrics() {\n    this.metrics = [];\n  }\n}\n\n// Singleton instance\nexport const metrics = new MetricsCollector();\n\n/**\n * Decorator for measuring function execution time\n */\nexport function measureExecutionTime(metricName: string, dimensions?: Record<string, string>) {\n  return function (\n    _target: any,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: any[]) {\n      const timerId = metrics.startTimer(metricName, dimensions);\n      try {\n        const result = await originalMethod.apply(this, args);\n        metrics.stopTimer(timerId);\n        return result;\n      } catch (error) {\n        metrics.stopTimer(timerId);\n        throw error;\n      }\n    };\n\n    return descriptor;\n  };\n}\n\n/**\n * Helper to track request metrics\n */\nexport class RequestMetrics {\n  private requestCount = 0;\n  private errorCount = 0;\n  private successCount = 0;\n\n  incrementRequest(endpoint: string) {\n    this.requestCount++;\n    metrics.recordCount('RequestCount', 1, { endpoint });\n  }\n\n  incrementError(endpoint: string, errorType?: string) {\n    this.errorCount++;\n    metrics.recordCount('ErrorCount', 1, { endpoint, errorType: errorType || 'Unknown' });\n  }\n\n  incrementSuccess(endpoint: string) {\n    this.successCount++;\n    metrics.recordCount('SuccessCount', 1, { endpoint });\n  }\n\n  getErrorRate(): number {\n    if (this.requestCount === 0) return 0;\n    return (this.errorCount / this.requestCount) * 100;\n  }\n\n  recordErrorRate(endpoint: string) {\n    const rate = this.getErrorRate();\n    metrics.recordRate('ErrorRate', rate, { endpoint });\n  }\n}\n\n/**\n * Helper to track processing stage metrics\n */\nexport class StageMetrics {\n  recordStageStart(stage: string, jobId: string) {\n    metrics.recordCount('StageStarted', 1, { stage, jobId });\n  }\n\n  recordStageComplete(stage: string, jobId: string, durationMs: number) {\n    metrics.recordCount('StageCompleted', 1, { stage, jobId });\n    metrics.recordDuration('StageDuration', durationMs, { stage, jobId });\n  }\n\n  recordStageFailed(stage: string, jobId: string, errorType: string) {\n    metrics.recordCount('StageFailed', 1, { stage, jobId, errorType });\n  }\n}\n\n/**\n * Helper to track external API metrics\n */\nexport class ExternalAPIMetrics {\n  recordAPICall(apiName: string, operation: string) {\n    metrics.recordCount('ExternalAPICall', 1, { apiName, operation });\n  }\n\n  recordAPILatency(apiName: string, operation: string, latencyMs: number) {\n    metrics.recordDuration('ExternalAPILatency', latencyMs, { apiName, operation });\n  }\n\n  recordAPIError(apiName: string, operation: string, errorType: string) {\n    metrics.recordCount('ExternalAPIError', 1, { apiName, operation, errorType });\n  }\n}\n\n/**\n * Helper to track storage metrics\n */\nexport class StorageMetrics {\n  recordStorageWrite(storageType: string, sizeBytes: number) {\n    metrics.recordCount('StorageWrite', 1, { storageType });\n    metrics.recordSize('StorageWriteSize', sizeBytes, { storageType });\n  }\n\n  recordStorageRead(storageType: string, sizeBytes: number) {\n    metrics.recordCount('StorageRead', 1, { storageType });\n    metrics.recordSize('StorageReadSize', sizeBytes, { storageType });\n  }\n\n  recordStorageUsage(storageType: string, totalBytes: number) {\n    metrics.recordSize('StorageUsage', totalBytes, { storageType });\n  }\n}\n"],
  "mappings": "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",
  "names": ["require_package", "__commonJSMin", "exports", "module", "require_main", "__commonJSMin", "exports", "module", "fs", "path", "os", "crypto", "packageJson", "version", "LINE", "parse", "src", "obj", "lines", "match", "key", "value", "maybeQuote", "_parseVault", "options", "vaultPath", "_vaultPath", "result", "DotenvModule", "err", "keys", "_dotenvKey", "length", "decrypted", "i", "attrs", "_instructions", "error", "_warn", "message", "_debug", "_log", "dotenvKey", "uri", "environment", "environmentKey", "ciphertext", "possibleVaultPath", "filepath", "_resolveHome", "envPath", "_configVault", "debug", "quiet", "parsed", "processEnv", "configDotenv", "dotenvPath", "encoding", "optionPaths", "lastError", "parsedAll", "e", "keysCount", "shortPaths", "filePath", "relative", "config", "decrypt", "encrypted", "keyStr", "nonce", "authTag", "aesgcm", "isRange", "invalidKeyLength", "decryptionFailed", "populate", "override", "import_dotenv", "config", "init_config", "__esmMin", "dotenv", "SENSITIVE_PATTERNS", "Logger", "logger", "init_logger", "__esmMin", "_Logger", "envLogLevel", "id", "name", "data", "item", "redacted", "key", "value", "pattern", "level", "levels", "currentLevelIndex", "minLevelIndex", "message", "metadata", "entry", "correlationId", "childLogger", "cloudwatch_exports", "__export", "createAlarm", "createStandardAlarmsForFunction", "publishMetric", "publishMetrics", "metric", "config", "logger", "dimensions", "name", "value", "cloudwatch", "error", "metrics", "metricData", "batchSize", "i", "batch", "params", "functionName", "timeoutMs", "AWS", "init_cloudwatch", "__esmMin", "init_config", "init_logger", "upload_exports", "__export", "uploadHandler", "__toCommonJS", "import_crypto", "init_config", "init_logger", "AppError", "message", "code", "statusCode", "retryable", "details", "jobId", "ValidationError", "ExternalServiceError", "AppError", "message", "service", "details", "ResourceError", "validateFileSize", "size", "maxSize", "ValidationError", "validatePDFFormat", "buffer", "header", "import_aws_sdk", "init_config", "init_logger", "init_logger", "DEFAULT_RETRY_OPTIONS", "delay", "ms", "resolve", "isRetryableError", "error", "retryableErrors", "message", "withRetry", "fn", "options", "opts", "lastError", "delayMs", "attempt", "result", "logger", "isRetryable", "isLastAttempt", "s3Config", "config", "s3", "AWS", "handleS3Error", "error", "operation", "logger", "ResourceError", "ExternalServiceError", "uploadPDF", "jobId", "pdfBuffer", "filename", "withRetry", "key", "import_aws_sdk", "init_config", "init_logger", "dynamoDBConfig", "config", "dynamoDB", "AWS", "handleDynamoDBError", "error", "operation", "logger", "jobToRecord", "job", "createJob", "job", "record", "jobToRecord", "dynamoDB", "config", "logger", "error", "handleDynamoDBError", "createContent", "jobId", "record", "dynamoDB", "config", "logger", "error", "handleDynamoDBError", "import_aws_sdk", "init_config", "init_logger", "eventBridge", "config", "publishPipelineEvent", "detailType", "detail", "eventBusName", "logger", "params", "result", "errors", "e", "error", "triggerAnalysis", "jobId", "validateUpload", "buffer", "filename", "maxSizeBytes", "config", "validateFileSize", "error", "ValidationError", "logger", "validatePDFFormat", "generateErrorResponse", "jobId", "AppError", "uploadError", "handleUpload", "request", "file", "agentId", "pdfUrl", "uploadPDF", "job", "initializeStages", "createJob", "createContent", "triggerAnalysis", "stage", "index", "init_logger", "init_logger", "MetricsCollector", "name", "value", "dimensions", "durationMs", "sizeBytes", "rate", "timerId", "timer", "logger", "duration", "unit", "metric", "publishMetric", "metrics", "RequestMetrics", "endpoint", "metrics", "errorType", "rate", "import_crypto", "requestMetrics", "RequestMetrics", "uploadHandler", "event", "correlationId", "logger", "timerId", "metrics", "request", "response", "handleUpload", "error", "errorType", "errorResponse", "generateErrorResponse", "statusCode", "code"]
}
